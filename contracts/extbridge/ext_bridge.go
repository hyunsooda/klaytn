// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package extbridge

import (
	"math/big"
	"strings"

	"github.com/klaytn/klaytn"
	"github.com/klaytn/klaytn/accounts/abi"
	"github.com/klaytn/klaytn/accounts/abi/bind"
	"github.com/klaytn/klaytn/blockchain/types"
	"github.com/klaytn/klaytn/common"
	"github.com/klaytn/klaytn/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = klaytn.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// AddressABI is the input ABI used to generate the binding from.
const AddressABI = "[]"

// AddressBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const AddressBinRuntime = `73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c4289861551a3b181d2909947054297a7b2550725cafc9ab6e921d0ed3bd6d9d64736f6c634300080d0033`

// AddressBin is the compiled bytecode used for deploying new contracts.
var AddressBin = "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c4289861551a3b181d2909947054297a7b2550725cafc9ab6e921d0ed3bd6d9d64736f6c634300080d0033"

// DeployAddress deploys a new Klaytn contract, binding an instance of Address to it.
func DeployAddress(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Address, error) {
	parsed, err := abi.JSON(strings.NewReader(AddressABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(AddressBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Address{AddressCaller: AddressCaller{contract: contract}, AddressTransactor: AddressTransactor{contract: contract}, AddressFilterer: AddressFilterer{contract: contract}}, nil
}

// Address is an auto generated Go binding around a Klaytn contract.
type Address struct {
	AddressCaller     // Read-only binding to the contract
	AddressTransactor // Write-only binding to the contract
	AddressFilterer   // Log filterer for contract events
}

// AddressCaller is an auto generated read-only Go binding around a Klaytn contract.
type AddressCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressTransactor is an auto generated write-only Go binding around a Klaytn contract.
type AddressTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type AddressFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type AddressSession struct {
	Contract     *Address          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AddressCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type AddressCallerSession struct {
	Contract *AddressCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// AddressTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type AddressTransactorSession struct {
	Contract     *AddressTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// AddressRaw is an auto generated low-level Go binding around a Klaytn contract.
type AddressRaw struct {
	Contract *Address // Generic contract binding to access the raw methods on
}

// AddressCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type AddressCallerRaw struct {
	Contract *AddressCaller // Generic read-only contract binding to access the raw methods on
}

// AddressTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type AddressTransactorRaw struct {
	Contract *AddressTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAddress creates a new instance of Address, bound to a specific deployed contract.
func NewAddress(address common.Address, backend bind.ContractBackend) (*Address, error) {
	contract, err := bindAddress(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Address{AddressCaller: AddressCaller{contract: contract}, AddressTransactor: AddressTransactor{contract: contract}, AddressFilterer: AddressFilterer{contract: contract}}, nil
}

// NewAddressCaller creates a new read-only instance of Address, bound to a specific deployed contract.
func NewAddressCaller(address common.Address, caller bind.ContractCaller) (*AddressCaller, error) {
	contract, err := bindAddress(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AddressCaller{contract: contract}, nil
}

// NewAddressTransactor creates a new write-only instance of Address, bound to a specific deployed contract.
func NewAddressTransactor(address common.Address, transactor bind.ContractTransactor) (*AddressTransactor, error) {
	contract, err := bindAddress(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AddressTransactor{contract: contract}, nil
}

// NewAddressFilterer creates a new log filterer instance of Address, bound to a specific deployed contract.
func NewAddressFilterer(address common.Address, filterer bind.ContractFilterer) (*AddressFilterer, error) {
	contract, err := bindAddress(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AddressFilterer{contract: contract}, nil
}

// bindAddress binds a generic wrapper to an already deployed contract.
func bindAddress(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AddressABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Address *AddressRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Address.Contract.AddressCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Address *AddressRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Address.Contract.AddressTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Address *AddressRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Address.Contract.AddressTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Address *AddressCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Address.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Address *AddressTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Address.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Address *AddressTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Address.Contract.contract.Transact(opts, method, params...)
}

// BridgeFeeABI is the input ABI used to generate the binding from.
const BridgeFeeABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ERC20FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"FeeReceiverChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"KLAYFeeChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeOfERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOfKLAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"addresspayable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// BridgeFeeBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const BridgeFeeBinRuntime = ``

// BridgeFeeFuncSigs maps the 4-byte function signature to its string representation.
var BridgeFeeFuncSigs = map[string]string{
	"488af871": "feeOfERC20(address)",
	"c263b5d6": "feeOfKLAY()",
	"b3f00674": "feeReceiver()",
}

// BridgeFee is an auto generated Go binding around a Klaytn contract.
type BridgeFee struct {
	BridgeFeeCaller     // Read-only binding to the contract
	BridgeFeeTransactor // Write-only binding to the contract
	BridgeFeeFilterer   // Log filterer for contract events
}

// BridgeFeeCaller is an auto generated read-only Go binding around a Klaytn contract.
type BridgeFeeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeFeeTransactor is an auto generated write-only Go binding around a Klaytn contract.
type BridgeFeeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeFeeFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type BridgeFeeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeFeeSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type BridgeFeeSession struct {
	Contract     *BridgeFee        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BridgeFeeCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type BridgeFeeCallerSession struct {
	Contract *BridgeFeeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// BridgeFeeTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type BridgeFeeTransactorSession struct {
	Contract     *BridgeFeeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// BridgeFeeRaw is an auto generated low-level Go binding around a Klaytn contract.
type BridgeFeeRaw struct {
	Contract *BridgeFee // Generic contract binding to access the raw methods on
}

// BridgeFeeCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type BridgeFeeCallerRaw struct {
	Contract *BridgeFeeCaller // Generic read-only contract binding to access the raw methods on
}

// BridgeFeeTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type BridgeFeeTransactorRaw struct {
	Contract *BridgeFeeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBridgeFee creates a new instance of BridgeFee, bound to a specific deployed contract.
func NewBridgeFee(address common.Address, backend bind.ContractBackend) (*BridgeFee, error) {
	contract, err := bindBridgeFee(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BridgeFee{BridgeFeeCaller: BridgeFeeCaller{contract: contract}, BridgeFeeTransactor: BridgeFeeTransactor{contract: contract}, BridgeFeeFilterer: BridgeFeeFilterer{contract: contract}}, nil
}

// NewBridgeFeeCaller creates a new read-only instance of BridgeFee, bound to a specific deployed contract.
func NewBridgeFeeCaller(address common.Address, caller bind.ContractCaller) (*BridgeFeeCaller, error) {
	contract, err := bindBridgeFee(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeFeeCaller{contract: contract}, nil
}

// NewBridgeFeeTransactor creates a new write-only instance of BridgeFee, bound to a specific deployed contract.
func NewBridgeFeeTransactor(address common.Address, transactor bind.ContractTransactor) (*BridgeFeeTransactor, error) {
	contract, err := bindBridgeFee(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeFeeTransactor{contract: contract}, nil
}

// NewBridgeFeeFilterer creates a new log filterer instance of BridgeFee, bound to a specific deployed contract.
func NewBridgeFeeFilterer(address common.Address, filterer bind.ContractFilterer) (*BridgeFeeFilterer, error) {
	contract, err := bindBridgeFee(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BridgeFeeFilterer{contract: contract}, nil
}

// bindBridgeFee binds a generic wrapper to an already deployed contract.
func bindBridgeFee(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeFeeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeFee *BridgeFeeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeFee.Contract.BridgeFeeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeFee *BridgeFeeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeFee.Contract.BridgeFeeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeFee *BridgeFeeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeFee.Contract.BridgeFeeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeFee *BridgeFeeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeFee.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeFee *BridgeFeeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeFee.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeFee *BridgeFeeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeFee.Contract.contract.Transact(opts, method, params...)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeFee *BridgeFeeCaller) FeeOfERC20(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeFee.contract.Call(opts, out, "feeOfERC20", arg0)
	return *ret0, err
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeFee *BridgeFeeSession) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _BridgeFee.Contract.FeeOfERC20(&_BridgeFee.CallOpts, arg0)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeFee *BridgeFeeCallerSession) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _BridgeFee.Contract.FeeOfERC20(&_BridgeFee.CallOpts, arg0)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeFee *BridgeFeeCaller) FeeOfKLAY(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeFee.contract.Call(opts, out, "feeOfKLAY")
	return *ret0, err
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeFee *BridgeFeeSession) FeeOfKLAY() (*big.Int, error) {
	return _BridgeFee.Contract.FeeOfKLAY(&_BridgeFee.CallOpts)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeFee *BridgeFeeCallerSession) FeeOfKLAY() (*big.Int, error) {
	return _BridgeFee.Contract.FeeOfKLAY(&_BridgeFee.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeFee *BridgeFeeCaller) FeeReceiver(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeFee.contract.Call(opts, out, "feeReceiver")
	return *ret0, err
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeFee *BridgeFeeSession) FeeReceiver() (common.Address, error) {
	return _BridgeFee.Contract.FeeReceiver(&_BridgeFee.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeFee *BridgeFeeCallerSession) FeeReceiver() (common.Address, error) {
	return _BridgeFee.Contract.FeeReceiver(&_BridgeFee.CallOpts)
}

// BridgeFeeERC20FeeChangedIterator is returned from FilterERC20FeeChanged and is used to iterate over the raw logs and unpacked data for ERC20FeeChanged events raised by the BridgeFee contract.
type BridgeFeeERC20FeeChangedIterator struct {
	Event *BridgeFeeERC20FeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeFeeERC20FeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeFeeERC20FeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeFeeERC20FeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeFeeERC20FeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeFeeERC20FeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeFeeERC20FeeChanged represents a ERC20FeeChanged event raised by the BridgeFee contract.
type BridgeFeeERC20FeeChanged struct {
	Token common.Address
	Fee   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterERC20FeeChanged is a free log retrieval operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeFee *BridgeFeeFilterer) FilterERC20FeeChanged(opts *bind.FilterOpts, token []common.Address, fee []*big.Int) (*BridgeFeeERC20FeeChangedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeFee.contract.FilterLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return &BridgeFeeERC20FeeChangedIterator{contract: _BridgeFee.contract, event: "ERC20FeeChanged", logs: logs, sub: sub}, nil
}

// WatchERC20FeeChanged is a free log subscription operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeFee *BridgeFeeFilterer) WatchERC20FeeChanged(opts *bind.WatchOpts, sink chan<- *BridgeFeeERC20FeeChanged, token []common.Address, fee []*big.Int) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeFee.contract.WatchLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeFeeERC20FeeChanged)
				if err := _BridgeFee.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20FeeChanged is a log parse operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeFee *BridgeFeeFilterer) ParseERC20FeeChanged(log types.Log) (*BridgeFeeERC20FeeChanged, error) {
	event := new(BridgeFeeERC20FeeChanged)
	if err := _BridgeFee.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeFeeFeeReceiverChangedIterator is returned from FilterFeeReceiverChanged and is used to iterate over the raw logs and unpacked data for FeeReceiverChanged events raised by the BridgeFee contract.
type BridgeFeeFeeReceiverChangedIterator struct {
	Event *BridgeFeeFeeReceiverChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeFeeFeeReceiverChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeFeeFeeReceiverChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeFeeFeeReceiverChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeFeeFeeReceiverChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeFeeFeeReceiverChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeFeeFeeReceiverChanged represents a FeeReceiverChanged event raised by the BridgeFee contract.
type BridgeFeeFeeReceiverChanged struct {
	FeeReceiver common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterFeeReceiverChanged is a free log retrieval operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeFee *BridgeFeeFilterer) FilterFeeReceiverChanged(opts *bind.FilterOpts, feeReceiver []common.Address) (*BridgeFeeFeeReceiverChangedIterator, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _BridgeFee.contract.FilterLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return &BridgeFeeFeeReceiverChangedIterator{contract: _BridgeFee.contract, event: "FeeReceiverChanged", logs: logs, sub: sub}, nil
}

// WatchFeeReceiverChanged is a free log subscription operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeFee *BridgeFeeFilterer) WatchFeeReceiverChanged(opts *bind.WatchOpts, sink chan<- *BridgeFeeFeeReceiverChanged, feeReceiver []common.Address) (event.Subscription, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _BridgeFee.contract.WatchLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeFeeFeeReceiverChanged)
				if err := _BridgeFee.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeReceiverChanged is a log parse operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeFee *BridgeFeeFilterer) ParseFeeReceiverChanged(log types.Log) (*BridgeFeeFeeReceiverChanged, error) {
	event := new(BridgeFeeFeeReceiverChanged)
	if err := _BridgeFee.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeFeeKLAYFeeChangedIterator is returned from FilterKLAYFeeChanged and is used to iterate over the raw logs and unpacked data for KLAYFeeChanged events raised by the BridgeFee contract.
type BridgeFeeKLAYFeeChangedIterator struct {
	Event *BridgeFeeKLAYFeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeFeeKLAYFeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeFeeKLAYFeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeFeeKLAYFeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeFeeKLAYFeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeFeeKLAYFeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeFeeKLAYFeeChanged represents a KLAYFeeChanged event raised by the BridgeFee contract.
type BridgeFeeKLAYFeeChanged struct {
	Fee *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterKLAYFeeChanged is a free log retrieval operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeFee *BridgeFeeFilterer) FilterKLAYFeeChanged(opts *bind.FilterOpts, fee []*big.Int) (*BridgeFeeKLAYFeeChangedIterator, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeFee.contract.FilterLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return &BridgeFeeKLAYFeeChangedIterator{contract: _BridgeFee.contract, event: "KLAYFeeChanged", logs: logs, sub: sub}, nil
}

// WatchKLAYFeeChanged is a free log subscription operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeFee *BridgeFeeFilterer) WatchKLAYFeeChanged(opts *bind.WatchOpts, sink chan<- *BridgeFeeKLAYFeeChanged, fee []*big.Int) (event.Subscription, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeFee.contract.WatchLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeFeeKLAYFeeChanged)
				if err := _BridgeFee.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKLAYFeeChanged is a log parse operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeFee *BridgeFeeFilterer) ParseKLAYFeeChanged(log types.Log) (*BridgeFeeKLAYFeeChanged, error) {
	event := new(BridgeFeeKLAYFeeChanged)
	if err := _BridgeFee.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeHandledRequestsABI is the input ABI used to generate the binding from.
const BridgeHandledRequestsABI = "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"handledRequestTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// BridgeHandledRequestsBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const BridgeHandledRequestsBinRuntime = `6080604052348015600f57600080fd5b506004361060285760003560e01c80638a75eee214602d575b600080fd5b604d60383660046061565b60006020819052908152604090205460ff1681565b604051901515815260200160405180910390f35b600060208284031215607257600080fd5b503591905056fea2646970667358221220e327fc2759ecf4a7463e9bc9392261b2757b161c05d806adab0951984f14ebde64736f6c634300080d0033`

// BridgeHandledRequestsFuncSigs maps the 4-byte function signature to its string representation.
var BridgeHandledRequestsFuncSigs = map[string]string{
	"8a75eee2": "handledRequestTx(bytes32)",
}

// BridgeHandledRequestsBin is the compiled bytecode used for deploying new contracts.
var BridgeHandledRequestsBin = "0x608060405234801561001057600080fd5b5060af8061001f6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80638a75eee214602d575b600080fd5b604d60383660046061565b60006020819052908152604090205460ff1681565b604051901515815260200160405180910390f35b600060208284031215607257600080fd5b503591905056fea2646970667358221220e327fc2759ecf4a7463e9bc9392261b2757b161c05d806adab0951984f14ebde64736f6c634300080d0033"

// DeployBridgeHandledRequests deploys a new Klaytn contract, binding an instance of BridgeHandledRequests to it.
func DeployBridgeHandledRequests(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BridgeHandledRequests, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeHandledRequestsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(BridgeHandledRequestsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BridgeHandledRequests{BridgeHandledRequestsCaller: BridgeHandledRequestsCaller{contract: contract}, BridgeHandledRequestsTransactor: BridgeHandledRequestsTransactor{contract: contract}, BridgeHandledRequestsFilterer: BridgeHandledRequestsFilterer{contract: contract}}, nil
}

// BridgeHandledRequests is an auto generated Go binding around a Klaytn contract.
type BridgeHandledRequests struct {
	BridgeHandledRequestsCaller     // Read-only binding to the contract
	BridgeHandledRequestsTransactor // Write-only binding to the contract
	BridgeHandledRequestsFilterer   // Log filterer for contract events
}

// BridgeHandledRequestsCaller is an auto generated read-only Go binding around a Klaytn contract.
type BridgeHandledRequestsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeHandledRequestsTransactor is an auto generated write-only Go binding around a Klaytn contract.
type BridgeHandledRequestsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeHandledRequestsFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type BridgeHandledRequestsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeHandledRequestsSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type BridgeHandledRequestsSession struct {
	Contract     *BridgeHandledRequests // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// BridgeHandledRequestsCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type BridgeHandledRequestsCallerSession struct {
	Contract *BridgeHandledRequestsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// BridgeHandledRequestsTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type BridgeHandledRequestsTransactorSession struct {
	Contract     *BridgeHandledRequestsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// BridgeHandledRequestsRaw is an auto generated low-level Go binding around a Klaytn contract.
type BridgeHandledRequestsRaw struct {
	Contract *BridgeHandledRequests // Generic contract binding to access the raw methods on
}

// BridgeHandledRequestsCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type BridgeHandledRequestsCallerRaw struct {
	Contract *BridgeHandledRequestsCaller // Generic read-only contract binding to access the raw methods on
}

// BridgeHandledRequestsTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type BridgeHandledRequestsTransactorRaw struct {
	Contract *BridgeHandledRequestsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBridgeHandledRequests creates a new instance of BridgeHandledRequests, bound to a specific deployed contract.
func NewBridgeHandledRequests(address common.Address, backend bind.ContractBackend) (*BridgeHandledRequests, error) {
	contract, err := bindBridgeHandledRequests(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BridgeHandledRequests{BridgeHandledRequestsCaller: BridgeHandledRequestsCaller{contract: contract}, BridgeHandledRequestsTransactor: BridgeHandledRequestsTransactor{contract: contract}, BridgeHandledRequestsFilterer: BridgeHandledRequestsFilterer{contract: contract}}, nil
}

// NewBridgeHandledRequestsCaller creates a new read-only instance of BridgeHandledRequests, bound to a specific deployed contract.
func NewBridgeHandledRequestsCaller(address common.Address, caller bind.ContractCaller) (*BridgeHandledRequestsCaller, error) {
	contract, err := bindBridgeHandledRequests(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeHandledRequestsCaller{contract: contract}, nil
}

// NewBridgeHandledRequestsTransactor creates a new write-only instance of BridgeHandledRequests, bound to a specific deployed contract.
func NewBridgeHandledRequestsTransactor(address common.Address, transactor bind.ContractTransactor) (*BridgeHandledRequestsTransactor, error) {
	contract, err := bindBridgeHandledRequests(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeHandledRequestsTransactor{contract: contract}, nil
}

// NewBridgeHandledRequestsFilterer creates a new log filterer instance of BridgeHandledRequests, bound to a specific deployed contract.
func NewBridgeHandledRequestsFilterer(address common.Address, filterer bind.ContractFilterer) (*BridgeHandledRequestsFilterer, error) {
	contract, err := bindBridgeHandledRequests(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BridgeHandledRequestsFilterer{contract: contract}, nil
}

// bindBridgeHandledRequests binds a generic wrapper to an already deployed contract.
func bindBridgeHandledRequests(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeHandledRequestsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeHandledRequests *BridgeHandledRequestsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeHandledRequests.Contract.BridgeHandledRequestsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeHandledRequests *BridgeHandledRequestsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeHandledRequests.Contract.BridgeHandledRequestsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeHandledRequests *BridgeHandledRequestsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeHandledRequests.Contract.BridgeHandledRequestsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeHandledRequests *BridgeHandledRequestsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeHandledRequests.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeHandledRequests *BridgeHandledRequestsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeHandledRequests.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeHandledRequests *BridgeHandledRequestsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeHandledRequests.Contract.contract.Transact(opts, method, params...)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeHandledRequests *BridgeHandledRequestsCaller) HandledRequestTx(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeHandledRequests.contract.Call(opts, out, "handledRequestTx", arg0)
	return *ret0, err
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeHandledRequests *BridgeHandledRequestsSession) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _BridgeHandledRequests.Contract.HandledRequestTx(&_BridgeHandledRequests.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeHandledRequests *BridgeHandledRequestsCallerSession) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _BridgeHandledRequests.Contract.HandledRequestTx(&_BridgeHandledRequests.CallOpts, arg0)
}

// BridgeOperatorABI is the input ABI used to generate the binding from.
const BridgeOperatorABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_OPERATOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"closedValueTransferVotes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"deregisterOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"operatorThresholds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enumBridgeOperator.VoteType\",\"name\":\"_voteType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"}],\"name\":\"setOperatorThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// BridgeOperatorBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const BridgeOperatorBinRuntime = ``

// BridgeOperatorFuncSigs maps the 4-byte function signature to its string representation.
var BridgeOperatorFuncSigs = map[string]string{
	"3a3099d1": "MAX_OPERATOR()",
	"9832c1d7": "closedValueTransferVotes(uint64)",
	"ac6fff0b": "configurationNonce()",
	"d8cf98ca": "deregisterOperator(address)",
	"b2c01030": "getOperatorList()",
	"cb38f407": "operatorList(uint256)",
	"5526f76b": "operatorThresholds(uint8)",
	"13e7c9d8": "operators(address)",
	"8da5cb5b": "owner()",
	"3682a450": "registerOperator(address)",
	"715018a6": "renounceOwnership()",
	"ee2aec65": "setOperatorThreshold(uint8,uint8)",
	"f2fde38b": "transferOwnership(address)",
}

// BridgeOperator is an auto generated Go binding around a Klaytn contract.
type BridgeOperator struct {
	BridgeOperatorCaller     // Read-only binding to the contract
	BridgeOperatorTransactor // Write-only binding to the contract
	BridgeOperatorFilterer   // Log filterer for contract events
}

// BridgeOperatorCaller is an auto generated read-only Go binding around a Klaytn contract.
type BridgeOperatorCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeOperatorTransactor is an auto generated write-only Go binding around a Klaytn contract.
type BridgeOperatorTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeOperatorFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type BridgeOperatorFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeOperatorSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type BridgeOperatorSession struct {
	Contract     *BridgeOperator   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BridgeOperatorCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type BridgeOperatorCallerSession struct {
	Contract *BridgeOperatorCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// BridgeOperatorTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type BridgeOperatorTransactorSession struct {
	Contract     *BridgeOperatorTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// BridgeOperatorRaw is an auto generated low-level Go binding around a Klaytn contract.
type BridgeOperatorRaw struct {
	Contract *BridgeOperator // Generic contract binding to access the raw methods on
}

// BridgeOperatorCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type BridgeOperatorCallerRaw struct {
	Contract *BridgeOperatorCaller // Generic read-only contract binding to access the raw methods on
}

// BridgeOperatorTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type BridgeOperatorTransactorRaw struct {
	Contract *BridgeOperatorTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBridgeOperator creates a new instance of BridgeOperator, bound to a specific deployed contract.
func NewBridgeOperator(address common.Address, backend bind.ContractBackend) (*BridgeOperator, error) {
	contract, err := bindBridgeOperator(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BridgeOperator{BridgeOperatorCaller: BridgeOperatorCaller{contract: contract}, BridgeOperatorTransactor: BridgeOperatorTransactor{contract: contract}, BridgeOperatorFilterer: BridgeOperatorFilterer{contract: contract}}, nil
}

// NewBridgeOperatorCaller creates a new read-only instance of BridgeOperator, bound to a specific deployed contract.
func NewBridgeOperatorCaller(address common.Address, caller bind.ContractCaller) (*BridgeOperatorCaller, error) {
	contract, err := bindBridgeOperator(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeOperatorCaller{contract: contract}, nil
}

// NewBridgeOperatorTransactor creates a new write-only instance of BridgeOperator, bound to a specific deployed contract.
func NewBridgeOperatorTransactor(address common.Address, transactor bind.ContractTransactor) (*BridgeOperatorTransactor, error) {
	contract, err := bindBridgeOperator(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeOperatorTransactor{contract: contract}, nil
}

// NewBridgeOperatorFilterer creates a new log filterer instance of BridgeOperator, bound to a specific deployed contract.
func NewBridgeOperatorFilterer(address common.Address, filterer bind.ContractFilterer) (*BridgeOperatorFilterer, error) {
	contract, err := bindBridgeOperator(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BridgeOperatorFilterer{contract: contract}, nil
}

// bindBridgeOperator binds a generic wrapper to an already deployed contract.
func bindBridgeOperator(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeOperatorABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeOperator *BridgeOperatorRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeOperator.Contract.BridgeOperatorCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeOperator *BridgeOperatorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeOperator.Contract.BridgeOperatorTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeOperator *BridgeOperatorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeOperator.Contract.BridgeOperatorTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeOperator *BridgeOperatorCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeOperator.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeOperator *BridgeOperatorTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeOperator.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeOperator *BridgeOperatorTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeOperator.Contract.contract.Transact(opts, method, params...)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeOperator *BridgeOperatorCaller) MAXOPERATOR(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeOperator.contract.Call(opts, out, "MAX_OPERATOR")
	return *ret0, err
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeOperator *BridgeOperatorSession) MAXOPERATOR() (uint64, error) {
	return _BridgeOperator.Contract.MAXOPERATOR(&_BridgeOperator.CallOpts)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeOperator *BridgeOperatorCallerSession) MAXOPERATOR() (uint64, error) {
	return _BridgeOperator.Contract.MAXOPERATOR(&_BridgeOperator.CallOpts)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeOperator *BridgeOperatorCaller) ClosedValueTransferVotes(opts *bind.CallOpts, arg0 uint64) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeOperator.contract.Call(opts, out, "closedValueTransferVotes", arg0)
	return *ret0, err
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeOperator *BridgeOperatorSession) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _BridgeOperator.Contract.ClosedValueTransferVotes(&_BridgeOperator.CallOpts, arg0)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeOperator *BridgeOperatorCallerSession) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _BridgeOperator.Contract.ClosedValueTransferVotes(&_BridgeOperator.CallOpts, arg0)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeOperator *BridgeOperatorCaller) ConfigurationNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeOperator.contract.Call(opts, out, "configurationNonce")
	return *ret0, err
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeOperator *BridgeOperatorSession) ConfigurationNonce() (uint64, error) {
	return _BridgeOperator.Contract.ConfigurationNonce(&_BridgeOperator.CallOpts)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeOperator *BridgeOperatorCallerSession) ConfigurationNonce() (uint64, error) {
	return _BridgeOperator.Contract.ConfigurationNonce(&_BridgeOperator.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeOperator *BridgeOperatorCaller) GetOperatorList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _BridgeOperator.contract.Call(opts, out, "getOperatorList")
	return *ret0, err
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeOperator *BridgeOperatorSession) GetOperatorList() ([]common.Address, error) {
	return _BridgeOperator.Contract.GetOperatorList(&_BridgeOperator.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeOperator *BridgeOperatorCallerSession) GetOperatorList() ([]common.Address, error) {
	return _BridgeOperator.Contract.GetOperatorList(&_BridgeOperator.CallOpts)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeOperator *BridgeOperatorCaller) OperatorList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeOperator.contract.Call(opts, out, "operatorList", arg0)
	return *ret0, err
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeOperator *BridgeOperatorSession) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _BridgeOperator.Contract.OperatorList(&_BridgeOperator.CallOpts, arg0)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeOperator *BridgeOperatorCallerSession) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _BridgeOperator.Contract.OperatorList(&_BridgeOperator.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeOperator *BridgeOperatorCaller) OperatorThresholds(opts *bind.CallOpts, arg0 uint8) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _BridgeOperator.contract.Call(opts, out, "operatorThresholds", arg0)
	return *ret0, err
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeOperator *BridgeOperatorSession) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _BridgeOperator.Contract.OperatorThresholds(&_BridgeOperator.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeOperator *BridgeOperatorCallerSession) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _BridgeOperator.Contract.OperatorThresholds(&_BridgeOperator.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeOperator *BridgeOperatorCaller) Operators(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeOperator.contract.Call(opts, out, "operators", arg0)
	return *ret0, err
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeOperator *BridgeOperatorSession) Operators(arg0 common.Address) (bool, error) {
	return _BridgeOperator.Contract.Operators(&_BridgeOperator.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeOperator *BridgeOperatorCallerSession) Operators(arg0 common.Address) (bool, error) {
	return _BridgeOperator.Contract.Operators(&_BridgeOperator.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeOperator *BridgeOperatorCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeOperator.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeOperator *BridgeOperatorSession) Owner() (common.Address, error) {
	return _BridgeOperator.Contract.Owner(&_BridgeOperator.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeOperator *BridgeOperatorCallerSession) Owner() (common.Address, error) {
	return _BridgeOperator.Contract.Owner(&_BridgeOperator.CallOpts)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeOperator *BridgeOperatorTransactor) DeregisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _BridgeOperator.contract.Transact(opts, "deregisterOperator", _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeOperator *BridgeOperatorSession) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeOperator.Contract.DeregisterOperator(&_BridgeOperator.TransactOpts, _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeOperator *BridgeOperatorTransactorSession) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeOperator.Contract.DeregisterOperator(&_BridgeOperator.TransactOpts, _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeOperator *BridgeOperatorTransactor) RegisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _BridgeOperator.contract.Transact(opts, "registerOperator", _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeOperator *BridgeOperatorSession) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeOperator.Contract.RegisterOperator(&_BridgeOperator.TransactOpts, _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeOperator *BridgeOperatorTransactorSession) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeOperator.Contract.RegisterOperator(&_BridgeOperator.TransactOpts, _operator)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeOperator *BridgeOperatorTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeOperator.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeOperator *BridgeOperatorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeOperator.Contract.RenounceOwnership(&_BridgeOperator.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeOperator *BridgeOperatorTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeOperator.Contract.RenounceOwnership(&_BridgeOperator.TransactOpts)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeOperator *BridgeOperatorTransactor) SetOperatorThreshold(opts *bind.TransactOpts, _voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeOperator.contract.Transact(opts, "setOperatorThreshold", _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeOperator *BridgeOperatorSession) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeOperator.Contract.SetOperatorThreshold(&_BridgeOperator.TransactOpts, _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeOperator *BridgeOperatorTransactorSession) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeOperator.Contract.SetOperatorThreshold(&_BridgeOperator.TransactOpts, _voteType, _threshold)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeOperator *BridgeOperatorTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BridgeOperator.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeOperator *BridgeOperatorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeOperator.Contract.TransferOwnership(&_BridgeOperator.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeOperator *BridgeOperatorTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeOperator.Contract.TransferOwnership(&_BridgeOperator.TransactOpts, newOwner)
}

// BridgeOperatorOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BridgeOperator contract.
type BridgeOperatorOwnershipTransferredIterator struct {
	Event *BridgeOperatorOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeOperatorOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeOperatorOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeOperatorOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeOperatorOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeOperatorOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeOperatorOwnershipTransferred represents a OwnershipTransferred event raised by the BridgeOperator contract.
type BridgeOperatorOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeOperator *BridgeOperatorFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BridgeOperatorOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeOperator.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BridgeOperatorOwnershipTransferredIterator{contract: _BridgeOperator.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeOperator *BridgeOperatorFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BridgeOperatorOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeOperator.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeOperatorOwnershipTransferred)
				if err := _BridgeOperator.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeOperator *BridgeOperatorFilterer) ParseOwnershipTransferred(log types.Log) (*BridgeOperatorOwnershipTransferred, error) {
	event := new(BridgeOperatorOwnershipTransferred)
	if err := _BridgeOperator.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTokensABI is the input ABI used to generate the binding from.
const BridgeTokensABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"deregisterToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexOfTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"registerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredTokenList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"unlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// BridgeTokensBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const BridgeTokensBinRuntime = `608060405234801561001057600080fd5b50600436106100b45760003560e01c80638c0bd916116100715780638c0bd9161461017a5780638da5cb5b146101a35780639ef2017b146101b4578063bab2af1d146101c7578063ea21eade146101da578063f2fde38b146101ef57600080fd5b806310693fcd146100b95780633e4fe949146100ce5780634739f7e5146100fe57806348a18a6a146101115780635eb7413a1461013f578063715018a614610172575b600080fd5b6100cc6100c73660046108ef565b610202565b005b6100e16100dc366004610911565b610316565b6040516001600160a01b0390911681526020015b60405180910390f35b6100cc61010c36600461092a565b610340565b61013161011f3660046108ef565b60026020526000908152604090205481565b6040519081526020016100f5565b61016261014d3660046108ef565b60046020526000908152604090205460ff1681565b60405190151581526020016100f5565b6100cc610463565b6100e16101883660046108ef565b6001602052600090815260409020546001600160a01b031681565b6000546001600160a01b03166100e1565b6100cc6101c23660046108ef565b610499565b6100cc6101d53660046108ef565b6105a7565b6101e2610786565b6040516100f5919061095d565b6100cc6101fd3660046108ef565b6107e8565b6000546001600160a01b031633146102355760405162461bcd60e51b815260040161022c906109aa565b60405180910390fd5b6001600160a01b0380821660009081526001602052604090205482911661026e5760405162461bcd60e51b815260040161022c906109df565b6001600160a01b038216600090815260046020526040902054829060ff16156102c85760405162461bcd60e51b815260206004820152600c60248201526b3637b1b5b2b2103a37b5b2b760a11b604482015260640161022c565b6001600160a01b038316600081815260046020526040808220805460ff19166001179055517fca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd79190a2505050565b6003818154811061032657600080fd5b6000918252602090912001546001600160a01b0316905081565b6000546001600160a01b0316331461036a5760405162461bcd60e51b815260040161022c906109aa565b6001600160a01b03808316600090815260016020526040902054839116156103c45760405162461bcd60e51b815260206004820152600d60248201526c30b63637bbb2b2103a37b5b2b760991b604482015260640161022c565b6001600160a01b03808416600081815260016020818152604080842080549689166001600160a01b031997881617905560038054600290935281852083905592820183559183527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b0180549094168317909355915190917f158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d91a2505050565b6000546001600160a01b0316331461048d5760405162461bcd60e51b815260040161022c906109aa565b6104976000610883565b565b6000546001600160a01b031633146104c35760405162461bcd60e51b815260040161022c906109aa565b6001600160a01b038082166000908152600160205260409020548291166104fc5760405162461bcd60e51b815260040161022c906109df565b6001600160a01b038216600090815260046020526040902054829060ff16151560011461055c5760405162461bcd60e51b815260206004820152600e60248201526d3ab73637b1b5b2b2103a37b5b2b760911b604482015260640161022c565b6001600160a01b038316600081815260046020526040808220805460ff19169055517f81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec9190a2505050565b6000546001600160a01b031633146105d15760405162461bcd60e51b815260040161022c906109aa565b6001600160a01b0380821660009081526001602052604090205482911661060a5760405162461bcd60e51b815260040161022c906109df565b6001600160a01b038216600090815260016020818152604080842080546001600160a01b031916905560048252808420805460ff1916905560029091528220805492905560035461065b9190610a0a565b81101561071a576003805461067290600190610a0a565b8154811061068257610682610a2f565b600091825260209091200154600380546001600160a01b0390921691839081106106ae576106ae610a2f565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b031602179055508060026000600384815481106106f4576106f4610a2f565b60009182526020808320909101546001600160a01b031683528201929092526040019020555b600380548061072b5761072b610a45565b600082815260208120820160001990810180546001600160a01b03191690559091019091556040516001600160a01b038516917f1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b691a2505050565b606060038054806020026020016040519081016040528092919081815260200182805480156107de57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116107c0575b5050505050905090565b6000546001600160a01b031633146108125760405162461bcd60e51b815260040161022c906109aa565b6001600160a01b0381166108775760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161022c565b61088081610883565b50565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80356001600160a01b03811681146108ea57600080fd5b919050565b60006020828403121561090157600080fd5b61090a826108d3565b9392505050565b60006020828403121561092357600080fd5b5035919050565b6000806040838503121561093d57600080fd5b610946836108d3565b9150610954602084016108d3565b90509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561099e5783516001600160a01b031683529284019291840191600101610979565b50909695505050505050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6020808252601190820152703737ba1030b63637bbb2b2103a37b5b2b760791b604082015260600190565b600082821015610a2a57634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052603160045260246000fdfea2646970667358221220296a7d5d1ddebbacb3c735eb7d217fb900420a58bd761668fc36afafa5e637c364736f6c634300080d0033`

// BridgeTokensFuncSigs maps the 4-byte function signature to its string representation.
var BridgeTokensFuncSigs = map[string]string{
	"bab2af1d": "deregisterToken(address)",
	"ea21eade": "getRegisteredTokenList()",
	"48a18a6a": "indexOfTokens(address)",
	"10693fcd": "lockToken(address)",
	"5eb7413a": "lockedTokens(address)",
	"8da5cb5b": "owner()",
	"4739f7e5": "registerToken(address,address)",
	"3e4fe949": "registeredTokenList(uint256)",
	"8c0bd916": "registeredTokens(address)",
	"715018a6": "renounceOwnership()",
	"f2fde38b": "transferOwnership(address)",
	"9ef2017b": "unlockToken(address)",
}

// BridgeTokensBin is the compiled bytecode used for deploying new contracts.
var BridgeTokensBin = "0x608060405234801561001057600080fd5b5061001a3361001f565b61006f565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b610a918061007e6000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c80638c0bd916116100715780638c0bd9161461017a5780638da5cb5b146101a35780639ef2017b146101b4578063bab2af1d146101c7578063ea21eade146101da578063f2fde38b146101ef57600080fd5b806310693fcd146100b95780633e4fe949146100ce5780634739f7e5146100fe57806348a18a6a146101115780635eb7413a1461013f578063715018a614610172575b600080fd5b6100cc6100c73660046108ef565b610202565b005b6100e16100dc366004610911565b610316565b6040516001600160a01b0390911681526020015b60405180910390f35b6100cc61010c36600461092a565b610340565b61013161011f3660046108ef565b60026020526000908152604090205481565b6040519081526020016100f5565b61016261014d3660046108ef565b60046020526000908152604090205460ff1681565b60405190151581526020016100f5565b6100cc610463565b6100e16101883660046108ef565b6001602052600090815260409020546001600160a01b031681565b6000546001600160a01b03166100e1565b6100cc6101c23660046108ef565b610499565b6100cc6101d53660046108ef565b6105a7565b6101e2610786565b6040516100f5919061095d565b6100cc6101fd3660046108ef565b6107e8565b6000546001600160a01b031633146102355760405162461bcd60e51b815260040161022c906109aa565b60405180910390fd5b6001600160a01b0380821660009081526001602052604090205482911661026e5760405162461bcd60e51b815260040161022c906109df565b6001600160a01b038216600090815260046020526040902054829060ff16156102c85760405162461bcd60e51b815260206004820152600c60248201526b3637b1b5b2b2103a37b5b2b760a11b604482015260640161022c565b6001600160a01b038316600081815260046020526040808220805460ff19166001179055517fca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd79190a2505050565b6003818154811061032657600080fd5b6000918252602090912001546001600160a01b0316905081565b6000546001600160a01b0316331461036a5760405162461bcd60e51b815260040161022c906109aa565b6001600160a01b03808316600090815260016020526040902054839116156103c45760405162461bcd60e51b815260206004820152600d60248201526c30b63637bbb2b2103a37b5b2b760991b604482015260640161022c565b6001600160a01b03808416600081815260016020818152604080842080549689166001600160a01b031997881617905560038054600290935281852083905592820183559183527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b0180549094168317909355915190917f158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d91a2505050565b6000546001600160a01b0316331461048d5760405162461bcd60e51b815260040161022c906109aa565b6104976000610883565b565b6000546001600160a01b031633146104c35760405162461bcd60e51b815260040161022c906109aa565b6001600160a01b038082166000908152600160205260409020548291166104fc5760405162461bcd60e51b815260040161022c906109df565b6001600160a01b038216600090815260046020526040902054829060ff16151560011461055c5760405162461bcd60e51b815260206004820152600e60248201526d3ab73637b1b5b2b2103a37b5b2b760911b604482015260640161022c565b6001600160a01b038316600081815260046020526040808220805460ff19169055517f81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec9190a2505050565b6000546001600160a01b031633146105d15760405162461bcd60e51b815260040161022c906109aa565b6001600160a01b0380821660009081526001602052604090205482911661060a5760405162461bcd60e51b815260040161022c906109df565b6001600160a01b038216600090815260016020818152604080842080546001600160a01b031916905560048252808420805460ff1916905560029091528220805492905560035461065b9190610a0a565b81101561071a576003805461067290600190610a0a565b8154811061068257610682610a2f565b600091825260209091200154600380546001600160a01b0390921691839081106106ae576106ae610a2f565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b031602179055508060026000600384815481106106f4576106f4610a2f565b60009182526020808320909101546001600160a01b031683528201929092526040019020555b600380548061072b5761072b610a45565b600082815260208120820160001990810180546001600160a01b03191690559091019091556040516001600160a01b038516917f1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b691a2505050565b606060038054806020026020016040519081016040528092919081815260200182805480156107de57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116107c0575b5050505050905090565b6000546001600160a01b031633146108125760405162461bcd60e51b815260040161022c906109aa565b6001600160a01b0381166108775760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161022c565b61088081610883565b50565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80356001600160a01b03811681146108ea57600080fd5b919050565b60006020828403121561090157600080fd5b61090a826108d3565b9392505050565b60006020828403121561092357600080fd5b5035919050565b6000806040838503121561093d57600080fd5b610946836108d3565b9150610954602084016108d3565b90509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561099e5783516001600160a01b031683529284019291840191600101610979565b50909695505050505050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6020808252601190820152703737ba1030b63637bbb2b2103a37b5b2b760791b604082015260600190565b600082821015610a2a57634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052603160045260246000fdfea2646970667358221220296a7d5d1ddebbacb3c735eb7d217fb900420a58bd761668fc36afafa5e637c364736f6c634300080d0033"

// DeployBridgeTokens deploys a new Klaytn contract, binding an instance of BridgeTokens to it.
func DeployBridgeTokens(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BridgeTokens, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeTokensABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(BridgeTokensBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BridgeTokens{BridgeTokensCaller: BridgeTokensCaller{contract: contract}, BridgeTokensTransactor: BridgeTokensTransactor{contract: contract}, BridgeTokensFilterer: BridgeTokensFilterer{contract: contract}}, nil
}

// BridgeTokens is an auto generated Go binding around a Klaytn contract.
type BridgeTokens struct {
	BridgeTokensCaller     // Read-only binding to the contract
	BridgeTokensTransactor // Write-only binding to the contract
	BridgeTokensFilterer   // Log filterer for contract events
}

// BridgeTokensCaller is an auto generated read-only Go binding around a Klaytn contract.
type BridgeTokensCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTokensTransactor is an auto generated write-only Go binding around a Klaytn contract.
type BridgeTokensTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTokensFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type BridgeTokensFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTokensSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type BridgeTokensSession struct {
	Contract     *BridgeTokens     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BridgeTokensCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type BridgeTokensCallerSession struct {
	Contract *BridgeTokensCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// BridgeTokensTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type BridgeTokensTransactorSession struct {
	Contract     *BridgeTokensTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// BridgeTokensRaw is an auto generated low-level Go binding around a Klaytn contract.
type BridgeTokensRaw struct {
	Contract *BridgeTokens // Generic contract binding to access the raw methods on
}

// BridgeTokensCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type BridgeTokensCallerRaw struct {
	Contract *BridgeTokensCaller // Generic read-only contract binding to access the raw methods on
}

// BridgeTokensTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type BridgeTokensTransactorRaw struct {
	Contract *BridgeTokensTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBridgeTokens creates a new instance of BridgeTokens, bound to a specific deployed contract.
func NewBridgeTokens(address common.Address, backend bind.ContractBackend) (*BridgeTokens, error) {
	contract, err := bindBridgeTokens(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BridgeTokens{BridgeTokensCaller: BridgeTokensCaller{contract: contract}, BridgeTokensTransactor: BridgeTokensTransactor{contract: contract}, BridgeTokensFilterer: BridgeTokensFilterer{contract: contract}}, nil
}

// NewBridgeTokensCaller creates a new read-only instance of BridgeTokens, bound to a specific deployed contract.
func NewBridgeTokensCaller(address common.Address, caller bind.ContractCaller) (*BridgeTokensCaller, error) {
	contract, err := bindBridgeTokens(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTokensCaller{contract: contract}, nil
}

// NewBridgeTokensTransactor creates a new write-only instance of BridgeTokens, bound to a specific deployed contract.
func NewBridgeTokensTransactor(address common.Address, transactor bind.ContractTransactor) (*BridgeTokensTransactor, error) {
	contract, err := bindBridgeTokens(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTokensTransactor{contract: contract}, nil
}

// NewBridgeTokensFilterer creates a new log filterer instance of BridgeTokens, bound to a specific deployed contract.
func NewBridgeTokensFilterer(address common.Address, filterer bind.ContractFilterer) (*BridgeTokensFilterer, error) {
	contract, err := bindBridgeTokens(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BridgeTokensFilterer{contract: contract}, nil
}

// bindBridgeTokens binds a generic wrapper to an already deployed contract.
func bindBridgeTokens(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeTokensABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeTokens *BridgeTokensRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeTokens.Contract.BridgeTokensCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeTokens *BridgeTokensRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTokens.Contract.BridgeTokensTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeTokens *BridgeTokensRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeTokens.Contract.BridgeTokensTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeTokens *BridgeTokensCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeTokens.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeTokens *BridgeTokensTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTokens.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeTokens *BridgeTokensTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeTokens.Contract.contract.Transact(opts, method, params...)
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTokens *BridgeTokensCaller) GetRegisteredTokenList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _BridgeTokens.contract.Call(opts, out, "getRegisteredTokenList")
	return *ret0, err
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTokens *BridgeTokensSession) GetRegisteredTokenList() ([]common.Address, error) {
	return _BridgeTokens.Contract.GetRegisteredTokenList(&_BridgeTokens.CallOpts)
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTokens *BridgeTokensCallerSession) GetRegisteredTokenList() ([]common.Address, error) {
	return _BridgeTokens.Contract.GetRegisteredTokenList(&_BridgeTokens.CallOpts)
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTokens *BridgeTokensCaller) IndexOfTokens(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTokens.contract.Call(opts, out, "indexOfTokens", arg0)
	return *ret0, err
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTokens *BridgeTokensSession) IndexOfTokens(arg0 common.Address) (*big.Int, error) {
	return _BridgeTokens.Contract.IndexOfTokens(&_BridgeTokens.CallOpts, arg0)
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTokens *BridgeTokensCallerSession) IndexOfTokens(arg0 common.Address) (*big.Int, error) {
	return _BridgeTokens.Contract.IndexOfTokens(&_BridgeTokens.CallOpts, arg0)
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTokens *BridgeTokensCaller) LockedTokens(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTokens.contract.Call(opts, out, "lockedTokens", arg0)
	return *ret0, err
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTokens *BridgeTokensSession) LockedTokens(arg0 common.Address) (bool, error) {
	return _BridgeTokens.Contract.LockedTokens(&_BridgeTokens.CallOpts, arg0)
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTokens *BridgeTokensCallerSession) LockedTokens(arg0 common.Address) (bool, error) {
	return _BridgeTokens.Contract.LockedTokens(&_BridgeTokens.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTokens *BridgeTokensCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTokens.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTokens *BridgeTokensSession) Owner() (common.Address, error) {
	return _BridgeTokens.Contract.Owner(&_BridgeTokens.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTokens *BridgeTokensCallerSession) Owner() (common.Address, error) {
	return _BridgeTokens.Contract.Owner(&_BridgeTokens.CallOpts)
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTokens *BridgeTokensCaller) RegisteredTokenList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTokens.contract.Call(opts, out, "registeredTokenList", arg0)
	return *ret0, err
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTokens *BridgeTokensSession) RegisteredTokenList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTokens.Contract.RegisteredTokenList(&_BridgeTokens.CallOpts, arg0)
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTokens *BridgeTokensCallerSession) RegisteredTokenList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTokens.Contract.RegisteredTokenList(&_BridgeTokens.CallOpts, arg0)
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTokens *BridgeTokensCaller) RegisteredTokens(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTokens.contract.Call(opts, out, "registeredTokens", arg0)
	return *ret0, err
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTokens *BridgeTokensSession) RegisteredTokens(arg0 common.Address) (common.Address, error) {
	return _BridgeTokens.Contract.RegisteredTokens(&_BridgeTokens.CallOpts, arg0)
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTokens *BridgeTokensCallerSession) RegisteredTokens(arg0 common.Address) (common.Address, error) {
	return _BridgeTokens.Contract.RegisteredTokens(&_BridgeTokens.CallOpts, arg0)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTokens *BridgeTokensTransactor) DeregisterToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.contract.Transact(opts, "deregisterToken", _token)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTokens *BridgeTokensSession) DeregisterToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.DeregisterToken(&_BridgeTokens.TransactOpts, _token)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTokens *BridgeTokensTransactorSession) DeregisterToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.DeregisterToken(&_BridgeTokens.TransactOpts, _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTokens *BridgeTokensTransactor) LockToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.contract.Transact(opts, "lockToken", _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTokens *BridgeTokensSession) LockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.LockToken(&_BridgeTokens.TransactOpts, _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTokens *BridgeTokensTransactorSession) LockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.LockToken(&_BridgeTokens.TransactOpts, _token)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTokens *BridgeTokensTransactor) RegisterToken(opts *bind.TransactOpts, _token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTokens.contract.Transact(opts, "registerToken", _token, _cToken)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTokens *BridgeTokensSession) RegisterToken(_token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.RegisterToken(&_BridgeTokens.TransactOpts, _token, _cToken)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTokens *BridgeTokensTransactorSession) RegisterToken(_token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.RegisterToken(&_BridgeTokens.TransactOpts, _token, _cToken)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTokens *BridgeTokensTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTokens.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTokens *BridgeTokensSession) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeTokens.Contract.RenounceOwnership(&_BridgeTokens.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTokens *BridgeTokensTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeTokens.Contract.RenounceOwnership(&_BridgeTokens.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTokens *BridgeTokensTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTokens.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTokens *BridgeTokensSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.TransferOwnership(&_BridgeTokens.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTokens *BridgeTokensTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.TransferOwnership(&_BridgeTokens.TransactOpts, newOwner)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTokens *BridgeTokensTransactor) UnlockToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.contract.Transact(opts, "unlockToken", _token)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTokens *BridgeTokensSession) UnlockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.UnlockToken(&_BridgeTokens.TransactOpts, _token)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTokens *BridgeTokensTransactorSession) UnlockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTokens.Contract.UnlockToken(&_BridgeTokens.TransactOpts, _token)
}

// BridgeTokensOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BridgeTokens contract.
type BridgeTokensOwnershipTransferredIterator struct {
	Event *BridgeTokensOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTokensOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTokensOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTokensOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTokensOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTokensOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTokensOwnershipTransferred represents a OwnershipTransferred event raised by the BridgeTokens contract.
type BridgeTokensOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTokens *BridgeTokensFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BridgeTokensOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeTokens.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTokensOwnershipTransferredIterator{contract: _BridgeTokens.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTokens *BridgeTokensFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BridgeTokensOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeTokens.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTokensOwnershipTransferred)
				if err := _BridgeTokens.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTokens *BridgeTokensFilterer) ParseOwnershipTransferred(log types.Log) (*BridgeTokensOwnershipTransferred, error) {
	event := new(BridgeTokensOwnershipTransferred)
	if err := _BridgeTokens.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTokensTokenDeregisteredIterator is returned from FilterTokenDeregistered and is used to iterate over the raw logs and unpacked data for TokenDeregistered events raised by the BridgeTokens contract.
type BridgeTokensTokenDeregisteredIterator struct {
	Event *BridgeTokensTokenDeregistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTokensTokenDeregisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTokensTokenDeregistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTokensTokenDeregistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTokensTokenDeregisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTokensTokenDeregisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTokensTokenDeregistered represents a TokenDeregistered event raised by the BridgeTokens contract.
type BridgeTokensTokenDeregistered struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenDeregistered is a free log retrieval operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) FilterTokenDeregistered(opts *bind.FilterOpts, token []common.Address) (*BridgeTokensTokenDeregisteredIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTokens.contract.FilterLogs(opts, "TokenDeregistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTokensTokenDeregisteredIterator{contract: _BridgeTokens.contract, event: "TokenDeregistered", logs: logs, sub: sub}, nil
}

// WatchTokenDeregistered is a free log subscription operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) WatchTokenDeregistered(opts *bind.WatchOpts, sink chan<- *BridgeTokensTokenDeregistered, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTokens.contract.WatchLogs(opts, "TokenDeregistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTokensTokenDeregistered)
				if err := _BridgeTokens.contract.UnpackLog(event, "TokenDeregistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenDeregistered is a log parse operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) ParseTokenDeregistered(log types.Log) (*BridgeTokensTokenDeregistered, error) {
	event := new(BridgeTokensTokenDeregistered)
	if err := _BridgeTokens.contract.UnpackLog(event, "TokenDeregistered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTokensTokenLockedIterator is returned from FilterTokenLocked and is used to iterate over the raw logs and unpacked data for TokenLocked events raised by the BridgeTokens contract.
type BridgeTokensTokenLockedIterator struct {
	Event *BridgeTokensTokenLocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTokensTokenLockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTokensTokenLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTokensTokenLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTokensTokenLockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTokensTokenLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTokensTokenLocked represents a TokenLocked event raised by the BridgeTokens contract.
type BridgeTokensTokenLocked struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenLocked is a free log retrieval operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) FilterTokenLocked(opts *bind.FilterOpts, token []common.Address) (*BridgeTokensTokenLockedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTokens.contract.FilterLogs(opts, "TokenLocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTokensTokenLockedIterator{contract: _BridgeTokens.contract, event: "TokenLocked", logs: logs, sub: sub}, nil
}

// WatchTokenLocked is a free log subscription operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) WatchTokenLocked(opts *bind.WatchOpts, sink chan<- *BridgeTokensTokenLocked, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTokens.contract.WatchLogs(opts, "TokenLocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTokensTokenLocked)
				if err := _BridgeTokens.contract.UnpackLog(event, "TokenLocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenLocked is a log parse operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) ParseTokenLocked(log types.Log) (*BridgeTokensTokenLocked, error) {
	event := new(BridgeTokensTokenLocked)
	if err := _BridgeTokens.contract.UnpackLog(event, "TokenLocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTokensTokenRegisteredIterator is returned from FilterTokenRegistered and is used to iterate over the raw logs and unpacked data for TokenRegistered events raised by the BridgeTokens contract.
type BridgeTokensTokenRegisteredIterator struct {
	Event *BridgeTokensTokenRegistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTokensTokenRegisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTokensTokenRegistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTokensTokenRegistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTokensTokenRegisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTokensTokenRegisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTokensTokenRegistered represents a TokenRegistered event raised by the BridgeTokens contract.
type BridgeTokensTokenRegistered struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenRegistered is a free log retrieval operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) FilterTokenRegistered(opts *bind.FilterOpts, token []common.Address) (*BridgeTokensTokenRegisteredIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTokens.contract.FilterLogs(opts, "TokenRegistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTokensTokenRegisteredIterator{contract: _BridgeTokens.contract, event: "TokenRegistered", logs: logs, sub: sub}, nil
}

// WatchTokenRegistered is a free log subscription operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) WatchTokenRegistered(opts *bind.WatchOpts, sink chan<- *BridgeTokensTokenRegistered, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTokens.contract.WatchLogs(opts, "TokenRegistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTokensTokenRegistered)
				if err := _BridgeTokens.contract.UnpackLog(event, "TokenRegistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenRegistered is a log parse operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) ParseTokenRegistered(log types.Log) (*BridgeTokensTokenRegistered, error) {
	event := new(BridgeTokensTokenRegistered)
	if err := _BridgeTokens.contract.UnpackLog(event, "TokenRegistered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTokensTokenUnlockedIterator is returned from FilterTokenUnlocked and is used to iterate over the raw logs and unpacked data for TokenUnlocked events raised by the BridgeTokens contract.
type BridgeTokensTokenUnlockedIterator struct {
	Event *BridgeTokensTokenUnlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTokensTokenUnlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTokensTokenUnlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTokensTokenUnlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTokensTokenUnlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTokensTokenUnlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTokensTokenUnlocked represents a TokenUnlocked event raised by the BridgeTokens contract.
type BridgeTokensTokenUnlocked struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenUnlocked is a free log retrieval operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) FilterTokenUnlocked(opts *bind.FilterOpts, token []common.Address) (*BridgeTokensTokenUnlockedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTokens.contract.FilterLogs(opts, "TokenUnlocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTokensTokenUnlockedIterator{contract: _BridgeTokens.contract, event: "TokenUnlocked", logs: logs, sub: sub}, nil
}

// WatchTokenUnlocked is a free log subscription operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) WatchTokenUnlocked(opts *bind.WatchOpts, sink chan<- *BridgeTokensTokenUnlocked, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTokens.contract.WatchLogs(opts, "TokenUnlocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTokensTokenUnlocked)
				if err := _BridgeTokens.contract.UnpackLog(event, "TokenUnlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenUnlocked is a log parse operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTokens *BridgeTokensFilterer) ParseTokenUnlocked(log types.Log) (*BridgeTokensTokenUnlocked, error) {
	event := new(BridgeTokensTokenUnlocked)
	if err := _BridgeTokens.contract.UnpackLog(event, "TokenUnlocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferABI is the input ABI used to generate the binding from.
const BridgeTransferABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ERC20FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"FeeReceiverChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"handleNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lowerHandleNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"HandleValueTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"KLAYFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"requestNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"RequestValueTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"requestNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"encodingVer\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encodedData\",\"type\":\"bytes\"}],\"name\":\"RequestValueTransferEncoded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_OPERATOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"closedValueTransferVotes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"deregisterOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeOfERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOfKLAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"addresspayable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"handleNoncesToBlockNums\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"handledRequestTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerHandleNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modeMintBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"operatorThresholds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryBlockNumber\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enumBridgeOperator.VoteType\",\"name\":\"_voteType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"}],\"name\":\"setOperatorThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperHandleNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// BridgeTransferBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const BridgeTransferBinRuntime = ``

// BridgeTransferFuncSigs maps the 4-byte function signature to its string representation.
var BridgeTransferFuncSigs = map[string]string{
	"3a3099d1": "MAX_OPERATOR()",
	"9832c1d7": "closedValueTransferVotes(uint64)",
	"ac6fff0b": "configurationNonce()",
	"d8cf98ca": "deregisterOperator(address)",
	"488af871": "feeOfERC20(address)",
	"c263b5d6": "feeOfKLAY()",
	"b3f00674": "feeReceiver()",
	"b2c01030": "getOperatorList()",
	"13a6738a": "handleNoncesToBlockNums(uint64)",
	"8a75eee2": "handledRequestTx(bytes32)",
	"2014e5d1": "isRunning()",
	"4b40b826": "lowerHandleNonce()",
	"6e176ec2": "modeMintBurn()",
	"cb38f407": "operatorList(uint256)",
	"5526f76b": "operatorThresholds(uint8)",
	"13e7c9d8": "operators(address)",
	"8da5cb5b": "owner()",
	"989ba0d3": "recoveryBlockNumber()",
	"3682a450": "registerOperator(address)",
	"715018a6": "renounceOwnership()",
	"7c1a0302": "requestNonce()",
	"efdcd974": "setFeeReceiver(address)",
	"ee2aec65": "setOperatorThreshold(uint8,uint8)",
	"c877cf37": "start(bool)",
	"f2fde38b": "transferOwnership(address)",
	"54edad72": "upperHandleNonce()",
}

// BridgeTransfer is an auto generated Go binding around a Klaytn contract.
type BridgeTransfer struct {
	BridgeTransferCaller     // Read-only binding to the contract
	BridgeTransferTransactor // Write-only binding to the contract
	BridgeTransferFilterer   // Log filterer for contract events
}

// BridgeTransferCaller is an auto generated read-only Go binding around a Klaytn contract.
type BridgeTransferCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferTransactor is an auto generated write-only Go binding around a Klaytn contract.
type BridgeTransferTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type BridgeTransferFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type BridgeTransferSession struct {
	Contract     *BridgeTransfer   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BridgeTransferCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type BridgeTransferCallerSession struct {
	Contract *BridgeTransferCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// BridgeTransferTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type BridgeTransferTransactorSession struct {
	Contract     *BridgeTransferTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// BridgeTransferRaw is an auto generated low-level Go binding around a Klaytn contract.
type BridgeTransferRaw struct {
	Contract *BridgeTransfer // Generic contract binding to access the raw methods on
}

// BridgeTransferCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type BridgeTransferCallerRaw struct {
	Contract *BridgeTransferCaller // Generic read-only contract binding to access the raw methods on
}

// BridgeTransferTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type BridgeTransferTransactorRaw struct {
	Contract *BridgeTransferTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBridgeTransfer creates a new instance of BridgeTransfer, bound to a specific deployed contract.
func NewBridgeTransfer(address common.Address, backend bind.ContractBackend) (*BridgeTransfer, error) {
	contract, err := bindBridgeTransfer(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BridgeTransfer{BridgeTransferCaller: BridgeTransferCaller{contract: contract}, BridgeTransferTransactor: BridgeTransferTransactor{contract: contract}, BridgeTransferFilterer: BridgeTransferFilterer{contract: contract}}, nil
}

// NewBridgeTransferCaller creates a new read-only instance of BridgeTransfer, bound to a specific deployed contract.
func NewBridgeTransferCaller(address common.Address, caller bind.ContractCaller) (*BridgeTransferCaller, error) {
	contract, err := bindBridgeTransfer(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferCaller{contract: contract}, nil
}

// NewBridgeTransferTransactor creates a new write-only instance of BridgeTransfer, bound to a specific deployed contract.
func NewBridgeTransferTransactor(address common.Address, transactor bind.ContractTransactor) (*BridgeTransferTransactor, error) {
	contract, err := bindBridgeTransfer(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferTransactor{contract: contract}, nil
}

// NewBridgeTransferFilterer creates a new log filterer instance of BridgeTransfer, bound to a specific deployed contract.
func NewBridgeTransferFilterer(address common.Address, filterer bind.ContractFilterer) (*BridgeTransferFilterer, error) {
	contract, err := bindBridgeTransfer(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferFilterer{contract: contract}, nil
}

// bindBridgeTransfer binds a generic wrapper to an already deployed contract.
func bindBridgeTransfer(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeTransferABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeTransfer *BridgeTransferRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeTransfer.Contract.BridgeTransferCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeTransfer *BridgeTransferRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.BridgeTransferTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeTransfer *BridgeTransferRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.BridgeTransferTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeTransfer *BridgeTransferCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeTransfer.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeTransfer *BridgeTransferTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeTransfer *BridgeTransferTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.contract.Transact(opts, method, params...)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCaller) MAXOPERATOR(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "MAX_OPERATOR")
	return *ret0, err
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransfer *BridgeTransferSession) MAXOPERATOR() (uint64, error) {
	return _BridgeTransfer.Contract.MAXOPERATOR(&_BridgeTransfer.CallOpts)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCallerSession) MAXOPERATOR() (uint64, error) {
	return _BridgeTransfer.Contract.MAXOPERATOR(&_BridgeTransfer.CallOpts)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransfer *BridgeTransferCaller) ClosedValueTransferVotes(opts *bind.CallOpts, arg0 uint64) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "closedValueTransferVotes", arg0)
	return *ret0, err
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransfer *BridgeTransferSession) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _BridgeTransfer.Contract.ClosedValueTransferVotes(&_BridgeTransfer.CallOpts, arg0)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransfer *BridgeTransferCallerSession) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _BridgeTransfer.Contract.ClosedValueTransferVotes(&_BridgeTransfer.CallOpts, arg0)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCaller) ConfigurationNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "configurationNonce")
	return *ret0, err
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferSession) ConfigurationNonce() (uint64, error) {
	return _BridgeTransfer.Contract.ConfigurationNonce(&_BridgeTransfer.CallOpts)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCallerSession) ConfigurationNonce() (uint64, error) {
	return _BridgeTransfer.Contract.ConfigurationNonce(&_BridgeTransfer.CallOpts)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransfer *BridgeTransferCaller) FeeOfERC20(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "feeOfERC20", arg0)
	return *ret0, err
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransfer *BridgeTransferSession) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransfer.Contract.FeeOfERC20(&_BridgeTransfer.CallOpts, arg0)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransfer *BridgeTransferCallerSession) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransfer.Contract.FeeOfERC20(&_BridgeTransfer.CallOpts, arg0)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransfer *BridgeTransferCaller) FeeOfKLAY(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "feeOfKLAY")
	return *ret0, err
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransfer *BridgeTransferSession) FeeOfKLAY() (*big.Int, error) {
	return _BridgeTransfer.Contract.FeeOfKLAY(&_BridgeTransfer.CallOpts)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransfer *BridgeTransferCallerSession) FeeOfKLAY() (*big.Int, error) {
	return _BridgeTransfer.Contract.FeeOfKLAY(&_BridgeTransfer.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransfer *BridgeTransferCaller) FeeReceiver(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "feeReceiver")
	return *ret0, err
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransfer *BridgeTransferSession) FeeReceiver() (common.Address, error) {
	return _BridgeTransfer.Contract.FeeReceiver(&_BridgeTransfer.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransfer *BridgeTransferCallerSession) FeeReceiver() (common.Address, error) {
	return _BridgeTransfer.Contract.FeeReceiver(&_BridgeTransfer.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransfer *BridgeTransferCaller) GetOperatorList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "getOperatorList")
	return *ret0, err
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransfer *BridgeTransferSession) GetOperatorList() ([]common.Address, error) {
	return _BridgeTransfer.Contract.GetOperatorList(&_BridgeTransfer.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransfer *BridgeTransferCallerSession) GetOperatorList() ([]common.Address, error) {
	return _BridgeTransfer.Contract.GetOperatorList(&_BridgeTransfer.CallOpts)
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransfer *BridgeTransferCaller) HandleNoncesToBlockNums(opts *bind.CallOpts, arg0 uint64) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "handleNoncesToBlockNums", arg0)
	return *ret0, err
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransfer *BridgeTransferSession) HandleNoncesToBlockNums(arg0 uint64) (uint64, error) {
	return _BridgeTransfer.Contract.HandleNoncesToBlockNums(&_BridgeTransfer.CallOpts, arg0)
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransfer *BridgeTransferCallerSession) HandleNoncesToBlockNums(arg0 uint64) (uint64, error) {
	return _BridgeTransfer.Contract.HandleNoncesToBlockNums(&_BridgeTransfer.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransfer *BridgeTransferCaller) HandledRequestTx(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "handledRequestTx", arg0)
	return *ret0, err
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransfer *BridgeTransferSession) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _BridgeTransfer.Contract.HandledRequestTx(&_BridgeTransfer.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransfer *BridgeTransferCallerSession) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _BridgeTransfer.Contract.HandledRequestTx(&_BridgeTransfer.CallOpts, arg0)
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransfer *BridgeTransferCaller) IsRunning(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "isRunning")
	return *ret0, err
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransfer *BridgeTransferSession) IsRunning() (bool, error) {
	return _BridgeTransfer.Contract.IsRunning(&_BridgeTransfer.CallOpts)
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransfer *BridgeTransferCallerSession) IsRunning() (bool, error) {
	return _BridgeTransfer.Contract.IsRunning(&_BridgeTransfer.CallOpts)
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCaller) LowerHandleNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "lowerHandleNonce")
	return *ret0, err
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferSession) LowerHandleNonce() (uint64, error) {
	return _BridgeTransfer.Contract.LowerHandleNonce(&_BridgeTransfer.CallOpts)
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCallerSession) LowerHandleNonce() (uint64, error) {
	return _BridgeTransfer.Contract.LowerHandleNonce(&_BridgeTransfer.CallOpts)
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransfer *BridgeTransferCaller) ModeMintBurn(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "modeMintBurn")
	return *ret0, err
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransfer *BridgeTransferSession) ModeMintBurn() (bool, error) {
	return _BridgeTransfer.Contract.ModeMintBurn(&_BridgeTransfer.CallOpts)
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransfer *BridgeTransferCallerSession) ModeMintBurn() (bool, error) {
	return _BridgeTransfer.Contract.ModeMintBurn(&_BridgeTransfer.CallOpts)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransfer *BridgeTransferCaller) OperatorList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "operatorList", arg0)
	return *ret0, err
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransfer *BridgeTransferSession) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransfer.Contract.OperatorList(&_BridgeTransfer.CallOpts, arg0)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransfer *BridgeTransferCallerSession) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransfer.Contract.OperatorList(&_BridgeTransfer.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransfer *BridgeTransferCaller) OperatorThresholds(opts *bind.CallOpts, arg0 uint8) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "operatorThresholds", arg0)
	return *ret0, err
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransfer *BridgeTransferSession) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _BridgeTransfer.Contract.OperatorThresholds(&_BridgeTransfer.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransfer *BridgeTransferCallerSession) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _BridgeTransfer.Contract.OperatorThresholds(&_BridgeTransfer.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransfer *BridgeTransferCaller) Operators(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "operators", arg0)
	return *ret0, err
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransfer *BridgeTransferSession) Operators(arg0 common.Address) (bool, error) {
	return _BridgeTransfer.Contract.Operators(&_BridgeTransfer.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransfer *BridgeTransferCallerSession) Operators(arg0 common.Address) (bool, error) {
	return _BridgeTransfer.Contract.Operators(&_BridgeTransfer.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransfer *BridgeTransferCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransfer *BridgeTransferSession) Owner() (common.Address, error) {
	return _BridgeTransfer.Contract.Owner(&_BridgeTransfer.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransfer *BridgeTransferCallerSession) Owner() (common.Address, error) {
	return _BridgeTransfer.Contract.Owner(&_BridgeTransfer.CallOpts)
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCaller) RecoveryBlockNumber(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "recoveryBlockNumber")
	return *ret0, err
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransfer *BridgeTransferSession) RecoveryBlockNumber() (uint64, error) {
	return _BridgeTransfer.Contract.RecoveryBlockNumber(&_BridgeTransfer.CallOpts)
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCallerSession) RecoveryBlockNumber() (uint64, error) {
	return _BridgeTransfer.Contract.RecoveryBlockNumber(&_BridgeTransfer.CallOpts)
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCaller) RequestNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "requestNonce")
	return *ret0, err
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferSession) RequestNonce() (uint64, error) {
	return _BridgeTransfer.Contract.RequestNonce(&_BridgeTransfer.CallOpts)
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCallerSession) RequestNonce() (uint64, error) {
	return _BridgeTransfer.Contract.RequestNonce(&_BridgeTransfer.CallOpts)
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCaller) UpperHandleNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransfer.contract.Call(opts, out, "upperHandleNonce")
	return *ret0, err
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferSession) UpperHandleNonce() (uint64, error) {
	return _BridgeTransfer.Contract.UpperHandleNonce(&_BridgeTransfer.CallOpts)
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransfer *BridgeTransferCallerSession) UpperHandleNonce() (uint64, error) {
	return _BridgeTransfer.Contract.UpperHandleNonce(&_BridgeTransfer.CallOpts)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransfer *BridgeTransferTransactor) DeregisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.contract.Transact(opts, "deregisterOperator", _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransfer *BridgeTransferSession) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.DeregisterOperator(&_BridgeTransfer.TransactOpts, _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransfer *BridgeTransferTransactorSession) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.DeregisterOperator(&_BridgeTransfer.TransactOpts, _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransfer *BridgeTransferTransactor) RegisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.contract.Transact(opts, "registerOperator", _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransfer *BridgeTransferSession) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.RegisterOperator(&_BridgeTransfer.TransactOpts, _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransfer *BridgeTransferTransactorSession) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.RegisterOperator(&_BridgeTransfer.TransactOpts, _operator)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransfer *BridgeTransferTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransfer.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransfer *BridgeTransferSession) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeTransfer.Contract.RenounceOwnership(&_BridgeTransfer.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransfer *BridgeTransferTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeTransfer.Contract.RenounceOwnership(&_BridgeTransfer.TransactOpts)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransfer *BridgeTransferTransactor) SetFeeReceiver(opts *bind.TransactOpts, _feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.contract.Transact(opts, "setFeeReceiver", _feeReceiver)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransfer *BridgeTransferSession) SetFeeReceiver(_feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.SetFeeReceiver(&_BridgeTransfer.TransactOpts, _feeReceiver)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransfer *BridgeTransferTransactorSession) SetFeeReceiver(_feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.SetFeeReceiver(&_BridgeTransfer.TransactOpts, _feeReceiver)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransfer *BridgeTransferTransactor) SetOperatorThreshold(opts *bind.TransactOpts, _voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransfer.contract.Transact(opts, "setOperatorThreshold", _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransfer *BridgeTransferSession) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.SetOperatorThreshold(&_BridgeTransfer.TransactOpts, _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransfer *BridgeTransferTransactorSession) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.SetOperatorThreshold(&_BridgeTransfer.TransactOpts, _voteType, _threshold)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransfer *BridgeTransferTransactor) Start(opts *bind.TransactOpts, _status bool) (*types.Transaction, error) {
	return _BridgeTransfer.contract.Transact(opts, "start", _status)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransfer *BridgeTransferSession) Start(_status bool) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.Start(&_BridgeTransfer.TransactOpts, _status)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransfer *BridgeTransferTransactorSession) Start(_status bool) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.Start(&_BridgeTransfer.TransactOpts, _status)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransfer *BridgeTransferTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransfer *BridgeTransferSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.TransferOwnership(&_BridgeTransfer.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransfer *BridgeTransferTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransfer.Contract.TransferOwnership(&_BridgeTransfer.TransactOpts, newOwner)
}

// BridgeTransferERC20FeeChangedIterator is returned from FilterERC20FeeChanged and is used to iterate over the raw logs and unpacked data for ERC20FeeChanged events raised by the BridgeTransfer contract.
type BridgeTransferERC20FeeChangedIterator struct {
	Event *BridgeTransferERC20FeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20FeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20FeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20FeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20FeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20FeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20FeeChanged represents a ERC20FeeChanged event raised by the BridgeTransfer contract.
type BridgeTransferERC20FeeChanged struct {
	Token common.Address
	Fee   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterERC20FeeChanged is a free log retrieval operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransfer *BridgeTransferFilterer) FilterERC20FeeChanged(opts *bind.FilterOpts, token []common.Address, fee []*big.Int) (*BridgeTransferERC20FeeChangedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransfer.contract.FilterLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20FeeChangedIterator{contract: _BridgeTransfer.contract, event: "ERC20FeeChanged", logs: logs, sub: sub}, nil
}

// WatchERC20FeeChanged is a free log subscription operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransfer *BridgeTransferFilterer) WatchERC20FeeChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20FeeChanged, token []common.Address, fee []*big.Int) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransfer.contract.WatchLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20FeeChanged)
				if err := _BridgeTransfer.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20FeeChanged is a log parse operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransfer *BridgeTransferFilterer) ParseERC20FeeChanged(log types.Log) (*BridgeTransferERC20FeeChanged, error) {
	event := new(BridgeTransferERC20FeeChanged)
	if err := _BridgeTransfer.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferFeeReceiverChangedIterator is returned from FilterFeeReceiverChanged and is used to iterate over the raw logs and unpacked data for FeeReceiverChanged events raised by the BridgeTransfer contract.
type BridgeTransferFeeReceiverChangedIterator struct {
	Event *BridgeTransferFeeReceiverChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferFeeReceiverChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferFeeReceiverChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferFeeReceiverChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferFeeReceiverChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferFeeReceiverChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferFeeReceiverChanged represents a FeeReceiverChanged event raised by the BridgeTransfer contract.
type BridgeTransferFeeReceiverChanged struct {
	FeeReceiver common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterFeeReceiverChanged is a free log retrieval operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransfer *BridgeTransferFilterer) FilterFeeReceiverChanged(opts *bind.FilterOpts, feeReceiver []common.Address) (*BridgeTransferFeeReceiverChangedIterator, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _BridgeTransfer.contract.FilterLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferFeeReceiverChangedIterator{contract: _BridgeTransfer.contract, event: "FeeReceiverChanged", logs: logs, sub: sub}, nil
}

// WatchFeeReceiverChanged is a free log subscription operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransfer *BridgeTransferFilterer) WatchFeeReceiverChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferFeeReceiverChanged, feeReceiver []common.Address) (event.Subscription, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _BridgeTransfer.contract.WatchLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferFeeReceiverChanged)
				if err := _BridgeTransfer.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeReceiverChanged is a log parse operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransfer *BridgeTransferFilterer) ParseFeeReceiverChanged(log types.Log) (*BridgeTransferFeeReceiverChanged, error) {
	event := new(BridgeTransferFeeReceiverChanged)
	if err := _BridgeTransfer.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferHandleValueTransferIterator is returned from FilterHandleValueTransfer and is used to iterate over the raw logs and unpacked data for HandleValueTransfer events raised by the BridgeTransfer contract.
type BridgeTransferHandleValueTransferIterator struct {
	Event *BridgeTransferHandleValueTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferHandleValueTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferHandleValueTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferHandleValueTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferHandleValueTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferHandleValueTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferHandleValueTransfer represents a HandleValueTransfer event raised by the BridgeTransfer contract.
type BridgeTransferHandleValueTransfer struct {
	RequestTxHash    [32]byte
	TokenType        uint8
	From             common.Address
	To               common.Address
	TokenAddress     common.Address
	ValueOrTokenId   *big.Int
	HandleNonce      uint64
	LowerHandleNonce uint64
	ExtraData        []byte
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterHandleValueTransfer is a free log retrieval operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransfer *BridgeTransferFilterer) FilterHandleValueTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferHandleValueTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransfer.contract.FilterLogs(opts, "HandleValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferHandleValueTransferIterator{contract: _BridgeTransfer.contract, event: "HandleValueTransfer", logs: logs, sub: sub}, nil
}

// WatchHandleValueTransfer is a free log subscription operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransfer *BridgeTransferFilterer) WatchHandleValueTransfer(opts *bind.WatchOpts, sink chan<- *BridgeTransferHandleValueTransfer, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransfer.contract.WatchLogs(opts, "HandleValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferHandleValueTransfer)
				if err := _BridgeTransfer.contract.UnpackLog(event, "HandleValueTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseHandleValueTransfer is a log parse operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransfer *BridgeTransferFilterer) ParseHandleValueTransfer(log types.Log) (*BridgeTransferHandleValueTransfer, error) {
	event := new(BridgeTransferHandleValueTransfer)
	if err := _BridgeTransfer.contract.UnpackLog(event, "HandleValueTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferKLAYFeeChangedIterator is returned from FilterKLAYFeeChanged and is used to iterate over the raw logs and unpacked data for KLAYFeeChanged events raised by the BridgeTransfer contract.
type BridgeTransferKLAYFeeChangedIterator struct {
	Event *BridgeTransferKLAYFeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferKLAYFeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferKLAYFeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferKLAYFeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferKLAYFeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferKLAYFeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferKLAYFeeChanged represents a KLAYFeeChanged event raised by the BridgeTransfer contract.
type BridgeTransferKLAYFeeChanged struct {
	Fee *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterKLAYFeeChanged is a free log retrieval operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransfer *BridgeTransferFilterer) FilterKLAYFeeChanged(opts *bind.FilterOpts, fee []*big.Int) (*BridgeTransferKLAYFeeChangedIterator, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransfer.contract.FilterLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferKLAYFeeChangedIterator{contract: _BridgeTransfer.contract, event: "KLAYFeeChanged", logs: logs, sub: sub}, nil
}

// WatchKLAYFeeChanged is a free log subscription operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransfer *BridgeTransferFilterer) WatchKLAYFeeChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferKLAYFeeChanged, fee []*big.Int) (event.Subscription, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransfer.contract.WatchLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferKLAYFeeChanged)
				if err := _BridgeTransfer.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKLAYFeeChanged is a log parse operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransfer *BridgeTransferFilterer) ParseKLAYFeeChanged(log types.Log) (*BridgeTransferKLAYFeeChanged, error) {
	event := new(BridgeTransferKLAYFeeChanged)
	if err := _BridgeTransfer.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BridgeTransfer contract.
type BridgeTransferOwnershipTransferredIterator struct {
	Event *BridgeTransferOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferOwnershipTransferred represents a OwnershipTransferred event raised by the BridgeTransfer contract.
type BridgeTransferOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransfer *BridgeTransferFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BridgeTransferOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeTransfer.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferOwnershipTransferredIterator{contract: _BridgeTransfer.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransfer *BridgeTransferFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BridgeTransferOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeTransfer.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferOwnershipTransferred)
				if err := _BridgeTransfer.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransfer *BridgeTransferFilterer) ParseOwnershipTransferred(log types.Log) (*BridgeTransferOwnershipTransferred, error) {
	event := new(BridgeTransferOwnershipTransferred)
	if err := _BridgeTransfer.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferRequestValueTransferIterator is returned from FilterRequestValueTransfer and is used to iterate over the raw logs and unpacked data for RequestValueTransfer events raised by the BridgeTransfer contract.
type BridgeTransferRequestValueTransferIterator struct {
	Event *BridgeTransferRequestValueTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferRequestValueTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferRequestValueTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferRequestValueTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferRequestValueTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferRequestValueTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferRequestValueTransfer represents a RequestValueTransfer event raised by the BridgeTransfer contract.
type BridgeTransferRequestValueTransfer struct {
	TokenType      uint8
	From           common.Address
	To             common.Address
	TokenAddress   common.Address
	ValueOrTokenId *big.Int
	RequestNonce   uint64
	Fee            *big.Int
	ExtraData      []byte
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterRequestValueTransfer is a free log retrieval operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransfer *BridgeTransferFilterer) FilterRequestValueTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferRequestValueTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransfer.contract.FilterLogs(opts, "RequestValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferRequestValueTransferIterator{contract: _BridgeTransfer.contract, event: "RequestValueTransfer", logs: logs, sub: sub}, nil
}

// WatchRequestValueTransfer is a free log subscription operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransfer *BridgeTransferFilterer) WatchRequestValueTransfer(opts *bind.WatchOpts, sink chan<- *BridgeTransferRequestValueTransfer, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransfer.contract.WatchLogs(opts, "RequestValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferRequestValueTransfer)
				if err := _BridgeTransfer.contract.UnpackLog(event, "RequestValueTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestValueTransfer is a log parse operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransfer *BridgeTransferFilterer) ParseRequestValueTransfer(log types.Log) (*BridgeTransferRequestValueTransfer, error) {
	event := new(BridgeTransferRequestValueTransfer)
	if err := _BridgeTransfer.contract.UnpackLog(event, "RequestValueTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferRequestValueTransferEncodedIterator is returned from FilterRequestValueTransferEncoded and is used to iterate over the raw logs and unpacked data for RequestValueTransferEncoded events raised by the BridgeTransfer contract.
type BridgeTransferRequestValueTransferEncodedIterator struct {
	Event *BridgeTransferRequestValueTransferEncoded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferRequestValueTransferEncodedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferRequestValueTransferEncoded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferRequestValueTransferEncoded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferRequestValueTransferEncodedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferRequestValueTransferEncodedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferRequestValueTransferEncoded represents a RequestValueTransferEncoded event raised by the BridgeTransfer contract.
type BridgeTransferRequestValueTransferEncoded struct {
	TokenType      uint8
	From           common.Address
	To             common.Address
	TokenAddress   common.Address
	ValueOrTokenId *big.Int
	RequestNonce   uint64
	Fee            *big.Int
	ExtraData      []byte
	EncodingVer    uint8
	EncodedData    []byte
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterRequestValueTransferEncoded is a free log retrieval operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransfer *BridgeTransferFilterer) FilterRequestValueTransferEncoded(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferRequestValueTransferEncodedIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransfer.contract.FilterLogs(opts, "RequestValueTransferEncoded", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferRequestValueTransferEncodedIterator{contract: _BridgeTransfer.contract, event: "RequestValueTransferEncoded", logs: logs, sub: sub}, nil
}

// WatchRequestValueTransferEncoded is a free log subscription operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransfer *BridgeTransferFilterer) WatchRequestValueTransferEncoded(opts *bind.WatchOpts, sink chan<- *BridgeTransferRequestValueTransferEncoded, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransfer.contract.WatchLogs(opts, "RequestValueTransferEncoded", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferRequestValueTransferEncoded)
				if err := _BridgeTransfer.contract.UnpackLog(event, "RequestValueTransferEncoded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestValueTransferEncoded is a log parse operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransfer *BridgeTransferFilterer) ParseRequestValueTransferEncoded(log types.Log) (*BridgeTransferRequestValueTransferEncoded, error) {
	event := new(BridgeTransferRequestValueTransferEncoded)
	if err := _BridgeTransfer.contract.UnpackLog(event, "RequestValueTransferEncoded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20ABI is the input ABI used to generate the binding from.
const BridgeTransferERC20ABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ERC20FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"FeeReceiverChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"handleNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lowerHandleNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"HandleValueTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"KLAYFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"requestNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"RequestValueTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"requestNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"encodingVer\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encodedData\",\"type\":\"bytes\"}],\"name\":\"RequestValueTransferEncoded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_OPERATOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"closedValueTransferVotes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"deregisterOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"deregisterToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeOfERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOfKLAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"addresspayable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_requestedNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_requestedBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"handleERC20Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"handleNoncesToBlockNums\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"handledRequestTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexOfTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerHandleNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modeMintBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onERC20Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"operatorThresholds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryBlockNumber\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"registerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredTokenList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"requestERC20Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_requestNonce\",\"type\":\"uint64\"}],\"name\":\"setERC20Fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enumBridgeOperator.VoteType\",\"name\":\"_voteType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"}],\"name\":\"setOperatorThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"unlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperHandleNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// BridgeTransferERC20BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const BridgeTransferERC20BinRuntime = ``

// BridgeTransferERC20FuncSigs maps the 4-byte function signature to its string representation.
var BridgeTransferERC20FuncSigs = map[string]string{
	"3a3099d1": "MAX_OPERATOR()",
	"9832c1d7": "closedValueTransferVotes(uint64)",
	"ac6fff0b": "configurationNonce()",
	"d8cf98ca": "deregisterOperator(address)",
	"bab2af1d": "deregisterToken(address)",
	"488af871": "feeOfERC20(address)",
	"c263b5d6": "feeOfKLAY()",
	"b3f00674": "feeReceiver()",
	"b2c01030": "getOperatorList()",
	"ea21eade": "getRegisteredTokenList()",
	"407e6bae": "handleERC20Transfer(bytes32,address,address,address,uint256,uint64,uint64,bytes)",
	"13a6738a": "handleNoncesToBlockNums(uint64)",
	"8a75eee2": "handledRequestTx(bytes32)",
	"48a18a6a": "indexOfTokens(address)",
	"2014e5d1": "isRunning()",
	"10693fcd": "lockToken(address)",
	"5eb7413a": "lockedTokens(address)",
	"4b40b826": "lowerHandleNonce()",
	"6e176ec2": "modeMintBurn()",
	"f1656e53": "onERC20Received(address,address,uint256,uint256,bytes)",
	"cb38f407": "operatorList(uint256)",
	"5526f76b": "operatorThresholds(uint8)",
	"13e7c9d8": "operators(address)",
	"8da5cb5b": "owner()",
	"989ba0d3": "recoveryBlockNumber()",
	"3682a450": "registerOperator(address)",
	"4739f7e5": "registerToken(address,address)",
	"3e4fe949": "registeredTokenList(uint256)",
	"8c0bd916": "registeredTokens(address)",
	"715018a6": "renounceOwnership()",
	"26c23b54": "requestERC20Transfer(address,address,uint256,uint256,bytes)",
	"7c1a0302": "requestNonce()",
	"2f88396c": "setERC20Fee(address,uint256,uint64)",
	"efdcd974": "setFeeReceiver(address)",
	"ee2aec65": "setOperatorThreshold(uint8,uint8)",
	"c877cf37": "start(bool)",
	"f2fde38b": "transferOwnership(address)",
	"9ef2017b": "unlockToken(address)",
	"54edad72": "upperHandleNonce()",
}

// BridgeTransferERC20 is an auto generated Go binding around a Klaytn contract.
type BridgeTransferERC20 struct {
	BridgeTransferERC20Caller     // Read-only binding to the contract
	BridgeTransferERC20Transactor // Write-only binding to the contract
	BridgeTransferERC20Filterer   // Log filterer for contract events
}

// BridgeTransferERC20Caller is an auto generated read-only Go binding around a Klaytn contract.
type BridgeTransferERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferERC20Transactor is an auto generated write-only Go binding around a Klaytn contract.
type BridgeTransferERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferERC20Filterer is an auto generated log filtering Go binding around a Klaytn contract events.
type BridgeTransferERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferERC20Session is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type BridgeTransferERC20Session struct {
	Contract     *BridgeTransferERC20 // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// BridgeTransferERC20CallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type BridgeTransferERC20CallerSession struct {
	Contract *BridgeTransferERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// BridgeTransferERC20TransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type BridgeTransferERC20TransactorSession struct {
	Contract     *BridgeTransferERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// BridgeTransferERC20Raw is an auto generated low-level Go binding around a Klaytn contract.
type BridgeTransferERC20Raw struct {
	Contract *BridgeTransferERC20 // Generic contract binding to access the raw methods on
}

// BridgeTransferERC20CallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type BridgeTransferERC20CallerRaw struct {
	Contract *BridgeTransferERC20Caller // Generic read-only contract binding to access the raw methods on
}

// BridgeTransferERC20TransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type BridgeTransferERC20TransactorRaw struct {
	Contract *BridgeTransferERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewBridgeTransferERC20 creates a new instance of BridgeTransferERC20, bound to a specific deployed contract.
func NewBridgeTransferERC20(address common.Address, backend bind.ContractBackend) (*BridgeTransferERC20, error) {
	contract, err := bindBridgeTransferERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20{BridgeTransferERC20Caller: BridgeTransferERC20Caller{contract: contract}, BridgeTransferERC20Transactor: BridgeTransferERC20Transactor{contract: contract}, BridgeTransferERC20Filterer: BridgeTransferERC20Filterer{contract: contract}}, nil
}

// NewBridgeTransferERC20Caller creates a new read-only instance of BridgeTransferERC20, bound to a specific deployed contract.
func NewBridgeTransferERC20Caller(address common.Address, caller bind.ContractCaller) (*BridgeTransferERC20Caller, error) {
	contract, err := bindBridgeTransferERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20Caller{contract: contract}, nil
}

// NewBridgeTransferERC20Transactor creates a new write-only instance of BridgeTransferERC20, bound to a specific deployed contract.
func NewBridgeTransferERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*BridgeTransferERC20Transactor, error) {
	contract, err := bindBridgeTransferERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20Transactor{contract: contract}, nil
}

// NewBridgeTransferERC20Filterer creates a new log filterer instance of BridgeTransferERC20, bound to a specific deployed contract.
func NewBridgeTransferERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*BridgeTransferERC20Filterer, error) {
	contract, err := bindBridgeTransferERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20Filterer{contract: contract}, nil
}

// bindBridgeTransferERC20 binds a generic wrapper to an already deployed contract.
func bindBridgeTransferERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeTransferERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeTransferERC20 *BridgeTransferERC20Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeTransferERC20.Contract.BridgeTransferERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeTransferERC20 *BridgeTransferERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.BridgeTransferERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeTransferERC20 *BridgeTransferERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.BridgeTransferERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeTransferERC20 *BridgeTransferERC20CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeTransferERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.contract.Transact(opts, method, params...)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) MAXOPERATOR(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "MAX_OPERATOR")
	return *ret0, err
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) MAXOPERATOR() (uint64, error) {
	return _BridgeTransferERC20.Contract.MAXOPERATOR(&_BridgeTransferERC20.CallOpts)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) MAXOPERATOR() (uint64, error) {
	return _BridgeTransferERC20.Contract.MAXOPERATOR(&_BridgeTransferERC20.CallOpts)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) ClosedValueTransferVotes(opts *bind.CallOpts, arg0 uint64) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "closedValueTransferVotes", arg0)
	return *ret0, err
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _BridgeTransferERC20.Contract.ClosedValueTransferVotes(&_BridgeTransferERC20.CallOpts, arg0)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _BridgeTransferERC20.Contract.ClosedValueTransferVotes(&_BridgeTransferERC20.CallOpts, arg0)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) ConfigurationNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "configurationNonce")
	return *ret0, err
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) ConfigurationNonce() (uint64, error) {
	return _BridgeTransferERC20.Contract.ConfigurationNonce(&_BridgeTransferERC20.CallOpts)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) ConfigurationNonce() (uint64, error) {
	return _BridgeTransferERC20.Contract.ConfigurationNonce(&_BridgeTransferERC20.CallOpts)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) FeeOfERC20(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "feeOfERC20", arg0)
	return *ret0, err
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransferERC20.Contract.FeeOfERC20(&_BridgeTransferERC20.CallOpts, arg0)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransferERC20.Contract.FeeOfERC20(&_BridgeTransferERC20.CallOpts, arg0)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) FeeOfKLAY(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "feeOfKLAY")
	return *ret0, err
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) FeeOfKLAY() (*big.Int, error) {
	return _BridgeTransferERC20.Contract.FeeOfKLAY(&_BridgeTransferERC20.CallOpts)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) FeeOfKLAY() (*big.Int, error) {
	return _BridgeTransferERC20.Contract.FeeOfKLAY(&_BridgeTransferERC20.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) FeeReceiver(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "feeReceiver")
	return *ret0, err
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) FeeReceiver() (common.Address, error) {
	return _BridgeTransferERC20.Contract.FeeReceiver(&_BridgeTransferERC20.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) FeeReceiver() (common.Address, error) {
	return _BridgeTransferERC20.Contract.FeeReceiver(&_BridgeTransferERC20.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) GetOperatorList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "getOperatorList")
	return *ret0, err
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransferERC20 *BridgeTransferERC20Session) GetOperatorList() ([]common.Address, error) {
	return _BridgeTransferERC20.Contract.GetOperatorList(&_BridgeTransferERC20.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) GetOperatorList() ([]common.Address, error) {
	return _BridgeTransferERC20.Contract.GetOperatorList(&_BridgeTransferERC20.CallOpts)
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) GetRegisteredTokenList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "getRegisteredTokenList")
	return *ret0, err
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTransferERC20 *BridgeTransferERC20Session) GetRegisteredTokenList() ([]common.Address, error) {
	return _BridgeTransferERC20.Contract.GetRegisteredTokenList(&_BridgeTransferERC20.CallOpts)
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) GetRegisteredTokenList() ([]common.Address, error) {
	return _BridgeTransferERC20.Contract.GetRegisteredTokenList(&_BridgeTransferERC20.CallOpts)
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) HandleNoncesToBlockNums(opts *bind.CallOpts, arg0 uint64) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "handleNoncesToBlockNums", arg0)
	return *ret0, err
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) HandleNoncesToBlockNums(arg0 uint64) (uint64, error) {
	return _BridgeTransferERC20.Contract.HandleNoncesToBlockNums(&_BridgeTransferERC20.CallOpts, arg0)
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) HandleNoncesToBlockNums(arg0 uint64) (uint64, error) {
	return _BridgeTransferERC20.Contract.HandleNoncesToBlockNums(&_BridgeTransferERC20.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) HandledRequestTx(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "handledRequestTx", arg0)
	return *ret0, err
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _BridgeTransferERC20.Contract.HandledRequestTx(&_BridgeTransferERC20.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _BridgeTransferERC20.Contract.HandledRequestTx(&_BridgeTransferERC20.CallOpts, arg0)
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) IndexOfTokens(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "indexOfTokens", arg0)
	return *ret0, err
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) IndexOfTokens(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransferERC20.Contract.IndexOfTokens(&_BridgeTransferERC20.CallOpts, arg0)
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) IndexOfTokens(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransferERC20.Contract.IndexOfTokens(&_BridgeTransferERC20.CallOpts, arg0)
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) IsRunning(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "isRunning")
	return *ret0, err
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) IsRunning() (bool, error) {
	return _BridgeTransferERC20.Contract.IsRunning(&_BridgeTransferERC20.CallOpts)
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) IsRunning() (bool, error) {
	return _BridgeTransferERC20.Contract.IsRunning(&_BridgeTransferERC20.CallOpts)
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) LockedTokens(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "lockedTokens", arg0)
	return *ret0, err
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) LockedTokens(arg0 common.Address) (bool, error) {
	return _BridgeTransferERC20.Contract.LockedTokens(&_BridgeTransferERC20.CallOpts, arg0)
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) LockedTokens(arg0 common.Address) (bool, error) {
	return _BridgeTransferERC20.Contract.LockedTokens(&_BridgeTransferERC20.CallOpts, arg0)
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) LowerHandleNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "lowerHandleNonce")
	return *ret0, err
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) LowerHandleNonce() (uint64, error) {
	return _BridgeTransferERC20.Contract.LowerHandleNonce(&_BridgeTransferERC20.CallOpts)
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) LowerHandleNonce() (uint64, error) {
	return _BridgeTransferERC20.Contract.LowerHandleNonce(&_BridgeTransferERC20.CallOpts)
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) ModeMintBurn(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "modeMintBurn")
	return *ret0, err
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) ModeMintBurn() (bool, error) {
	return _BridgeTransferERC20.Contract.ModeMintBurn(&_BridgeTransferERC20.CallOpts)
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) ModeMintBurn() (bool, error) {
	return _BridgeTransferERC20.Contract.ModeMintBurn(&_BridgeTransferERC20.CallOpts)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) OperatorList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "operatorList", arg0)
	return *ret0, err
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransferERC20.Contract.OperatorList(&_BridgeTransferERC20.CallOpts, arg0)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransferERC20.Contract.OperatorList(&_BridgeTransferERC20.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) OperatorThresholds(opts *bind.CallOpts, arg0 uint8) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "operatorThresholds", arg0)
	return *ret0, err
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _BridgeTransferERC20.Contract.OperatorThresholds(&_BridgeTransferERC20.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _BridgeTransferERC20.Contract.OperatorThresholds(&_BridgeTransferERC20.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) Operators(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "operators", arg0)
	return *ret0, err
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) Operators(arg0 common.Address) (bool, error) {
	return _BridgeTransferERC20.Contract.Operators(&_BridgeTransferERC20.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) Operators(arg0 common.Address) (bool, error) {
	return _BridgeTransferERC20.Contract.Operators(&_BridgeTransferERC20.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) Owner() (common.Address, error) {
	return _BridgeTransferERC20.Contract.Owner(&_BridgeTransferERC20.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) Owner() (common.Address, error) {
	return _BridgeTransferERC20.Contract.Owner(&_BridgeTransferERC20.CallOpts)
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) RecoveryBlockNumber(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "recoveryBlockNumber")
	return *ret0, err
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) RecoveryBlockNumber() (uint64, error) {
	return _BridgeTransferERC20.Contract.RecoveryBlockNumber(&_BridgeTransferERC20.CallOpts)
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) RecoveryBlockNumber() (uint64, error) {
	return _BridgeTransferERC20.Contract.RecoveryBlockNumber(&_BridgeTransferERC20.CallOpts)
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) RegisteredTokenList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "registeredTokenList", arg0)
	return *ret0, err
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) RegisteredTokenList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransferERC20.Contract.RegisteredTokenList(&_BridgeTransferERC20.CallOpts, arg0)
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) RegisteredTokenList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransferERC20.Contract.RegisteredTokenList(&_BridgeTransferERC20.CallOpts, arg0)
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) RegisteredTokens(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "registeredTokens", arg0)
	return *ret0, err
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) RegisteredTokens(arg0 common.Address) (common.Address, error) {
	return _BridgeTransferERC20.Contract.RegisteredTokens(&_BridgeTransferERC20.CallOpts, arg0)
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) RegisteredTokens(arg0 common.Address) (common.Address, error) {
	return _BridgeTransferERC20.Contract.RegisteredTokens(&_BridgeTransferERC20.CallOpts, arg0)
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) RequestNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "requestNonce")
	return *ret0, err
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) RequestNonce() (uint64, error) {
	return _BridgeTransferERC20.Contract.RequestNonce(&_BridgeTransferERC20.CallOpts)
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) RequestNonce() (uint64, error) {
	return _BridgeTransferERC20.Contract.RequestNonce(&_BridgeTransferERC20.CallOpts)
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Caller) UpperHandleNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC20.contract.Call(opts, out, "upperHandleNonce")
	return *ret0, err
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20Session) UpperHandleNonce() (uint64, error) {
	return _BridgeTransferERC20.Contract.UpperHandleNonce(&_BridgeTransferERC20.CallOpts)
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransferERC20 *BridgeTransferERC20CallerSession) UpperHandleNonce() (uint64, error) {
	return _BridgeTransferERC20.Contract.UpperHandleNonce(&_BridgeTransferERC20.CallOpts)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) DeregisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "deregisterOperator", _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.DeregisterOperator(&_BridgeTransferERC20.TransactOpts, _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.DeregisterOperator(&_BridgeTransferERC20.TransactOpts, _operator)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) DeregisterToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "deregisterToken", _token)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) DeregisterToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.DeregisterToken(&_BridgeTransferERC20.TransactOpts, _token)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) DeregisterToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.DeregisterToken(&_BridgeTransferERC20.TransactOpts, _token)
}

// HandleERC20Transfer is a paid mutator transaction binding the contract method 0x407e6bae.
//
// Solidity: function handleERC20Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _value, uint64 _requestedNonce, uint64 _requestedBlockNumber, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) HandleERC20Transfer(opts *bind.TransactOpts, _requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _value *big.Int, _requestedNonce uint64, _requestedBlockNumber uint64, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "handleERC20Transfer", _requestTxHash, _from, _to, _tokenAddress, _value, _requestedNonce, _requestedBlockNumber, _extraData)
}

// HandleERC20Transfer is a paid mutator transaction binding the contract method 0x407e6bae.
//
// Solidity: function handleERC20Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _value, uint64 _requestedNonce, uint64 _requestedBlockNumber, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) HandleERC20Transfer(_requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _value *big.Int, _requestedNonce uint64, _requestedBlockNumber uint64, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.HandleERC20Transfer(&_BridgeTransferERC20.TransactOpts, _requestTxHash, _from, _to, _tokenAddress, _value, _requestedNonce, _requestedBlockNumber, _extraData)
}

// HandleERC20Transfer is a paid mutator transaction binding the contract method 0x407e6bae.
//
// Solidity: function handleERC20Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _value, uint64 _requestedNonce, uint64 _requestedBlockNumber, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) HandleERC20Transfer(_requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _value *big.Int, _requestedNonce uint64, _requestedBlockNumber uint64, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.HandleERC20Transfer(&_BridgeTransferERC20.TransactOpts, _requestTxHash, _from, _to, _tokenAddress, _value, _requestedNonce, _requestedBlockNumber, _extraData)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) LockToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "lockToken", _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) LockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.LockToken(&_BridgeTransferERC20.TransactOpts, _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) LockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.LockToken(&_BridgeTransferERC20.TransactOpts, _token)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) OnERC20Received(opts *bind.TransactOpts, _from common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "onERC20Received", _from, _to, _value, _feeLimit, _extraData)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) OnERC20Received(_from common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.OnERC20Received(&_BridgeTransferERC20.TransactOpts, _from, _to, _value, _feeLimit, _extraData)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) OnERC20Received(_from common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.OnERC20Received(&_BridgeTransferERC20.TransactOpts, _from, _to, _value, _feeLimit, _extraData)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) RegisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "registerOperator", _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.RegisterOperator(&_BridgeTransferERC20.TransactOpts, _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.RegisterOperator(&_BridgeTransferERC20.TransactOpts, _operator)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) RegisterToken(opts *bind.TransactOpts, _token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "registerToken", _token, _cToken)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) RegisterToken(_token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.RegisterToken(&_BridgeTransferERC20.TransactOpts, _token, _cToken)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) RegisterToken(_token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.RegisterToken(&_BridgeTransferERC20.TransactOpts, _token, _cToken)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.RenounceOwnership(&_BridgeTransferERC20.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.RenounceOwnership(&_BridgeTransferERC20.TransactOpts)
}

// RequestERC20Transfer is a paid mutator transaction binding the contract method 0x26c23b54.
//
// Solidity: function requestERC20Transfer(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) RequestERC20Transfer(opts *bind.TransactOpts, _tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "requestERC20Transfer", _tokenAddress, _to, _value, _feeLimit, _extraData)
}

// RequestERC20Transfer is a paid mutator transaction binding the contract method 0x26c23b54.
//
// Solidity: function requestERC20Transfer(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) RequestERC20Transfer(_tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.RequestERC20Transfer(&_BridgeTransferERC20.TransactOpts, _tokenAddress, _to, _value, _feeLimit, _extraData)
}

// RequestERC20Transfer is a paid mutator transaction binding the contract method 0x26c23b54.
//
// Solidity: function requestERC20Transfer(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) RequestERC20Transfer(_tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.RequestERC20Transfer(&_BridgeTransferERC20.TransactOpts, _tokenAddress, _to, _value, _feeLimit, _extraData)
}

// SetERC20Fee is a paid mutator transaction binding the contract method 0x2f88396c.
//
// Solidity: function setERC20Fee(address _token, uint256 _fee, uint64 _requestNonce) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) SetERC20Fee(opts *bind.TransactOpts, _token common.Address, _fee *big.Int, _requestNonce uint64) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "setERC20Fee", _token, _fee, _requestNonce)
}

// SetERC20Fee is a paid mutator transaction binding the contract method 0x2f88396c.
//
// Solidity: function setERC20Fee(address _token, uint256 _fee, uint64 _requestNonce) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) SetERC20Fee(_token common.Address, _fee *big.Int, _requestNonce uint64) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.SetERC20Fee(&_BridgeTransferERC20.TransactOpts, _token, _fee, _requestNonce)
}

// SetERC20Fee is a paid mutator transaction binding the contract method 0x2f88396c.
//
// Solidity: function setERC20Fee(address _token, uint256 _fee, uint64 _requestNonce) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) SetERC20Fee(_token common.Address, _fee *big.Int, _requestNonce uint64) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.SetERC20Fee(&_BridgeTransferERC20.TransactOpts, _token, _fee, _requestNonce)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) SetFeeReceiver(opts *bind.TransactOpts, _feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "setFeeReceiver", _feeReceiver)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) SetFeeReceiver(_feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.SetFeeReceiver(&_BridgeTransferERC20.TransactOpts, _feeReceiver)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) SetFeeReceiver(_feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.SetFeeReceiver(&_BridgeTransferERC20.TransactOpts, _feeReceiver)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) SetOperatorThreshold(opts *bind.TransactOpts, _voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "setOperatorThreshold", _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.SetOperatorThreshold(&_BridgeTransferERC20.TransactOpts, _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.SetOperatorThreshold(&_BridgeTransferERC20.TransactOpts, _voteType, _threshold)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) Start(opts *bind.TransactOpts, _status bool) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "start", _status)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) Start(_status bool) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.Start(&_BridgeTransferERC20.TransactOpts, _status)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) Start(_status bool) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.Start(&_BridgeTransferERC20.TransactOpts, _status)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.TransferOwnership(&_BridgeTransferERC20.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.TransferOwnership(&_BridgeTransferERC20.TransactOpts, newOwner)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Transactor) UnlockToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.contract.Transact(opts, "unlockToken", _token)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20Session) UnlockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.UnlockToken(&_BridgeTransferERC20.TransactOpts, _token)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTransferERC20 *BridgeTransferERC20TransactorSession) UnlockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC20.Contract.UnlockToken(&_BridgeTransferERC20.TransactOpts, _token)
}

// BridgeTransferERC20ERC20FeeChangedIterator is returned from FilterERC20FeeChanged and is used to iterate over the raw logs and unpacked data for ERC20FeeChanged events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20ERC20FeeChangedIterator struct {
	Event *BridgeTransferERC20ERC20FeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20ERC20FeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20ERC20FeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20ERC20FeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20ERC20FeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20ERC20FeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20ERC20FeeChanged represents a ERC20FeeChanged event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20ERC20FeeChanged struct {
	Token common.Address
	Fee   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterERC20FeeChanged is a free log retrieval operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterERC20FeeChanged(opts *bind.FilterOpts, token []common.Address, fee []*big.Int) (*BridgeTransferERC20ERC20FeeChangedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20ERC20FeeChangedIterator{contract: _BridgeTransferERC20.contract, event: "ERC20FeeChanged", logs: logs, sub: sub}, nil
}

// WatchERC20FeeChanged is a free log subscription operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchERC20FeeChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20ERC20FeeChanged, token []common.Address, fee []*big.Int) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20ERC20FeeChanged)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20FeeChanged is a log parse operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseERC20FeeChanged(log types.Log) (*BridgeTransferERC20ERC20FeeChanged, error) {
	event := new(BridgeTransferERC20ERC20FeeChanged)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20FeeReceiverChangedIterator is returned from FilterFeeReceiverChanged and is used to iterate over the raw logs and unpacked data for FeeReceiverChanged events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20FeeReceiverChangedIterator struct {
	Event *BridgeTransferERC20FeeReceiverChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20FeeReceiverChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20FeeReceiverChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20FeeReceiverChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20FeeReceiverChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20FeeReceiverChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20FeeReceiverChanged represents a FeeReceiverChanged event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20FeeReceiverChanged struct {
	FeeReceiver common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterFeeReceiverChanged is a free log retrieval operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterFeeReceiverChanged(opts *bind.FilterOpts, feeReceiver []common.Address) (*BridgeTransferERC20FeeReceiverChangedIterator, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20FeeReceiverChangedIterator{contract: _BridgeTransferERC20.contract, event: "FeeReceiverChanged", logs: logs, sub: sub}, nil
}

// WatchFeeReceiverChanged is a free log subscription operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchFeeReceiverChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20FeeReceiverChanged, feeReceiver []common.Address) (event.Subscription, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20FeeReceiverChanged)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeReceiverChanged is a log parse operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseFeeReceiverChanged(log types.Log) (*BridgeTransferERC20FeeReceiverChanged, error) {
	event := new(BridgeTransferERC20FeeReceiverChanged)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20HandleValueTransferIterator is returned from FilterHandleValueTransfer and is used to iterate over the raw logs and unpacked data for HandleValueTransfer events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20HandleValueTransferIterator struct {
	Event *BridgeTransferERC20HandleValueTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20HandleValueTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20HandleValueTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20HandleValueTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20HandleValueTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20HandleValueTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20HandleValueTransfer represents a HandleValueTransfer event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20HandleValueTransfer struct {
	RequestTxHash    [32]byte
	TokenType        uint8
	From             common.Address
	To               common.Address
	TokenAddress     common.Address
	ValueOrTokenId   *big.Int
	HandleNonce      uint64
	LowerHandleNonce uint64
	ExtraData        []byte
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterHandleValueTransfer is a free log retrieval operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterHandleValueTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferERC20HandleValueTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "HandleValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20HandleValueTransferIterator{contract: _BridgeTransferERC20.contract, event: "HandleValueTransfer", logs: logs, sub: sub}, nil
}

// WatchHandleValueTransfer is a free log subscription operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchHandleValueTransfer(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20HandleValueTransfer, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "HandleValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20HandleValueTransfer)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "HandleValueTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseHandleValueTransfer is a log parse operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseHandleValueTransfer(log types.Log) (*BridgeTransferERC20HandleValueTransfer, error) {
	event := new(BridgeTransferERC20HandleValueTransfer)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "HandleValueTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20KLAYFeeChangedIterator is returned from FilterKLAYFeeChanged and is used to iterate over the raw logs and unpacked data for KLAYFeeChanged events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20KLAYFeeChangedIterator struct {
	Event *BridgeTransferERC20KLAYFeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20KLAYFeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20KLAYFeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20KLAYFeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20KLAYFeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20KLAYFeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20KLAYFeeChanged represents a KLAYFeeChanged event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20KLAYFeeChanged struct {
	Fee *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterKLAYFeeChanged is a free log retrieval operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterKLAYFeeChanged(opts *bind.FilterOpts, fee []*big.Int) (*BridgeTransferERC20KLAYFeeChangedIterator, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20KLAYFeeChangedIterator{contract: _BridgeTransferERC20.contract, event: "KLAYFeeChanged", logs: logs, sub: sub}, nil
}

// WatchKLAYFeeChanged is a free log subscription operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchKLAYFeeChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20KLAYFeeChanged, fee []*big.Int) (event.Subscription, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20KLAYFeeChanged)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKLAYFeeChanged is a log parse operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseKLAYFeeChanged(log types.Log) (*BridgeTransferERC20KLAYFeeChanged, error) {
	event := new(BridgeTransferERC20KLAYFeeChanged)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20OwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20OwnershipTransferredIterator struct {
	Event *BridgeTransferERC20OwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20OwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20OwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20OwnershipTransferred represents a OwnershipTransferred event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20OwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BridgeTransferERC20OwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20OwnershipTransferredIterator{contract: _BridgeTransferERC20.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20OwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20OwnershipTransferred)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseOwnershipTransferred(log types.Log) (*BridgeTransferERC20OwnershipTransferred, error) {
	event := new(BridgeTransferERC20OwnershipTransferred)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20RequestValueTransferIterator is returned from FilterRequestValueTransfer and is used to iterate over the raw logs and unpacked data for RequestValueTransfer events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20RequestValueTransferIterator struct {
	Event *BridgeTransferERC20RequestValueTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20RequestValueTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20RequestValueTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20RequestValueTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20RequestValueTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20RequestValueTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20RequestValueTransfer represents a RequestValueTransfer event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20RequestValueTransfer struct {
	TokenType      uint8
	From           common.Address
	To             common.Address
	TokenAddress   common.Address
	ValueOrTokenId *big.Int
	RequestNonce   uint64
	Fee            *big.Int
	ExtraData      []byte
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterRequestValueTransfer is a free log retrieval operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterRequestValueTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferERC20RequestValueTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "RequestValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20RequestValueTransferIterator{contract: _BridgeTransferERC20.contract, event: "RequestValueTransfer", logs: logs, sub: sub}, nil
}

// WatchRequestValueTransfer is a free log subscription operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchRequestValueTransfer(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20RequestValueTransfer, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "RequestValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20RequestValueTransfer)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "RequestValueTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestValueTransfer is a log parse operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseRequestValueTransfer(log types.Log) (*BridgeTransferERC20RequestValueTransfer, error) {
	event := new(BridgeTransferERC20RequestValueTransfer)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "RequestValueTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20RequestValueTransferEncodedIterator is returned from FilterRequestValueTransferEncoded and is used to iterate over the raw logs and unpacked data for RequestValueTransferEncoded events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20RequestValueTransferEncodedIterator struct {
	Event *BridgeTransferERC20RequestValueTransferEncoded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20RequestValueTransferEncodedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20RequestValueTransferEncoded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20RequestValueTransferEncoded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20RequestValueTransferEncodedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20RequestValueTransferEncodedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20RequestValueTransferEncoded represents a RequestValueTransferEncoded event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20RequestValueTransferEncoded struct {
	TokenType      uint8
	From           common.Address
	To             common.Address
	TokenAddress   common.Address
	ValueOrTokenId *big.Int
	RequestNonce   uint64
	Fee            *big.Int
	ExtraData      []byte
	EncodingVer    uint8
	EncodedData    []byte
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterRequestValueTransferEncoded is a free log retrieval operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterRequestValueTransferEncoded(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferERC20RequestValueTransferEncodedIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "RequestValueTransferEncoded", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20RequestValueTransferEncodedIterator{contract: _BridgeTransferERC20.contract, event: "RequestValueTransferEncoded", logs: logs, sub: sub}, nil
}

// WatchRequestValueTransferEncoded is a free log subscription operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchRequestValueTransferEncoded(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20RequestValueTransferEncoded, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "RequestValueTransferEncoded", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20RequestValueTransferEncoded)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "RequestValueTransferEncoded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestValueTransferEncoded is a log parse operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseRequestValueTransferEncoded(log types.Log) (*BridgeTransferERC20RequestValueTransferEncoded, error) {
	event := new(BridgeTransferERC20RequestValueTransferEncoded)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "RequestValueTransferEncoded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20TokenDeregisteredIterator is returned from FilterTokenDeregistered and is used to iterate over the raw logs and unpacked data for TokenDeregistered events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20TokenDeregisteredIterator struct {
	Event *BridgeTransferERC20TokenDeregistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20TokenDeregisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20TokenDeregistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20TokenDeregistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20TokenDeregisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20TokenDeregisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20TokenDeregistered represents a TokenDeregistered event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20TokenDeregistered struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenDeregistered is a free log retrieval operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterTokenDeregistered(opts *bind.FilterOpts, token []common.Address) (*BridgeTransferERC20TokenDeregisteredIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "TokenDeregistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20TokenDeregisteredIterator{contract: _BridgeTransferERC20.contract, event: "TokenDeregistered", logs: logs, sub: sub}, nil
}

// WatchTokenDeregistered is a free log subscription operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchTokenDeregistered(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20TokenDeregistered, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "TokenDeregistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20TokenDeregistered)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "TokenDeregistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenDeregistered is a log parse operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseTokenDeregistered(log types.Log) (*BridgeTransferERC20TokenDeregistered, error) {
	event := new(BridgeTransferERC20TokenDeregistered)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "TokenDeregistered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20TokenLockedIterator is returned from FilterTokenLocked and is used to iterate over the raw logs and unpacked data for TokenLocked events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20TokenLockedIterator struct {
	Event *BridgeTransferERC20TokenLocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20TokenLockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20TokenLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20TokenLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20TokenLockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20TokenLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20TokenLocked represents a TokenLocked event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20TokenLocked struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenLocked is a free log retrieval operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterTokenLocked(opts *bind.FilterOpts, token []common.Address) (*BridgeTransferERC20TokenLockedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "TokenLocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20TokenLockedIterator{contract: _BridgeTransferERC20.contract, event: "TokenLocked", logs: logs, sub: sub}, nil
}

// WatchTokenLocked is a free log subscription operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchTokenLocked(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20TokenLocked, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "TokenLocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20TokenLocked)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "TokenLocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenLocked is a log parse operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseTokenLocked(log types.Log) (*BridgeTransferERC20TokenLocked, error) {
	event := new(BridgeTransferERC20TokenLocked)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "TokenLocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20TokenRegisteredIterator is returned from FilterTokenRegistered and is used to iterate over the raw logs and unpacked data for TokenRegistered events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20TokenRegisteredIterator struct {
	Event *BridgeTransferERC20TokenRegistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20TokenRegisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20TokenRegistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20TokenRegistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20TokenRegisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20TokenRegisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20TokenRegistered represents a TokenRegistered event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20TokenRegistered struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenRegistered is a free log retrieval operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterTokenRegistered(opts *bind.FilterOpts, token []common.Address) (*BridgeTransferERC20TokenRegisteredIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "TokenRegistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20TokenRegisteredIterator{contract: _BridgeTransferERC20.contract, event: "TokenRegistered", logs: logs, sub: sub}, nil
}

// WatchTokenRegistered is a free log subscription operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchTokenRegistered(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20TokenRegistered, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "TokenRegistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20TokenRegistered)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "TokenRegistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenRegistered is a log parse operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseTokenRegistered(log types.Log) (*BridgeTransferERC20TokenRegistered, error) {
	event := new(BridgeTransferERC20TokenRegistered)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "TokenRegistered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC20TokenUnlockedIterator is returned from FilterTokenUnlocked and is used to iterate over the raw logs and unpacked data for TokenUnlocked events raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20TokenUnlockedIterator struct {
	Event *BridgeTransferERC20TokenUnlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC20TokenUnlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC20TokenUnlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC20TokenUnlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC20TokenUnlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC20TokenUnlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC20TokenUnlocked represents a TokenUnlocked event raised by the BridgeTransferERC20 contract.
type BridgeTransferERC20TokenUnlocked struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenUnlocked is a free log retrieval operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) FilterTokenUnlocked(opts *bind.FilterOpts, token []common.Address) (*BridgeTransferERC20TokenUnlockedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.FilterLogs(opts, "TokenUnlocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC20TokenUnlockedIterator{contract: _BridgeTransferERC20.contract, event: "TokenUnlocked", logs: logs, sub: sub}, nil
}

// WatchTokenUnlocked is a free log subscription operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) WatchTokenUnlocked(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC20TokenUnlocked, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC20.contract.WatchLogs(opts, "TokenUnlocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC20TokenUnlocked)
				if err := _BridgeTransferERC20.contract.UnpackLog(event, "TokenUnlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenUnlocked is a log parse operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTransferERC20 *BridgeTransferERC20Filterer) ParseTokenUnlocked(log types.Log) (*BridgeTransferERC20TokenUnlocked, error) {
	event := new(BridgeTransferERC20TokenUnlocked)
	if err := _BridgeTransferERC20.contract.UnpackLog(event, "TokenUnlocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721ABI is the input ABI used to generate the binding from.
const BridgeTransferERC721ABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ERC20FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"FeeReceiverChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"handleNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lowerHandleNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"HandleValueTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"KLAYFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"requestNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"RequestValueTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"requestNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"encodingVer\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encodedData\",\"type\":\"bytes\"}],\"name\":\"RequestValueTransferEncoded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_OPERATOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"closedValueTransferVotes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"deregisterOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"deregisterToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeOfERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOfKLAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"addresspayable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_requestedNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_requestedBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"handleERC721Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"handleNoncesToBlockNums\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"handledRequestTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexOfTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerHandleNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modeMintBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"operatorThresholds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryBlockNumber\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"registerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredTokenList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"requestERC721Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enumBridgeOperator.VoteType\",\"name\":\"_voteType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"}],\"name\":\"setOperatorThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"unlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperHandleNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// BridgeTransferERC721BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const BridgeTransferERC721BinRuntime = ``

// BridgeTransferERC721FuncSigs maps the 4-byte function signature to its string representation.
var BridgeTransferERC721FuncSigs = map[string]string{
	"3a3099d1": "MAX_OPERATOR()",
	"9832c1d7": "closedValueTransferVotes(uint64)",
	"ac6fff0b": "configurationNonce()",
	"d8cf98ca": "deregisterOperator(address)",
	"bab2af1d": "deregisterToken(address)",
	"488af871": "feeOfERC20(address)",
	"c263b5d6": "feeOfKLAY()",
	"b3f00674": "feeReceiver()",
	"b2c01030": "getOperatorList()",
	"ea21eade": "getRegisteredTokenList()",
	"afb60223": "handleERC721Transfer(bytes32,address,address,address,uint256,uint64,uint64,string,bytes)",
	"13a6738a": "handleNoncesToBlockNums(uint64)",
	"8a75eee2": "handledRequestTx(bytes32)",
	"48a18a6a": "indexOfTokens(address)",
	"2014e5d1": "isRunning()",
	"10693fcd": "lockToken(address)",
	"5eb7413a": "lockedTokens(address)",
	"4b40b826": "lowerHandleNonce()",
	"6e176ec2": "modeMintBurn()",
	"cf0da290": "onERC721Received(address,uint256,address,bytes)",
	"cb38f407": "operatorList(uint256)",
	"5526f76b": "operatorThresholds(uint8)",
	"13e7c9d8": "operators(address)",
	"8da5cb5b": "owner()",
	"989ba0d3": "recoveryBlockNumber()",
	"3682a450": "registerOperator(address)",
	"4739f7e5": "registerToken(address,address)",
	"3e4fe949": "registeredTokenList(uint256)",
	"8c0bd916": "registeredTokens(address)",
	"715018a6": "renounceOwnership()",
	"22604742": "requestERC721Transfer(address,address,uint256,bytes)",
	"7c1a0302": "requestNonce()",
	"efdcd974": "setFeeReceiver(address)",
	"ee2aec65": "setOperatorThreshold(uint8,uint8)",
	"c877cf37": "start(bool)",
	"f2fde38b": "transferOwnership(address)",
	"9ef2017b": "unlockToken(address)",
	"54edad72": "upperHandleNonce()",
}

// BridgeTransferERC721 is an auto generated Go binding around a Klaytn contract.
type BridgeTransferERC721 struct {
	BridgeTransferERC721Caller     // Read-only binding to the contract
	BridgeTransferERC721Transactor // Write-only binding to the contract
	BridgeTransferERC721Filterer   // Log filterer for contract events
}

// BridgeTransferERC721Caller is an auto generated read-only Go binding around a Klaytn contract.
type BridgeTransferERC721Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferERC721Transactor is an auto generated write-only Go binding around a Klaytn contract.
type BridgeTransferERC721Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferERC721Filterer is an auto generated log filtering Go binding around a Klaytn contract events.
type BridgeTransferERC721Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransferERC721Session is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type BridgeTransferERC721Session struct {
	Contract     *BridgeTransferERC721 // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// BridgeTransferERC721CallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type BridgeTransferERC721CallerSession struct {
	Contract *BridgeTransferERC721Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// BridgeTransferERC721TransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type BridgeTransferERC721TransactorSession struct {
	Contract     *BridgeTransferERC721Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// BridgeTransferERC721Raw is an auto generated low-level Go binding around a Klaytn contract.
type BridgeTransferERC721Raw struct {
	Contract *BridgeTransferERC721 // Generic contract binding to access the raw methods on
}

// BridgeTransferERC721CallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type BridgeTransferERC721CallerRaw struct {
	Contract *BridgeTransferERC721Caller // Generic read-only contract binding to access the raw methods on
}

// BridgeTransferERC721TransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type BridgeTransferERC721TransactorRaw struct {
	Contract *BridgeTransferERC721Transactor // Generic write-only contract binding to access the raw methods on
}

// NewBridgeTransferERC721 creates a new instance of BridgeTransferERC721, bound to a specific deployed contract.
func NewBridgeTransferERC721(address common.Address, backend bind.ContractBackend) (*BridgeTransferERC721, error) {
	contract, err := bindBridgeTransferERC721(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721{BridgeTransferERC721Caller: BridgeTransferERC721Caller{contract: contract}, BridgeTransferERC721Transactor: BridgeTransferERC721Transactor{contract: contract}, BridgeTransferERC721Filterer: BridgeTransferERC721Filterer{contract: contract}}, nil
}

// NewBridgeTransferERC721Caller creates a new read-only instance of BridgeTransferERC721, bound to a specific deployed contract.
func NewBridgeTransferERC721Caller(address common.Address, caller bind.ContractCaller) (*BridgeTransferERC721Caller, error) {
	contract, err := bindBridgeTransferERC721(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721Caller{contract: contract}, nil
}

// NewBridgeTransferERC721Transactor creates a new write-only instance of BridgeTransferERC721, bound to a specific deployed contract.
func NewBridgeTransferERC721Transactor(address common.Address, transactor bind.ContractTransactor) (*BridgeTransferERC721Transactor, error) {
	contract, err := bindBridgeTransferERC721(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721Transactor{contract: contract}, nil
}

// NewBridgeTransferERC721Filterer creates a new log filterer instance of BridgeTransferERC721, bound to a specific deployed contract.
func NewBridgeTransferERC721Filterer(address common.Address, filterer bind.ContractFilterer) (*BridgeTransferERC721Filterer, error) {
	contract, err := bindBridgeTransferERC721(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721Filterer{contract: contract}, nil
}

// bindBridgeTransferERC721 binds a generic wrapper to an already deployed contract.
func bindBridgeTransferERC721(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BridgeTransferERC721ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeTransferERC721 *BridgeTransferERC721Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeTransferERC721.Contract.BridgeTransferERC721Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeTransferERC721 *BridgeTransferERC721Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.BridgeTransferERC721Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeTransferERC721 *BridgeTransferERC721Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.BridgeTransferERC721Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BridgeTransferERC721 *BridgeTransferERC721CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BridgeTransferERC721.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.contract.Transact(opts, method, params...)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) MAXOPERATOR(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "MAX_OPERATOR")
	return *ret0, err
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) MAXOPERATOR() (uint64, error) {
	return _BridgeTransferERC721.Contract.MAXOPERATOR(&_BridgeTransferERC721.CallOpts)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) MAXOPERATOR() (uint64, error) {
	return _BridgeTransferERC721.Contract.MAXOPERATOR(&_BridgeTransferERC721.CallOpts)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) ClosedValueTransferVotes(opts *bind.CallOpts, arg0 uint64) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "closedValueTransferVotes", arg0)
	return *ret0, err
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _BridgeTransferERC721.Contract.ClosedValueTransferVotes(&_BridgeTransferERC721.CallOpts, arg0)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _BridgeTransferERC721.Contract.ClosedValueTransferVotes(&_BridgeTransferERC721.CallOpts, arg0)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) ConfigurationNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "configurationNonce")
	return *ret0, err
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) ConfigurationNonce() (uint64, error) {
	return _BridgeTransferERC721.Contract.ConfigurationNonce(&_BridgeTransferERC721.CallOpts)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) ConfigurationNonce() (uint64, error) {
	return _BridgeTransferERC721.Contract.ConfigurationNonce(&_BridgeTransferERC721.CallOpts)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) FeeOfERC20(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "feeOfERC20", arg0)
	return *ret0, err
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransferERC721.Contract.FeeOfERC20(&_BridgeTransferERC721.CallOpts, arg0)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransferERC721.Contract.FeeOfERC20(&_BridgeTransferERC721.CallOpts, arg0)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) FeeOfKLAY(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "feeOfKLAY")
	return *ret0, err
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) FeeOfKLAY() (*big.Int, error) {
	return _BridgeTransferERC721.Contract.FeeOfKLAY(&_BridgeTransferERC721.CallOpts)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) FeeOfKLAY() (*big.Int, error) {
	return _BridgeTransferERC721.Contract.FeeOfKLAY(&_BridgeTransferERC721.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) FeeReceiver(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "feeReceiver")
	return *ret0, err
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) FeeReceiver() (common.Address, error) {
	return _BridgeTransferERC721.Contract.FeeReceiver(&_BridgeTransferERC721.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) FeeReceiver() (common.Address, error) {
	return _BridgeTransferERC721.Contract.FeeReceiver(&_BridgeTransferERC721.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) GetOperatorList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "getOperatorList")
	return *ret0, err
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransferERC721 *BridgeTransferERC721Session) GetOperatorList() ([]common.Address, error) {
	return _BridgeTransferERC721.Contract.GetOperatorList(&_BridgeTransferERC721.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) GetOperatorList() ([]common.Address, error) {
	return _BridgeTransferERC721.Contract.GetOperatorList(&_BridgeTransferERC721.CallOpts)
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) GetRegisteredTokenList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "getRegisteredTokenList")
	return *ret0, err
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTransferERC721 *BridgeTransferERC721Session) GetRegisteredTokenList() ([]common.Address, error) {
	return _BridgeTransferERC721.Contract.GetRegisteredTokenList(&_BridgeTransferERC721.CallOpts)
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) GetRegisteredTokenList() ([]common.Address, error) {
	return _BridgeTransferERC721.Contract.GetRegisteredTokenList(&_BridgeTransferERC721.CallOpts)
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) HandleNoncesToBlockNums(opts *bind.CallOpts, arg0 uint64) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "handleNoncesToBlockNums", arg0)
	return *ret0, err
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) HandleNoncesToBlockNums(arg0 uint64) (uint64, error) {
	return _BridgeTransferERC721.Contract.HandleNoncesToBlockNums(&_BridgeTransferERC721.CallOpts, arg0)
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) HandleNoncesToBlockNums(arg0 uint64) (uint64, error) {
	return _BridgeTransferERC721.Contract.HandleNoncesToBlockNums(&_BridgeTransferERC721.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) HandledRequestTx(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "handledRequestTx", arg0)
	return *ret0, err
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _BridgeTransferERC721.Contract.HandledRequestTx(&_BridgeTransferERC721.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _BridgeTransferERC721.Contract.HandledRequestTx(&_BridgeTransferERC721.CallOpts, arg0)
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) IndexOfTokens(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "indexOfTokens", arg0)
	return *ret0, err
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) IndexOfTokens(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransferERC721.Contract.IndexOfTokens(&_BridgeTransferERC721.CallOpts, arg0)
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) IndexOfTokens(arg0 common.Address) (*big.Int, error) {
	return _BridgeTransferERC721.Contract.IndexOfTokens(&_BridgeTransferERC721.CallOpts, arg0)
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) IsRunning(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "isRunning")
	return *ret0, err
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) IsRunning() (bool, error) {
	return _BridgeTransferERC721.Contract.IsRunning(&_BridgeTransferERC721.CallOpts)
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) IsRunning() (bool, error) {
	return _BridgeTransferERC721.Contract.IsRunning(&_BridgeTransferERC721.CallOpts)
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) LockedTokens(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "lockedTokens", arg0)
	return *ret0, err
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) LockedTokens(arg0 common.Address) (bool, error) {
	return _BridgeTransferERC721.Contract.LockedTokens(&_BridgeTransferERC721.CallOpts, arg0)
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) LockedTokens(arg0 common.Address) (bool, error) {
	return _BridgeTransferERC721.Contract.LockedTokens(&_BridgeTransferERC721.CallOpts, arg0)
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) LowerHandleNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "lowerHandleNonce")
	return *ret0, err
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) LowerHandleNonce() (uint64, error) {
	return _BridgeTransferERC721.Contract.LowerHandleNonce(&_BridgeTransferERC721.CallOpts)
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) LowerHandleNonce() (uint64, error) {
	return _BridgeTransferERC721.Contract.LowerHandleNonce(&_BridgeTransferERC721.CallOpts)
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) ModeMintBurn(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "modeMintBurn")
	return *ret0, err
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) ModeMintBurn() (bool, error) {
	return _BridgeTransferERC721.Contract.ModeMintBurn(&_BridgeTransferERC721.CallOpts)
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) ModeMintBurn() (bool, error) {
	return _BridgeTransferERC721.Contract.ModeMintBurn(&_BridgeTransferERC721.CallOpts)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) OperatorList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "operatorList", arg0)
	return *ret0, err
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransferERC721.Contract.OperatorList(&_BridgeTransferERC721.CallOpts, arg0)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransferERC721.Contract.OperatorList(&_BridgeTransferERC721.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) OperatorThresholds(opts *bind.CallOpts, arg0 uint8) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "operatorThresholds", arg0)
	return *ret0, err
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _BridgeTransferERC721.Contract.OperatorThresholds(&_BridgeTransferERC721.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _BridgeTransferERC721.Contract.OperatorThresholds(&_BridgeTransferERC721.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) Operators(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "operators", arg0)
	return *ret0, err
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) Operators(arg0 common.Address) (bool, error) {
	return _BridgeTransferERC721.Contract.Operators(&_BridgeTransferERC721.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) Operators(arg0 common.Address) (bool, error) {
	return _BridgeTransferERC721.Contract.Operators(&_BridgeTransferERC721.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) Owner() (common.Address, error) {
	return _BridgeTransferERC721.Contract.Owner(&_BridgeTransferERC721.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) Owner() (common.Address, error) {
	return _BridgeTransferERC721.Contract.Owner(&_BridgeTransferERC721.CallOpts)
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) RecoveryBlockNumber(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "recoveryBlockNumber")
	return *ret0, err
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) RecoveryBlockNumber() (uint64, error) {
	return _BridgeTransferERC721.Contract.RecoveryBlockNumber(&_BridgeTransferERC721.CallOpts)
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) RecoveryBlockNumber() (uint64, error) {
	return _BridgeTransferERC721.Contract.RecoveryBlockNumber(&_BridgeTransferERC721.CallOpts)
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) RegisteredTokenList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "registeredTokenList", arg0)
	return *ret0, err
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) RegisteredTokenList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransferERC721.Contract.RegisteredTokenList(&_BridgeTransferERC721.CallOpts, arg0)
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) RegisteredTokenList(arg0 *big.Int) (common.Address, error) {
	return _BridgeTransferERC721.Contract.RegisteredTokenList(&_BridgeTransferERC721.CallOpts, arg0)
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) RegisteredTokens(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "registeredTokens", arg0)
	return *ret0, err
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) RegisteredTokens(arg0 common.Address) (common.Address, error) {
	return _BridgeTransferERC721.Contract.RegisteredTokens(&_BridgeTransferERC721.CallOpts, arg0)
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) RegisteredTokens(arg0 common.Address) (common.Address, error) {
	return _BridgeTransferERC721.Contract.RegisteredTokens(&_BridgeTransferERC721.CallOpts, arg0)
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) RequestNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "requestNonce")
	return *ret0, err
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) RequestNonce() (uint64, error) {
	return _BridgeTransferERC721.Contract.RequestNonce(&_BridgeTransferERC721.CallOpts)
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) RequestNonce() (uint64, error) {
	return _BridgeTransferERC721.Contract.RequestNonce(&_BridgeTransferERC721.CallOpts)
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Caller) UpperHandleNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _BridgeTransferERC721.contract.Call(opts, out, "upperHandleNonce")
	return *ret0, err
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721Session) UpperHandleNonce() (uint64, error) {
	return _BridgeTransferERC721.Contract.UpperHandleNonce(&_BridgeTransferERC721.CallOpts)
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_BridgeTransferERC721 *BridgeTransferERC721CallerSession) UpperHandleNonce() (uint64, error) {
	return _BridgeTransferERC721.Contract.UpperHandleNonce(&_BridgeTransferERC721.CallOpts)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) DeregisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "deregisterOperator", _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.DeregisterOperator(&_BridgeTransferERC721.TransactOpts, _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.DeregisterOperator(&_BridgeTransferERC721.TransactOpts, _operator)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) DeregisterToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "deregisterToken", _token)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) DeregisterToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.DeregisterToken(&_BridgeTransferERC721.TransactOpts, _token)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) DeregisterToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.DeregisterToken(&_BridgeTransferERC721.TransactOpts, _token)
}

// HandleERC721Transfer is a paid mutator transaction binding the contract method 0xafb60223.
//
// Solidity: function handleERC721Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _tokenId, uint64 _requestedNonce, uint64 _requestedBlockNumber, string _tokenURI, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) HandleERC721Transfer(opts *bind.TransactOpts, _requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _tokenId *big.Int, _requestedNonce uint64, _requestedBlockNumber uint64, _tokenURI string, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "handleERC721Transfer", _requestTxHash, _from, _to, _tokenAddress, _tokenId, _requestedNonce, _requestedBlockNumber, _tokenURI, _extraData)
}

// HandleERC721Transfer is a paid mutator transaction binding the contract method 0xafb60223.
//
// Solidity: function handleERC721Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _tokenId, uint64 _requestedNonce, uint64 _requestedBlockNumber, string _tokenURI, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) HandleERC721Transfer(_requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _tokenId *big.Int, _requestedNonce uint64, _requestedBlockNumber uint64, _tokenURI string, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.HandleERC721Transfer(&_BridgeTransferERC721.TransactOpts, _requestTxHash, _from, _to, _tokenAddress, _tokenId, _requestedNonce, _requestedBlockNumber, _tokenURI, _extraData)
}

// HandleERC721Transfer is a paid mutator transaction binding the contract method 0xafb60223.
//
// Solidity: function handleERC721Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _tokenId, uint64 _requestedNonce, uint64 _requestedBlockNumber, string _tokenURI, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) HandleERC721Transfer(_requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _tokenId *big.Int, _requestedNonce uint64, _requestedBlockNumber uint64, _tokenURI string, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.HandleERC721Transfer(&_BridgeTransferERC721.TransactOpts, _requestTxHash, _from, _to, _tokenAddress, _tokenId, _requestedNonce, _requestedBlockNumber, _tokenURI, _extraData)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) LockToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "lockToken", _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) LockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.LockToken(&_BridgeTransferERC721.TransactOpts, _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) LockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.LockToken(&_BridgeTransferERC721.TransactOpts, _token)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) OnERC721Received(opts *bind.TransactOpts, _from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "onERC721Received", _from, _tokenId, _to, _extraData)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) OnERC721Received(_from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.OnERC721Received(&_BridgeTransferERC721.TransactOpts, _from, _tokenId, _to, _extraData)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) OnERC721Received(_from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.OnERC721Received(&_BridgeTransferERC721.TransactOpts, _from, _tokenId, _to, _extraData)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) RegisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "registerOperator", _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.RegisterOperator(&_BridgeTransferERC721.TransactOpts, _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.RegisterOperator(&_BridgeTransferERC721.TransactOpts, _operator)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) RegisterToken(opts *bind.TransactOpts, _token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "registerToken", _token, _cToken)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) RegisterToken(_token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.RegisterToken(&_BridgeTransferERC721.TransactOpts, _token, _cToken)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) RegisterToken(_token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.RegisterToken(&_BridgeTransferERC721.TransactOpts, _token, _cToken)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.RenounceOwnership(&_BridgeTransferERC721.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.RenounceOwnership(&_BridgeTransferERC721.TransactOpts)
}

// RequestERC721Transfer is a paid mutator transaction binding the contract method 0x22604742.
//
// Solidity: function requestERC721Transfer(address _tokenAddress, address _to, uint256 _tokenId, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) RequestERC721Transfer(opts *bind.TransactOpts, _tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "requestERC721Transfer", _tokenAddress, _to, _tokenId, _extraData)
}

// RequestERC721Transfer is a paid mutator transaction binding the contract method 0x22604742.
//
// Solidity: function requestERC721Transfer(address _tokenAddress, address _to, uint256 _tokenId, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) RequestERC721Transfer(_tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.RequestERC721Transfer(&_BridgeTransferERC721.TransactOpts, _tokenAddress, _to, _tokenId, _extraData)
}

// RequestERC721Transfer is a paid mutator transaction binding the contract method 0x22604742.
//
// Solidity: function requestERC721Transfer(address _tokenAddress, address _to, uint256 _tokenId, bytes _extraData) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) RequestERC721Transfer(_tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.RequestERC721Transfer(&_BridgeTransferERC721.TransactOpts, _tokenAddress, _to, _tokenId, _extraData)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) SetFeeReceiver(opts *bind.TransactOpts, _feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "setFeeReceiver", _feeReceiver)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) SetFeeReceiver(_feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.SetFeeReceiver(&_BridgeTransferERC721.TransactOpts, _feeReceiver)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) SetFeeReceiver(_feeReceiver common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.SetFeeReceiver(&_BridgeTransferERC721.TransactOpts, _feeReceiver)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) SetOperatorThreshold(opts *bind.TransactOpts, _voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "setOperatorThreshold", _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.SetOperatorThreshold(&_BridgeTransferERC721.TransactOpts, _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.SetOperatorThreshold(&_BridgeTransferERC721.TransactOpts, _voteType, _threshold)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) Start(opts *bind.TransactOpts, _status bool) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "start", _status)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) Start(_status bool) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.Start(&_BridgeTransferERC721.TransactOpts, _status)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) Start(_status bool) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.Start(&_BridgeTransferERC721.TransactOpts, _status)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.TransferOwnership(&_BridgeTransferERC721.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.TransferOwnership(&_BridgeTransferERC721.TransactOpts, newOwner)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Transactor) UnlockToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.contract.Transact(opts, "unlockToken", _token)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721Session) UnlockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.UnlockToken(&_BridgeTransferERC721.TransactOpts, _token)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_BridgeTransferERC721 *BridgeTransferERC721TransactorSession) UnlockToken(_token common.Address) (*types.Transaction, error) {
	return _BridgeTransferERC721.Contract.UnlockToken(&_BridgeTransferERC721.TransactOpts, _token)
}

// BridgeTransferERC721ERC20FeeChangedIterator is returned from FilterERC20FeeChanged and is used to iterate over the raw logs and unpacked data for ERC20FeeChanged events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721ERC20FeeChangedIterator struct {
	Event *BridgeTransferERC721ERC20FeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721ERC20FeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721ERC20FeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721ERC20FeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721ERC20FeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721ERC20FeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721ERC20FeeChanged represents a ERC20FeeChanged event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721ERC20FeeChanged struct {
	Token common.Address
	Fee   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterERC20FeeChanged is a free log retrieval operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterERC20FeeChanged(opts *bind.FilterOpts, token []common.Address, fee []*big.Int) (*BridgeTransferERC721ERC20FeeChangedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721ERC20FeeChangedIterator{contract: _BridgeTransferERC721.contract, event: "ERC20FeeChanged", logs: logs, sub: sub}, nil
}

// WatchERC20FeeChanged is a free log subscription operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchERC20FeeChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721ERC20FeeChanged, token []common.Address, fee []*big.Int) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721ERC20FeeChanged)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20FeeChanged is a log parse operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseERC20FeeChanged(log types.Log) (*BridgeTransferERC721ERC20FeeChanged, error) {
	event := new(BridgeTransferERC721ERC20FeeChanged)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721FeeReceiverChangedIterator is returned from FilterFeeReceiverChanged and is used to iterate over the raw logs and unpacked data for FeeReceiverChanged events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721FeeReceiverChangedIterator struct {
	Event *BridgeTransferERC721FeeReceiverChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721FeeReceiverChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721FeeReceiverChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721FeeReceiverChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721FeeReceiverChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721FeeReceiverChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721FeeReceiverChanged represents a FeeReceiverChanged event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721FeeReceiverChanged struct {
	FeeReceiver common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterFeeReceiverChanged is a free log retrieval operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterFeeReceiverChanged(opts *bind.FilterOpts, feeReceiver []common.Address) (*BridgeTransferERC721FeeReceiverChangedIterator, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721FeeReceiverChangedIterator{contract: _BridgeTransferERC721.contract, event: "FeeReceiverChanged", logs: logs, sub: sub}, nil
}

// WatchFeeReceiverChanged is a free log subscription operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchFeeReceiverChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721FeeReceiverChanged, feeReceiver []common.Address) (event.Subscription, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721FeeReceiverChanged)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeReceiverChanged is a log parse operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseFeeReceiverChanged(log types.Log) (*BridgeTransferERC721FeeReceiverChanged, error) {
	event := new(BridgeTransferERC721FeeReceiverChanged)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721HandleValueTransferIterator is returned from FilterHandleValueTransfer and is used to iterate over the raw logs and unpacked data for HandleValueTransfer events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721HandleValueTransferIterator struct {
	Event *BridgeTransferERC721HandleValueTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721HandleValueTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721HandleValueTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721HandleValueTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721HandleValueTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721HandleValueTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721HandleValueTransfer represents a HandleValueTransfer event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721HandleValueTransfer struct {
	RequestTxHash    [32]byte
	TokenType        uint8
	From             common.Address
	To               common.Address
	TokenAddress     common.Address
	ValueOrTokenId   *big.Int
	HandleNonce      uint64
	LowerHandleNonce uint64
	ExtraData        []byte
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterHandleValueTransfer is a free log retrieval operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterHandleValueTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferERC721HandleValueTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "HandleValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721HandleValueTransferIterator{contract: _BridgeTransferERC721.contract, event: "HandleValueTransfer", logs: logs, sub: sub}, nil
}

// WatchHandleValueTransfer is a free log subscription operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchHandleValueTransfer(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721HandleValueTransfer, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "HandleValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721HandleValueTransfer)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "HandleValueTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseHandleValueTransfer is a log parse operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseHandleValueTransfer(log types.Log) (*BridgeTransferERC721HandleValueTransfer, error) {
	event := new(BridgeTransferERC721HandleValueTransfer)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "HandleValueTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721KLAYFeeChangedIterator is returned from FilterKLAYFeeChanged and is used to iterate over the raw logs and unpacked data for KLAYFeeChanged events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721KLAYFeeChangedIterator struct {
	Event *BridgeTransferERC721KLAYFeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721KLAYFeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721KLAYFeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721KLAYFeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721KLAYFeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721KLAYFeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721KLAYFeeChanged represents a KLAYFeeChanged event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721KLAYFeeChanged struct {
	Fee *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterKLAYFeeChanged is a free log retrieval operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterKLAYFeeChanged(opts *bind.FilterOpts, fee []*big.Int) (*BridgeTransferERC721KLAYFeeChangedIterator, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721KLAYFeeChangedIterator{contract: _BridgeTransferERC721.contract, event: "KLAYFeeChanged", logs: logs, sub: sub}, nil
}

// WatchKLAYFeeChanged is a free log subscription operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchKLAYFeeChanged(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721KLAYFeeChanged, fee []*big.Int) (event.Subscription, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721KLAYFeeChanged)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKLAYFeeChanged is a log parse operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseKLAYFeeChanged(log types.Log) (*BridgeTransferERC721KLAYFeeChanged, error) {
	event := new(BridgeTransferERC721KLAYFeeChanged)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721OwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721OwnershipTransferredIterator struct {
	Event *BridgeTransferERC721OwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721OwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721OwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721OwnershipTransferred represents a OwnershipTransferred event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721OwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BridgeTransferERC721OwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721OwnershipTransferredIterator{contract: _BridgeTransferERC721.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721OwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721OwnershipTransferred)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseOwnershipTransferred(log types.Log) (*BridgeTransferERC721OwnershipTransferred, error) {
	event := new(BridgeTransferERC721OwnershipTransferred)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721RequestValueTransferIterator is returned from FilterRequestValueTransfer and is used to iterate over the raw logs and unpacked data for RequestValueTransfer events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721RequestValueTransferIterator struct {
	Event *BridgeTransferERC721RequestValueTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721RequestValueTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721RequestValueTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721RequestValueTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721RequestValueTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721RequestValueTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721RequestValueTransfer represents a RequestValueTransfer event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721RequestValueTransfer struct {
	TokenType      uint8
	From           common.Address
	To             common.Address
	TokenAddress   common.Address
	ValueOrTokenId *big.Int
	RequestNonce   uint64
	Fee            *big.Int
	ExtraData      []byte
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterRequestValueTransfer is a free log retrieval operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterRequestValueTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferERC721RequestValueTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "RequestValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721RequestValueTransferIterator{contract: _BridgeTransferERC721.contract, event: "RequestValueTransfer", logs: logs, sub: sub}, nil
}

// WatchRequestValueTransfer is a free log subscription operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchRequestValueTransfer(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721RequestValueTransfer, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "RequestValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721RequestValueTransfer)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "RequestValueTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestValueTransfer is a log parse operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseRequestValueTransfer(log types.Log) (*BridgeTransferERC721RequestValueTransfer, error) {
	event := new(BridgeTransferERC721RequestValueTransfer)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "RequestValueTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721RequestValueTransferEncodedIterator is returned from FilterRequestValueTransferEncoded and is used to iterate over the raw logs and unpacked data for RequestValueTransferEncoded events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721RequestValueTransferEncodedIterator struct {
	Event *BridgeTransferERC721RequestValueTransferEncoded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721RequestValueTransferEncodedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721RequestValueTransferEncoded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721RequestValueTransferEncoded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721RequestValueTransferEncodedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721RequestValueTransferEncodedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721RequestValueTransferEncoded represents a RequestValueTransferEncoded event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721RequestValueTransferEncoded struct {
	TokenType      uint8
	From           common.Address
	To             common.Address
	TokenAddress   common.Address
	ValueOrTokenId *big.Int
	RequestNonce   uint64
	Fee            *big.Int
	ExtraData      []byte
	EncodingVer    uint8
	EncodedData    []byte
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterRequestValueTransferEncoded is a free log retrieval operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterRequestValueTransferEncoded(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*BridgeTransferERC721RequestValueTransferEncodedIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "RequestValueTransferEncoded", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721RequestValueTransferEncodedIterator{contract: _BridgeTransferERC721.contract, event: "RequestValueTransferEncoded", logs: logs, sub: sub}, nil
}

// WatchRequestValueTransferEncoded is a free log subscription operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchRequestValueTransferEncoded(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721RequestValueTransferEncoded, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "RequestValueTransferEncoded", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721RequestValueTransferEncoded)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "RequestValueTransferEncoded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestValueTransferEncoded is a log parse operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseRequestValueTransferEncoded(log types.Log) (*BridgeTransferERC721RequestValueTransferEncoded, error) {
	event := new(BridgeTransferERC721RequestValueTransferEncoded)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "RequestValueTransferEncoded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721TokenDeregisteredIterator is returned from FilterTokenDeregistered and is used to iterate over the raw logs and unpacked data for TokenDeregistered events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721TokenDeregisteredIterator struct {
	Event *BridgeTransferERC721TokenDeregistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721TokenDeregisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721TokenDeregistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721TokenDeregistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721TokenDeregisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721TokenDeregisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721TokenDeregistered represents a TokenDeregistered event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721TokenDeregistered struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenDeregistered is a free log retrieval operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterTokenDeregistered(opts *bind.FilterOpts, token []common.Address) (*BridgeTransferERC721TokenDeregisteredIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "TokenDeregistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721TokenDeregisteredIterator{contract: _BridgeTransferERC721.contract, event: "TokenDeregistered", logs: logs, sub: sub}, nil
}

// WatchTokenDeregistered is a free log subscription operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchTokenDeregistered(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721TokenDeregistered, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "TokenDeregistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721TokenDeregistered)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "TokenDeregistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenDeregistered is a log parse operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseTokenDeregistered(log types.Log) (*BridgeTransferERC721TokenDeregistered, error) {
	event := new(BridgeTransferERC721TokenDeregistered)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "TokenDeregistered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721TokenLockedIterator is returned from FilterTokenLocked and is used to iterate over the raw logs and unpacked data for TokenLocked events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721TokenLockedIterator struct {
	Event *BridgeTransferERC721TokenLocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721TokenLockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721TokenLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721TokenLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721TokenLockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721TokenLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721TokenLocked represents a TokenLocked event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721TokenLocked struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenLocked is a free log retrieval operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterTokenLocked(opts *bind.FilterOpts, token []common.Address) (*BridgeTransferERC721TokenLockedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "TokenLocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721TokenLockedIterator{contract: _BridgeTransferERC721.contract, event: "TokenLocked", logs: logs, sub: sub}, nil
}

// WatchTokenLocked is a free log subscription operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchTokenLocked(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721TokenLocked, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "TokenLocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721TokenLocked)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "TokenLocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenLocked is a log parse operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseTokenLocked(log types.Log) (*BridgeTransferERC721TokenLocked, error) {
	event := new(BridgeTransferERC721TokenLocked)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "TokenLocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721TokenRegisteredIterator is returned from FilterTokenRegistered and is used to iterate over the raw logs and unpacked data for TokenRegistered events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721TokenRegisteredIterator struct {
	Event *BridgeTransferERC721TokenRegistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721TokenRegisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721TokenRegistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721TokenRegistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721TokenRegisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721TokenRegisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721TokenRegistered represents a TokenRegistered event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721TokenRegistered struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenRegistered is a free log retrieval operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterTokenRegistered(opts *bind.FilterOpts, token []common.Address) (*BridgeTransferERC721TokenRegisteredIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "TokenRegistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721TokenRegisteredIterator{contract: _BridgeTransferERC721.contract, event: "TokenRegistered", logs: logs, sub: sub}, nil
}

// WatchTokenRegistered is a free log subscription operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchTokenRegistered(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721TokenRegistered, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "TokenRegistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721TokenRegistered)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "TokenRegistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenRegistered is a log parse operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseTokenRegistered(log types.Log) (*BridgeTransferERC721TokenRegistered, error) {
	event := new(BridgeTransferERC721TokenRegistered)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "TokenRegistered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BridgeTransferERC721TokenUnlockedIterator is returned from FilterTokenUnlocked and is used to iterate over the raw logs and unpacked data for TokenUnlocked events raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721TokenUnlockedIterator struct {
	Event *BridgeTransferERC721TokenUnlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeTransferERC721TokenUnlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeTransferERC721TokenUnlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeTransferERC721TokenUnlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeTransferERC721TokenUnlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeTransferERC721TokenUnlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeTransferERC721TokenUnlocked represents a TokenUnlocked event raised by the BridgeTransferERC721 contract.
type BridgeTransferERC721TokenUnlocked struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenUnlocked is a free log retrieval operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) FilterTokenUnlocked(opts *bind.FilterOpts, token []common.Address) (*BridgeTransferERC721TokenUnlockedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.FilterLogs(opts, "TokenUnlocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return &BridgeTransferERC721TokenUnlockedIterator{contract: _BridgeTransferERC721.contract, event: "TokenUnlocked", logs: logs, sub: sub}, nil
}

// WatchTokenUnlocked is a free log subscription operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) WatchTokenUnlocked(opts *bind.WatchOpts, sink chan<- *BridgeTransferERC721TokenUnlocked, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _BridgeTransferERC721.contract.WatchLogs(opts, "TokenUnlocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeTransferERC721TokenUnlocked)
				if err := _BridgeTransferERC721.contract.UnpackLog(event, "TokenUnlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenUnlocked is a log parse operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_BridgeTransferERC721 *BridgeTransferERC721Filterer) ParseTokenUnlocked(log types.Log) (*BridgeTransferERC721TokenUnlocked, error) {
	event := new(BridgeTransferERC721TokenUnlocked)
	if err := _BridgeTransferERC721.contract.UnpackLog(event, "TokenUnlocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// CallbackABI is the input ABI used to generate the binding from.
const CallbackABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"RegisteredOffer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_valueOrID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"registerOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// CallbackBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const CallbackBinRuntime = `6080604052348015600f57600080fd5b506004361060285760003560e01c80635ec467e214602d575b600080fd5b603c603836600460b0565b603e565b005b604080516001600160a01b038681168252602082018690528416818301526060810183905290517f6e0b5117e49b57aaf37c635363b1b78a14ad521875ec99079d95bee2838cfeb89181900360800190a150505050565b80356001600160a01b038116811460ab57600080fd5b919050565b6000806000806080858703121560c557600080fd5b60cc856095565b93506020850135925060df604086016095565b939692955092936060013592505056fea264697066735822122090a4a1f31ef8f5fd828c9f5e0d75171712ccebed0d50af1b9d1601da775c429d64736f6c634300080d0033`

// CallbackFuncSigs maps the 4-byte function signature to its string representation.
var CallbackFuncSigs = map[string]string{
	"5ec467e2": "registerOffer(address,uint256,address,uint256)",
}

// CallbackBin is the compiled bytecode used for deploying new contracts.
var CallbackBin = "0x608060405234801561001057600080fd5b50610125806100206000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80635ec467e214602d575b600080fd5b603c603836600460b0565b603e565b005b604080516001600160a01b038681168252602082018690528416818301526060810183905290517f6e0b5117e49b57aaf37c635363b1b78a14ad521875ec99079d95bee2838cfeb89181900360800190a150505050565b80356001600160a01b038116811460ab57600080fd5b919050565b6000806000806080858703121560c557600080fd5b60cc856095565b93506020850135925060df604086016095565b939692955092936060013592505056fea264697066735822122090a4a1f31ef8f5fd828c9f5e0d75171712ccebed0d50af1b9d1601da775c429d64736f6c634300080d0033"

// DeployCallback deploys a new Klaytn contract, binding an instance of Callback to it.
func DeployCallback(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Callback, error) {
	parsed, err := abi.JSON(strings.NewReader(CallbackABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(CallbackBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Callback{CallbackCaller: CallbackCaller{contract: contract}, CallbackTransactor: CallbackTransactor{contract: contract}, CallbackFilterer: CallbackFilterer{contract: contract}}, nil
}

// Callback is an auto generated Go binding around a Klaytn contract.
type Callback struct {
	CallbackCaller     // Read-only binding to the contract
	CallbackTransactor // Write-only binding to the contract
	CallbackFilterer   // Log filterer for contract events
}

// CallbackCaller is an auto generated read-only Go binding around a Klaytn contract.
type CallbackCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CallbackTransactor is an auto generated write-only Go binding around a Klaytn contract.
type CallbackTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CallbackFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type CallbackFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CallbackSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type CallbackSession struct {
	Contract     *Callback         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CallbackCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type CallbackCallerSession struct {
	Contract *CallbackCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// CallbackTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type CallbackTransactorSession struct {
	Contract     *CallbackTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// CallbackRaw is an auto generated low-level Go binding around a Klaytn contract.
type CallbackRaw struct {
	Contract *Callback // Generic contract binding to access the raw methods on
}

// CallbackCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type CallbackCallerRaw struct {
	Contract *CallbackCaller // Generic read-only contract binding to access the raw methods on
}

// CallbackTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type CallbackTransactorRaw struct {
	Contract *CallbackTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCallback creates a new instance of Callback, bound to a specific deployed contract.
func NewCallback(address common.Address, backend bind.ContractBackend) (*Callback, error) {
	contract, err := bindCallback(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Callback{CallbackCaller: CallbackCaller{contract: contract}, CallbackTransactor: CallbackTransactor{contract: contract}, CallbackFilterer: CallbackFilterer{contract: contract}}, nil
}

// NewCallbackCaller creates a new read-only instance of Callback, bound to a specific deployed contract.
func NewCallbackCaller(address common.Address, caller bind.ContractCaller) (*CallbackCaller, error) {
	contract, err := bindCallback(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CallbackCaller{contract: contract}, nil
}

// NewCallbackTransactor creates a new write-only instance of Callback, bound to a specific deployed contract.
func NewCallbackTransactor(address common.Address, transactor bind.ContractTransactor) (*CallbackTransactor, error) {
	contract, err := bindCallback(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CallbackTransactor{contract: contract}, nil
}

// NewCallbackFilterer creates a new log filterer instance of Callback, bound to a specific deployed contract.
func NewCallbackFilterer(address common.Address, filterer bind.ContractFilterer) (*CallbackFilterer, error) {
	contract, err := bindCallback(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CallbackFilterer{contract: contract}, nil
}

// bindCallback binds a generic wrapper to an already deployed contract.
func bindCallback(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(CallbackABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Callback *CallbackRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Callback.Contract.CallbackCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Callback *CallbackRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Callback.Contract.CallbackTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Callback *CallbackRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Callback.Contract.CallbackTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Callback *CallbackCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Callback.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Callback *CallbackTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Callback.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Callback *CallbackTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Callback.Contract.contract.Transact(opts, method, params...)
}

// RegisterOffer is a paid mutator transaction binding the contract method 0x5ec467e2.
//
// Solidity: function registerOffer(address _owner, uint256 _valueOrID, address _tokenAddress, uint256 _price) returns()
func (_Callback *CallbackTransactor) RegisterOffer(opts *bind.TransactOpts, _owner common.Address, _valueOrID *big.Int, _tokenAddress common.Address, _price *big.Int) (*types.Transaction, error) {
	return _Callback.contract.Transact(opts, "registerOffer", _owner, _valueOrID, _tokenAddress, _price)
}

// RegisterOffer is a paid mutator transaction binding the contract method 0x5ec467e2.
//
// Solidity: function registerOffer(address _owner, uint256 _valueOrID, address _tokenAddress, uint256 _price) returns()
func (_Callback *CallbackSession) RegisterOffer(_owner common.Address, _valueOrID *big.Int, _tokenAddress common.Address, _price *big.Int) (*types.Transaction, error) {
	return _Callback.Contract.RegisterOffer(&_Callback.TransactOpts, _owner, _valueOrID, _tokenAddress, _price)
}

// RegisterOffer is a paid mutator transaction binding the contract method 0x5ec467e2.
//
// Solidity: function registerOffer(address _owner, uint256 _valueOrID, address _tokenAddress, uint256 _price) returns()
func (_Callback *CallbackTransactorSession) RegisterOffer(_owner common.Address, _valueOrID *big.Int, _tokenAddress common.Address, _price *big.Int) (*types.Transaction, error) {
	return _Callback.Contract.RegisterOffer(&_Callback.TransactOpts, _owner, _valueOrID, _tokenAddress, _price)
}

// CallbackRegisteredOfferIterator is returned from FilterRegisteredOffer and is used to iterate over the raw logs and unpacked data for RegisteredOffer events raised by the Callback contract.
type CallbackRegisteredOfferIterator struct {
	Event *CallbackRegisteredOffer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CallbackRegisteredOfferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CallbackRegisteredOffer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CallbackRegisteredOffer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CallbackRegisteredOfferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CallbackRegisteredOfferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CallbackRegisteredOffer represents a RegisteredOffer event raised by the Callback contract.
type CallbackRegisteredOffer struct {
	Owner        common.Address
	ValueOrID    *big.Int
	TokenAddress common.Address
	Price        *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterRegisteredOffer is a free log retrieval operation binding the contract event 0x6e0b5117e49b57aaf37c635363b1b78a14ad521875ec99079d95bee2838cfeb8.
//
// Solidity: event RegisteredOffer(address owner, uint256 valueOrID, address tokenAddress, uint256 price)
func (_Callback *CallbackFilterer) FilterRegisteredOffer(opts *bind.FilterOpts) (*CallbackRegisteredOfferIterator, error) {

	logs, sub, err := _Callback.contract.FilterLogs(opts, "RegisteredOffer")
	if err != nil {
		return nil, err
	}
	return &CallbackRegisteredOfferIterator{contract: _Callback.contract, event: "RegisteredOffer", logs: logs, sub: sub}, nil
}

// WatchRegisteredOffer is a free log subscription operation binding the contract event 0x6e0b5117e49b57aaf37c635363b1b78a14ad521875ec99079d95bee2838cfeb8.
//
// Solidity: event RegisteredOffer(address owner, uint256 valueOrID, address tokenAddress, uint256 price)
func (_Callback *CallbackFilterer) WatchRegisteredOffer(opts *bind.WatchOpts, sink chan<- *CallbackRegisteredOffer) (event.Subscription, error) {

	logs, sub, err := _Callback.contract.WatchLogs(opts, "RegisteredOffer")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CallbackRegisteredOffer)
				if err := _Callback.contract.UnpackLog(event, "RegisteredOffer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRegisteredOffer is a log parse operation binding the contract event 0x6e0b5117e49b57aaf37c635363b1b78a14ad521875ec99079d95bee2838cfeb8.
//
// Solidity: event RegisteredOffer(address owner, uint256 valueOrID, address tokenAddress, uint256 price)
func (_Callback *CallbackFilterer) ParseRegisteredOffer(log types.Log) (*CallbackRegisteredOffer, error) {
	event := new(CallbackRegisteredOffer)
	if err := _Callback.contract.UnpackLog(event, "RegisteredOffer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ContextABI is the input ABI used to generate the binding from.
const ContextABI = "[]"

// ContextBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ContextBinRuntime = ``

// Context is an auto generated Go binding around a Klaytn contract.
type Context struct {
	ContextCaller     // Read-only binding to the contract
	ContextTransactor // Write-only binding to the contract
	ContextFilterer   // Log filterer for contract events
}

// ContextCaller is an auto generated read-only Go binding around a Klaytn contract.
type ContextCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextTransactor is an auto generated write-only Go binding around a Klaytn contract.
type ContextTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type ContextFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type ContextSession struct {
	Contract     *Context          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContextCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type ContextCallerSession struct {
	Contract *ContextCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ContextTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type ContextTransactorSession struct {
	Contract     *ContextTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ContextRaw is an auto generated low-level Go binding around a Klaytn contract.
type ContextRaw struct {
	Contract *Context // Generic contract binding to access the raw methods on
}

// ContextCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type ContextCallerRaw struct {
	Contract *ContextCaller // Generic read-only contract binding to access the raw methods on
}

// ContextTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type ContextTransactorRaw struct {
	Contract *ContextTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContext creates a new instance of Context, bound to a specific deployed contract.
func NewContext(address common.Address, backend bind.ContractBackend) (*Context, error) {
	contract, err := bindContext(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Context{ContextCaller: ContextCaller{contract: contract}, ContextTransactor: ContextTransactor{contract: contract}, ContextFilterer: ContextFilterer{contract: contract}}, nil
}

// NewContextCaller creates a new read-only instance of Context, bound to a specific deployed contract.
func NewContextCaller(address common.Address, caller bind.ContractCaller) (*ContextCaller, error) {
	contract, err := bindContext(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextCaller{contract: contract}, nil
}

// NewContextTransactor creates a new write-only instance of Context, bound to a specific deployed contract.
func NewContextTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextTransactor, error) {
	contract, err := bindContext(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextTransactor{contract: contract}, nil
}

// NewContextFilterer creates a new log filterer instance of Context, bound to a specific deployed contract.
func NewContextFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextFilterer, error) {
	contract, err := bindContext(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextFilterer{contract: contract}, nil
}

// bindContext binds a generic wrapper to an already deployed contract.
func bindContext(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ContextABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Context.Contract.ContextCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Context.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.contract.Transact(opts, method, params...)
}

// ERC165ABI is the input ABI used to generate the binding from.
const ERC165ABI = "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ERC165BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ERC165BinRuntime = ``

// ERC165FuncSigs maps the 4-byte function signature to its string representation.
var ERC165FuncSigs = map[string]string{
	"01ffc9a7": "supportsInterface(bytes4)",
}

// ERC165 is an auto generated Go binding around a Klaytn contract.
type ERC165 struct {
	ERC165Caller     // Read-only binding to the contract
	ERC165Transactor // Write-only binding to the contract
	ERC165Filterer   // Log filterer for contract events
}

// ERC165Caller is an auto generated read-only Go binding around a Klaytn contract.
type ERC165Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC165Transactor is an auto generated write-only Go binding around a Klaytn contract.
type ERC165Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC165Filterer is an auto generated log filtering Go binding around a Klaytn contract events.
type ERC165Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC165Session is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type ERC165Session struct {
	Contract     *ERC165           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC165CallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type ERC165CallerSession struct {
	Contract *ERC165Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC165TransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type ERC165TransactorSession struct {
	Contract     *ERC165Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC165Raw is an auto generated low-level Go binding around a Klaytn contract.
type ERC165Raw struct {
	Contract *ERC165 // Generic contract binding to access the raw methods on
}

// ERC165CallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type ERC165CallerRaw struct {
	Contract *ERC165Caller // Generic read-only contract binding to access the raw methods on
}

// ERC165TransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type ERC165TransactorRaw struct {
	Contract *ERC165Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC165 creates a new instance of ERC165, bound to a specific deployed contract.
func NewERC165(address common.Address, backend bind.ContractBackend) (*ERC165, error) {
	contract, err := bindERC165(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC165{ERC165Caller: ERC165Caller{contract: contract}, ERC165Transactor: ERC165Transactor{contract: contract}, ERC165Filterer: ERC165Filterer{contract: contract}}, nil
}

// NewERC165Caller creates a new read-only instance of ERC165, bound to a specific deployed contract.
func NewERC165Caller(address common.Address, caller bind.ContractCaller) (*ERC165Caller, error) {
	contract, err := bindERC165(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC165Caller{contract: contract}, nil
}

// NewERC165Transactor creates a new write-only instance of ERC165, bound to a specific deployed contract.
func NewERC165Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC165Transactor, error) {
	contract, err := bindERC165(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC165Transactor{contract: contract}, nil
}

// NewERC165Filterer creates a new log filterer instance of ERC165, bound to a specific deployed contract.
func NewERC165Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC165Filterer, error) {
	contract, err := bindERC165(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC165Filterer{contract: contract}, nil
}

// bindERC165 binds a generic wrapper to an already deployed contract.
func bindERC165(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC165ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC165 *ERC165Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC165.Contract.ERC165Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC165 *ERC165Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC165.Contract.ERC165Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC165 *ERC165Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC165.Contract.ERC165Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC165 *ERC165CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC165.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC165 *ERC165TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC165.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC165 *ERC165TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC165.Contract.contract.Transact(opts, method, params...)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC165 *ERC165Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC165.contract.Call(opts, out, "supportsInterface", interfaceId)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC165 *ERC165Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC165.Contract.SupportsInterface(&_ERC165.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC165 *ERC165CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC165.Contract.SupportsInterface(&_ERC165.CallOpts, interfaceId)
}

// ERC20ABI is the input ABI used to generate the binding from.
const ERC20ABI = "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ERC20BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ERC20BinRuntime = `608060405234801561001057600080fd5b50600436106100a95760003560e01c80633950935111610071578063395093511461012357806370a082311461013657806395d89b411461015f578063a457c2d714610167578063a9059cbb1461017a578063dd62ed3e1461018d57600080fd5b806306fdde03146100ae578063095ea7b3146100cc57806318160ddd146100ef57806323b872dd14610101578063313ce56714610114575b600080fd5b6100b66101a0565b6040516100c391906106c4565b60405180910390f35b6100df6100da366004610735565b610232565b60405190151581526020016100c3565b6002545b6040519081526020016100c3565b6100df61010f36600461075f565b61024a565b604051601281526020016100c3565b6100df610131366004610735565b61026e565b6100f361014436600461079b565b6001600160a01b031660009081526020819052604090205490565b6100b6610290565b6100df610175366004610735565b61029f565b6100df610188366004610735565b61031f565b6100f361019b3660046107bd565b61032d565b6060600380546101af906107f0565b80601f01602080910402602001604051908101604052809291908181526020018280546101db906107f0565b80156102285780601f106101fd57610100808354040283529160200191610228565b820191906000526020600020905b81548152906001019060200180831161020b57829003601f168201915b5050505050905090565b600033610240818585610358565b5060019392505050565b60003361025885828561047c565b6102638585856104f6565b506001949350505050565b600033610240818585610281838361032d565b61028b919061082a565b610358565b6060600480546101af906107f0565b600033816102ad828661032d565b9050838110156103125760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77604482015264207a65726f60d81b60648201526084015b60405180910390fd5b6102638286868403610358565b6000336102408185856104f6565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b6001600160a01b0383166103ba5760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b6064820152608401610309565b6001600160a01b03821661041b5760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b6064820152608401610309565b6001600160a01b0383811660008181526001602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b6000610488848461032d565b905060001981146104f057818110156104e35760405162461bcd60e51b815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152606401610309565b6104f08484848403610358565b50505050565b6001600160a01b03831661055a5760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f206164604482015264647265737360d81b6064820152608401610309565b6001600160a01b0382166105bc5760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b6064820152608401610309565b6001600160a01b038316600090815260208190526040902054818110156106345760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e7420657863656564732062604482015265616c616e636560d01b6064820152608401610309565b6001600160a01b0380851660009081526020819052604080822085850390559185168152908120805484929061066b90849061082a565b92505081905550826001600160a01b0316846001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516106b791815260200190565b60405180910390a36104f0565b600060208083528351808285015260005b818110156106f1578581018301518582016040015282016106d5565b81811115610703576000604083870101525b50601f01601f1916929092016040019392505050565b80356001600160a01b038116811461073057600080fd5b919050565b6000806040838503121561074857600080fd5b61075183610719565b946020939093013593505050565b60008060006060848603121561077457600080fd5b61077d84610719565b925061078b60208501610719565b9150604084013590509250925092565b6000602082840312156107ad57600080fd5b6107b682610719565b9392505050565b600080604083850312156107d057600080fd5b6107d983610719565b91506107e760208401610719565b90509250929050565b600181811c9082168061080457607f821691505b60208210810361082457634e487b7160e01b600052602260045260246000fd5b50919050565b6000821982111561084b57634e487b7160e01b600052601160045260246000fd5b50019056fea2646970667358221220c927edf797341edebcd6cb380719419d5fde53086c02fe775ce245fd587221a864736f6c634300080d0033`

// ERC20FuncSigs maps the 4-byte function signature to its string representation.
var ERC20FuncSigs = map[string]string{
	"dd62ed3e": "allowance(address,address)",
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"313ce567": "decimals()",
	"a457c2d7": "decreaseAllowance(address,uint256)",
	"39509351": "increaseAllowance(address,uint256)",
	"06fdde03": "name()",
	"95d89b41": "symbol()",
	"18160ddd": "totalSupply()",
	"a9059cbb": "transfer(address,uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC20Bin is the compiled bytecode used for deploying new contracts.
var ERC20Bin = "0x60806040523480156200001157600080fd5b5060405162000b1738038062000b178339810160408190526200003491620001db565b81516200004990600390602085019062000068565b5080516200005f90600490602084019062000068565b50505062000281565b828054620000769062000245565b90600052602060002090601f0160209004810192826200009a5760008555620000e5565b82601f10620000b557805160ff1916838001178555620000e5565b82800160010185558215620000e5579182015b82811115620000e5578251825591602001919060010190620000c8565b50620000f3929150620000f7565b5090565b5b80821115620000f35760008155600101620000f8565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126200013657600080fd5b81516001600160401b03808211156200015357620001536200010e565b604051601f8301601f19908116603f011681019082821181831017156200017e576200017e6200010e565b816040528381526020925086838588010111156200019b57600080fd5b600091505b83821015620001bf5785820183015181830184015290820190620001a0565b83821115620001d15760008385830101525b9695505050505050565b60008060408385031215620001ef57600080fd5b82516001600160401b03808211156200020757600080fd5b620002158683870162000124565b935060208501519150808211156200022c57600080fd5b506200023b8582860162000124565b9150509250929050565b600181811c908216806200025a57607f821691505b6020821081036200027b57634e487b7160e01b600052602260045260246000fd5b50919050565b61088680620002916000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80633950935111610071578063395093511461012357806370a082311461013657806395d89b411461015f578063a457c2d714610167578063a9059cbb1461017a578063dd62ed3e1461018d57600080fd5b806306fdde03146100ae578063095ea7b3146100cc57806318160ddd146100ef57806323b872dd14610101578063313ce56714610114575b600080fd5b6100b66101a0565b6040516100c391906106c4565b60405180910390f35b6100df6100da366004610735565b610232565b60405190151581526020016100c3565b6002545b6040519081526020016100c3565b6100df61010f36600461075f565b61024a565b604051601281526020016100c3565b6100df610131366004610735565b61026e565b6100f361014436600461079b565b6001600160a01b031660009081526020819052604090205490565b6100b6610290565b6100df610175366004610735565b61029f565b6100df610188366004610735565b61031f565b6100f361019b3660046107bd565b61032d565b6060600380546101af906107f0565b80601f01602080910402602001604051908101604052809291908181526020018280546101db906107f0565b80156102285780601f106101fd57610100808354040283529160200191610228565b820191906000526020600020905b81548152906001019060200180831161020b57829003601f168201915b5050505050905090565b600033610240818585610358565b5060019392505050565b60003361025885828561047c565b6102638585856104f6565b506001949350505050565b600033610240818585610281838361032d565b61028b919061082a565b610358565b6060600480546101af906107f0565b600033816102ad828661032d565b9050838110156103125760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77604482015264207a65726f60d81b60648201526084015b60405180910390fd5b6102638286868403610358565b6000336102408185856104f6565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b6001600160a01b0383166103ba5760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b6064820152608401610309565b6001600160a01b03821661041b5760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b6064820152608401610309565b6001600160a01b0383811660008181526001602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b6000610488848461032d565b905060001981146104f057818110156104e35760405162461bcd60e51b815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152606401610309565b6104f08484848403610358565b50505050565b6001600160a01b03831661055a5760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f206164604482015264647265737360d81b6064820152608401610309565b6001600160a01b0382166105bc5760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b6064820152608401610309565b6001600160a01b038316600090815260208190526040902054818110156106345760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e7420657863656564732062604482015265616c616e636560d01b6064820152608401610309565b6001600160a01b0380851660009081526020819052604080822085850390559185168152908120805484929061066b90849061082a565b92505081905550826001600160a01b0316846001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516106b791815260200190565b60405180910390a36104f0565b600060208083528351808285015260005b818110156106f1578581018301518582016040015282016106d5565b81811115610703576000604083870101525b50601f01601f1916929092016040019392505050565b80356001600160a01b038116811461073057600080fd5b919050565b6000806040838503121561074857600080fd5b61075183610719565b946020939093013593505050565b60008060006060848603121561077457600080fd5b61077d84610719565b925061078b60208501610719565b9150604084013590509250925092565b6000602082840312156107ad57600080fd5b6107b682610719565b9392505050565b600080604083850312156107d057600080fd5b6107d983610719565b91506107e760208401610719565b90509250929050565b600181811c9082168061080457607f821691505b60208210810361082457634e487b7160e01b600052602260045260246000fd5b50919050565b6000821982111561084b57634e487b7160e01b600052601160045260246000fd5b50019056fea2646970667358221220c927edf797341edebcd6cb380719419d5fde53086c02fe775ce245fd587221a864736f6c634300080d0033"

// DeployERC20 deploys a new Klaytn contract, binding an instance of ERC20 to it.
func DeployERC20(auth *bind.TransactOpts, backend bind.ContractBackend, name_ string, symbol_ string) (common.Address, *types.Transaction, *ERC20, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC20ABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ERC20Bin), backend, name_, symbol_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// ERC20 is an auto generated Go binding around a Klaytn contract.
type ERC20 struct {
	ERC20Caller     // Read-only binding to the contract
	ERC20Transactor // Write-only binding to the contract
	ERC20Filterer   // Log filterer for contract events
}

// ERC20Caller is an auto generated read-only Go binding around a Klaytn contract.
type ERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Transactor is an auto generated write-only Go binding around a Klaytn contract.
type ERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Filterer is an auto generated log filtering Go binding around a Klaytn contract events.
type ERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Session is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type ERC20Session struct {
	Contract     *ERC20            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20CallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type ERC20CallerSession struct {
	Contract *ERC20Caller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC20TransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type ERC20TransactorSession struct {
	Contract     *ERC20Transactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20Raw is an auto generated low-level Go binding around a Klaytn contract.
type ERC20Raw struct {
	Contract *ERC20 // Generic contract binding to access the raw methods on
}

// ERC20CallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type ERC20CallerRaw struct {
	Contract *ERC20Caller // Generic read-only contract binding to access the raw methods on
}

// ERC20TransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type ERC20TransactorRaw struct {
	Contract *ERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20 creates a new instance of ERC20, bound to a specific deployed contract.
func NewERC20(address common.Address, backend bind.ContractBackend) (*ERC20, error) {
	contract, err := bindERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// NewERC20Caller creates a new read-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Caller(address common.Address, caller bind.ContractCaller) (*ERC20Caller, error) {
	contract, err := bindERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Caller{contract: contract}, nil
}

// NewERC20Transactor creates a new write-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC20Transactor, error) {
	contract, err := bindERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Transactor{contract: contract}, nil
}

// NewERC20Filterer creates a new log filterer instance of ERC20, bound to a specific deployed contract.
func NewERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC20Filterer, error) {
	contract, err := bindERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20Filterer{contract: contract}, nil
}

// bindERC20 binds a generic wrapper to an already deployed contract.
func bindERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.ERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "allowance", owner, spender)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "balanceOf", account)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20Caller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "decimals")
	return *ret0, err
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20Session) Decimals() (uint8, error) {
	return _ERC20.Contract.Decimals(&_ERC20.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20CallerSession) Decimals() (uint8, error) {
	return _ERC20.Contract.Decimals(&_ERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20Caller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20Session) Name() (string, error) {
	return _ERC20.Contract.Name(&_ERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20CallerSession) Name() (string, error) {
	return _ERC20.Contract.Name(&_ERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20Session) Symbol() (string, error) {
	return _ERC20.Contract.Symbol(&_ERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20CallerSession) Symbol() (string, error) {
	return _ERC20.Contract.Symbol(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20Session) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20Transactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20Session) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.DecreaseAllowance(&_ERC20.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20TransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.DecreaseAllowance(&_ERC20.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20Transactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20Session) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.IncreaseAllowance(&_ERC20.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20TransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.IncreaseAllowance(&_ERC20.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, amount)
}

// ERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20 contract.
type ERC20ApprovalIterator struct {
	Event *ERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20Approval represents a Approval event raised by the ERC20 contract.
type ERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20ApprovalIterator{contract: _ERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20Approval)
				if err := _ERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) ParseApproval(log types.Log) (*ERC20Approval, error) {
	event := new(ERC20Approval)
	if err := _ERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20 contract.
type ERC20TransferIterator struct {
	Event *ERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20Transfer represents a Transfer event raised by the ERC20 contract.
type ERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20TransferIterator{contract: _ERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20Transfer)
				if err := _ERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) ParseTransfer(log types.Log) (*ERC20Transfer, error) {
	event := new(ERC20Transfer)
	if err := _ERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC20BurnableABI is the input ABI used to generate the binding from.
const ERC20BurnableABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ERC20BurnableBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ERC20BurnableBinRuntime = ``

// ERC20BurnableFuncSigs maps the 4-byte function signature to its string representation.
var ERC20BurnableFuncSigs = map[string]string{
	"dd62ed3e": "allowance(address,address)",
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"42966c68": "burn(uint256)",
	"79cc6790": "burnFrom(address,uint256)",
	"313ce567": "decimals()",
	"a457c2d7": "decreaseAllowance(address,uint256)",
	"39509351": "increaseAllowance(address,uint256)",
	"06fdde03": "name()",
	"95d89b41": "symbol()",
	"18160ddd": "totalSupply()",
	"a9059cbb": "transfer(address,uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC20Burnable is an auto generated Go binding around a Klaytn contract.
type ERC20Burnable struct {
	ERC20BurnableCaller     // Read-only binding to the contract
	ERC20BurnableTransactor // Write-only binding to the contract
	ERC20BurnableFilterer   // Log filterer for contract events
}

// ERC20BurnableCaller is an auto generated read-only Go binding around a Klaytn contract.
type ERC20BurnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableTransactor is an auto generated write-only Go binding around a Klaytn contract.
type ERC20BurnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type ERC20BurnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type ERC20BurnableSession struct {
	Contract     *ERC20Burnable    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20BurnableCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type ERC20BurnableCallerSession struct {
	Contract *ERC20BurnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// ERC20BurnableTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type ERC20BurnableTransactorSession struct {
	Contract     *ERC20BurnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// ERC20BurnableRaw is an auto generated low-level Go binding around a Klaytn contract.
type ERC20BurnableRaw struct {
	Contract *ERC20Burnable // Generic contract binding to access the raw methods on
}

// ERC20BurnableCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type ERC20BurnableCallerRaw struct {
	Contract *ERC20BurnableCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20BurnableTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type ERC20BurnableTransactorRaw struct {
	Contract *ERC20BurnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20Burnable creates a new instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20Burnable(address common.Address, backend bind.ContractBackend) (*ERC20Burnable, error) {
	contract, err := bindERC20Burnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20Burnable{ERC20BurnableCaller: ERC20BurnableCaller{contract: contract}, ERC20BurnableTransactor: ERC20BurnableTransactor{contract: contract}, ERC20BurnableFilterer: ERC20BurnableFilterer{contract: contract}}, nil
}

// NewERC20BurnableCaller creates a new read-only instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableCaller(address common.Address, caller bind.ContractCaller) (*ERC20BurnableCaller, error) {
	contract, err := bindERC20Burnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableCaller{contract: contract}, nil
}

// NewERC20BurnableTransactor creates a new write-only instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20BurnableTransactor, error) {
	contract, err := bindERC20Burnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableTransactor{contract: contract}, nil
}

// NewERC20BurnableFilterer creates a new log filterer instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20BurnableFilterer, error) {
	contract, err := bindERC20Burnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableFilterer{contract: contract}, nil
}

// bindERC20Burnable binds a generic wrapper to an already deployed contract.
func bindERC20Burnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC20BurnableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Burnable *ERC20BurnableRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC20Burnable.Contract.ERC20BurnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Burnable *ERC20BurnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.ERC20BurnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Burnable *ERC20BurnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.ERC20BurnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Burnable *ERC20BurnableCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC20Burnable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Burnable *ERC20BurnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Burnable *ERC20BurnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20Burnable.contract.Call(opts, out, "allowance", owner, spender)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.Allowance(&_ERC20Burnable.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.Allowance(&_ERC20Burnable.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20Burnable.contract.Call(opts, out, "balanceOf", account)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.BalanceOf(&_ERC20Burnable.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.BalanceOf(&_ERC20Burnable.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _ERC20Burnable.contract.Call(opts, out, "decimals")
	return *ret0, err
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableSession) Decimals() (uint8, error) {
	return _ERC20Burnable.Contract.Decimals(&_ERC20Burnable.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableCallerSession) Decimals() (uint8, error) {
	return _ERC20Burnable.Contract.Decimals(&_ERC20Burnable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC20Burnable.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableSession) Name() (string, error) {
	return _ERC20Burnable.Contract.Name(&_ERC20Burnable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableCallerSession) Name() (string, error) {
	return _ERC20Burnable.Contract.Name(&_ERC20Burnable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC20Burnable.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableSession) Symbol() (string, error) {
	return _ERC20Burnable.Contract.Symbol(&_ERC20Burnable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableCallerSession) Symbol() (string, error) {
	return _ERC20Burnable.Contract.Symbol(&_ERC20Burnable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20Burnable.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) TotalSupply() (*big.Int, error) {
	return _ERC20Burnable.Contract.TotalSupply(&_ERC20Burnable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20Burnable.Contract.TotalSupply(&_ERC20Burnable.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Approve(&_ERC20Burnable.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Approve(&_ERC20Burnable.TransactOpts, spender, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactor) Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "burn", amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Burn(&_ERC20Burnable.TransactOpts, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactorSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Burn(&_ERC20Burnable.TransactOpts, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactor) BurnFrom(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "burnFrom", account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.BurnFrom(&_ERC20Burnable.TransactOpts, account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactorSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.BurnFrom(&_ERC20Burnable.TransactOpts, account, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.DecreaseAllowance(&_ERC20Burnable.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.DecreaseAllowance(&_ERC20Burnable.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.IncreaseAllowance(&_ERC20Burnable.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.IncreaseAllowance(&_ERC20Burnable.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Transfer(&_ERC20Burnable.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Transfer(&_ERC20Burnable.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.TransferFrom(&_ERC20Burnable.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.TransferFrom(&_ERC20Burnable.TransactOpts, from, to, amount)
}

// ERC20BurnableApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20Burnable contract.
type ERC20BurnableApprovalIterator struct {
	Event *ERC20BurnableApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BurnableApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BurnableApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BurnableApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BurnableApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BurnableApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BurnableApproval represents a Approval event raised by the ERC20Burnable contract.
type ERC20BurnableApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20BurnableApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20Burnable.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableApprovalIterator{contract: _ERC20Burnable.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20BurnableApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20Burnable.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BurnableApproval)
				if err := _ERC20Burnable.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) ParseApproval(log types.Log) (*ERC20BurnableApproval, error) {
	event := new(ERC20BurnableApproval)
	if err := _ERC20Burnable.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC20BurnableTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20Burnable contract.
type ERC20BurnableTransferIterator struct {
	Event *ERC20BurnableTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BurnableTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BurnableTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BurnableTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BurnableTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BurnableTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BurnableTransfer represents a Transfer event raised by the ERC20Burnable contract.
type ERC20BurnableTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20BurnableTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Burnable.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableTransferIterator{contract: _ERC20Burnable.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20BurnableTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Burnable.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BurnableTransfer)
				if err := _ERC20Burnable.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) ParseTransfer(log types.Log) (*ERC20BurnableTransfer, error) {
	event := new(ERC20BurnableTransfer)
	if err := _ERC20Burnable.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721ABI is the input ABI used to generate the binding from.
const ERC721ABI = "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ERC721BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ERC721BinRuntime = `608060405234801561001057600080fd5b50600436106100cf5760003560e01c80636352211e1161008c578063a22cb46511610066578063a22cb465146101b3578063b88d4fde146101c6578063c87b56dd146101d9578063e985e9c5146101ec57600080fd5b80636352211e1461017757806370a082311461018a57806395d89b41146101ab57600080fd5b806301ffc9a7146100d457806306fdde03146100fc578063081812fc14610111578063095ea7b31461013c57806323b872dd1461015157806342842e0e14610164575b600080fd5b6100e76100e2366004610d5f565b610228565b60405190151581526020015b60405180910390f35b61010461027a565b6040516100f39190610dd4565b61012461011f366004610de7565b61030c565b6040516001600160a01b0390911681526020016100f3565b61014f61014a366004610e1c565b6103a6565b005b61014f61015f366004610e46565b6104bb565b61014f610172366004610e46565b6104ec565b610124610185366004610de7565b610507565b61019d610198366004610e82565b61057e565b6040519081526020016100f3565b610104610604565b61014f6101c1366004610e9d565b610613565b61014f6101d4366004610eef565b610622565b6101046101e7366004610de7565b61065a565b6100e76101fa366004610fcb565b6001600160a01b03918216600090815260056020908152604080832093909416825291909152205460ff1690565b60006001600160e01b031982166380ac58cd60e01b148061025957506001600160e01b03198216635b5e139f60e01b145b8061027457506301ffc9a760e01b6001600160e01b03198316145b92915050565b60606000805461028990610ffe565b80601f01602080910402602001604051908101604052809291908181526020018280546102b590610ffe565b80156103025780601f106102d757610100808354040283529160200191610302565b820191906000526020600020905b8154815290600101906020018083116102e557829003601f168201915b5050505050905090565b6000818152600260205260408120546001600160a01b031661038a5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b60648201526084015b60405180910390fd5b506000908152600460205260409020546001600160a01b031690565b60006103b182610507565b9050806001600160a01b0316836001600160a01b03160361041e5760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b6064820152608401610381565b336001600160a01b038216148061043a575061043a81336101fa565b6104ac5760405162461bcd60e51b815260206004820152603860248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f74206f7760448201527f6e6572206e6f7220617070726f76656420666f7220616c6c00000000000000006064820152608401610381565b6104b68383610742565b505050565b6104c533826107b0565b6104e15760405162461bcd60e51b815260040161038190611038565b6104b68383836108a7565b6104b683838360405180602001604052806000815250610622565b6000818152600260205260408120546001600160a01b0316806102745760405162461bcd60e51b815260206004820152602960248201527f4552433732313a206f776e657220717565727920666f72206e6f6e657869737460448201526832b73a103a37b5b2b760b91b6064820152608401610381565b60006001600160a01b0382166105e85760405162461bcd60e51b815260206004820152602960248201527f4552433732313a2061646472657373207a65726f206973206e6f7420612076616044820152683634b21037bbb732b960b91b6064820152608401610381565b506001600160a01b031660009081526003602052604090205490565b60606001805461028990610ffe565b61061e338383610a43565b5050565b61062c33836107b0565b6106485760405162461bcd60e51b815260040161038190611038565b61065484848484610b11565b50505050565b6000818152600260205260409020546060906001600160a01b03166106d95760405162461bcd60e51b815260206004820152602f60248201527f4552433732314d657461646174613a2055524920717565727920666f72206e6f60448201526e3732bc34b9ba32b73a103a37b5b2b760891b6064820152608401610381565b60006106f060408051602081019091526000815290565b90506000815111610710576040518060200160405280600081525061073b565b8061071a84610b44565b60405160200161072b929190611089565b6040516020818303038152906040525b9392505050565b600081815260046020526040902080546001600160a01b0319166001600160a01b038416908117909155819061077782610507565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b6000818152600260205260408120546001600160a01b03166108295760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a206f70657261746f7220717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b6064820152608401610381565b600061083483610507565b9050806001600160a01b0316846001600160a01b0316148061087b57506001600160a01b0380821660009081526005602090815260408083209388168352929052205460ff165b8061089f5750836001600160a01b03166108948461030c565b6001600160a01b0316145b949350505050565b826001600160a01b03166108ba82610507565b6001600160a01b03161461091e5760405162461bcd60e51b815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201526437bbb732b960d91b6064820152608401610381565b6001600160a01b0382166109805760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b6064820152608401610381565b61098b600082610742565b6001600160a01b03831660009081526003602052604081208054600192906109b49084906110ce565b90915550506001600160a01b03821660009081526003602052604081208054600192906109e29084906110e5565b909155505060008181526002602052604080822080546001600160a01b0319166001600160a01b0386811691821790925591518493918716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b816001600160a01b0316836001600160a01b031603610aa45760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c6572000000000000006044820152606401610381565b6001600160a01b03838116600081815260056020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b610b1c8484846108a7565b610b2884848484610c45565b6106545760405162461bcd60e51b8152600401610381906110fd565b606081600003610b6b5750506040805180820190915260018152600360fc1b602082015290565b8160005b8115610b955780610b7f8161114f565b9150610b8e9050600a8361117e565b9150610b6f565b60008167ffffffffffffffff811115610bb057610bb0610ed9565b6040519080825280601f01601f191660200182016040528015610bda576020820181803683370190505b5090505b841561089f57610bef6001836110ce565b9150610bfc600a86611192565b610c079060306110e5565b60f81b818381518110610c1c57610c1c6111a6565b60200101906001600160f81b031916908160001a905350610c3e600a8661117e565b9450610bde565b60006001600160a01b0384163b15610d3b57604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290610c899033908990889088906004016111bc565b6020604051808303816000875af1925050508015610cc4575060408051601f3d908101601f19168201909252610cc1918101906111f9565b60015b610d21573d808015610cf2576040519150601f19603f3d011682016040523d82523d6000602084013e610cf7565b606091505b508051600003610d195760405162461bcd60e51b8152600401610381906110fd565b805181602001fd5b6001600160e01b031916630a85bd0160e11b14905061089f565b506001949350505050565b6001600160e01b031981168114610d5c57600080fd5b50565b600060208284031215610d7157600080fd5b813561073b81610d46565b60005b83811015610d97578181015183820152602001610d7f565b838111156106545750506000910152565b60008151808452610dc0816020860160208601610d7c565b601f01601f19169290920160200192915050565b60208152600061073b6020830184610da8565b600060208284031215610df957600080fd5b5035919050565b80356001600160a01b0381168114610e1757600080fd5b919050565b60008060408385031215610e2f57600080fd5b610e3883610e00565b946020939093013593505050565b600080600060608486031215610e5b57600080fd5b610e6484610e00565b9250610e7260208501610e00565b9150604084013590509250925092565b600060208284031215610e9457600080fd5b61073b82610e00565b60008060408385031215610eb057600080fd5b610eb983610e00565b915060208301358015158114610ece57600080fd5b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b60008060008060808587031215610f0557600080fd5b610f0e85610e00565b9350610f1c60208601610e00565b925060408501359150606085013567ffffffffffffffff80821115610f4057600080fd5b818701915087601f830112610f5457600080fd5b813581811115610f6657610f66610ed9565b604051601f8201601f19908116603f01168101908382118183101715610f8e57610f8e610ed9565b816040528281528a6020848701011115610fa757600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008060408385031215610fde57600080fd5b610fe783610e00565b9150610ff560208401610e00565b90509250929050565b600181811c9082168061101257607f821691505b60208210810361103257634e487b7160e01b600052602260045260246000fd5b50919050565b60208082526031908201527f4552433732313a207472616e736665722063616c6c6572206973206e6f74206f6040820152701ddb995c881b9bdc88185c1c1c9bdd9959607a1b606082015260800190565b6000835161109b818460208801610d7c565b8351908301906110af818360208801610d7c565b01949350505050565b634e487b7160e01b600052601160045260246000fd5b6000828210156110e0576110e06110b8565b500390565b600082198211156110f8576110f86110b8565b500190565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b600060018201611161576111616110b8565b5060010190565b634e487b7160e01b600052601260045260246000fd5b60008261118d5761118d611168565b500490565b6000826111a1576111a1611168565b500690565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b03858116825284166020820152604081018390526080606082018190526000906111ef90830184610da8565b9695505050505050565b60006020828403121561120b57600080fd5b815161073b81610d4656fea264697066735822122027a7b56ae50caf19da6468b86362b2fa45867945b5d8d10d6390e267956bc0ad64736f6c634300080d0033`

// ERC721FuncSigs maps the 4-byte function signature to its string representation.
var ERC721FuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"01ffc9a7": "supportsInterface(bytes4)",
	"95d89b41": "symbol()",
	"c87b56dd": "tokenURI(uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721Bin is the compiled bytecode used for deploying new contracts.
var ERC721Bin = "0x60806040523480156200001157600080fd5b50604051620014dd380380620014dd8339810160408190526200003491620001db565b81516200004990600090602085019062000068565b5080516200005f90600190602084019062000068565b50505062000281565b828054620000769062000245565b90600052602060002090601f0160209004810192826200009a5760008555620000e5565b82601f10620000b557805160ff1916838001178555620000e5565b82800160010185558215620000e5579182015b82811115620000e5578251825591602001919060010190620000c8565b50620000f3929150620000f7565b5090565b5b80821115620000f35760008155600101620000f8565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126200013657600080fd5b81516001600160401b03808211156200015357620001536200010e565b604051601f8301601f19908116603f011681019082821181831017156200017e576200017e6200010e565b816040528381526020925086838588010111156200019b57600080fd5b600091505b83821015620001bf5785820183015181830184015290820190620001a0565b83821115620001d15760008385830101525b9695505050505050565b60008060408385031215620001ef57600080fd5b82516001600160401b03808211156200020757600080fd5b620002158683870162000124565b935060208501519150808211156200022c57600080fd5b506200023b8582860162000124565b9150509250929050565b600181811c908216806200025a57607f821691505b6020821081036200027b57634e487b7160e01b600052602260045260246000fd5b50919050565b61124c80620002916000396000f3fe608060405234801561001057600080fd5b50600436106100cf5760003560e01c80636352211e1161008c578063a22cb46511610066578063a22cb465146101b3578063b88d4fde146101c6578063c87b56dd146101d9578063e985e9c5146101ec57600080fd5b80636352211e1461017757806370a082311461018a57806395d89b41146101ab57600080fd5b806301ffc9a7146100d457806306fdde03146100fc578063081812fc14610111578063095ea7b31461013c57806323b872dd1461015157806342842e0e14610164575b600080fd5b6100e76100e2366004610d5f565b610228565b60405190151581526020015b60405180910390f35b61010461027a565b6040516100f39190610dd4565b61012461011f366004610de7565b61030c565b6040516001600160a01b0390911681526020016100f3565b61014f61014a366004610e1c565b6103a6565b005b61014f61015f366004610e46565b6104bb565b61014f610172366004610e46565b6104ec565b610124610185366004610de7565b610507565b61019d610198366004610e82565b61057e565b6040519081526020016100f3565b610104610604565b61014f6101c1366004610e9d565b610613565b61014f6101d4366004610eef565b610622565b6101046101e7366004610de7565b61065a565b6100e76101fa366004610fcb565b6001600160a01b03918216600090815260056020908152604080832093909416825291909152205460ff1690565b60006001600160e01b031982166380ac58cd60e01b148061025957506001600160e01b03198216635b5e139f60e01b145b8061027457506301ffc9a760e01b6001600160e01b03198316145b92915050565b60606000805461028990610ffe565b80601f01602080910402602001604051908101604052809291908181526020018280546102b590610ffe565b80156103025780601f106102d757610100808354040283529160200191610302565b820191906000526020600020905b8154815290600101906020018083116102e557829003601f168201915b5050505050905090565b6000818152600260205260408120546001600160a01b031661038a5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b60648201526084015b60405180910390fd5b506000908152600460205260409020546001600160a01b031690565b60006103b182610507565b9050806001600160a01b0316836001600160a01b03160361041e5760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b6064820152608401610381565b336001600160a01b038216148061043a575061043a81336101fa565b6104ac5760405162461bcd60e51b815260206004820152603860248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f74206f7760448201527f6e6572206e6f7220617070726f76656420666f7220616c6c00000000000000006064820152608401610381565b6104b68383610742565b505050565b6104c533826107b0565b6104e15760405162461bcd60e51b815260040161038190611038565b6104b68383836108a7565b6104b683838360405180602001604052806000815250610622565b6000818152600260205260408120546001600160a01b0316806102745760405162461bcd60e51b815260206004820152602960248201527f4552433732313a206f776e657220717565727920666f72206e6f6e657869737460448201526832b73a103a37b5b2b760b91b6064820152608401610381565b60006001600160a01b0382166105e85760405162461bcd60e51b815260206004820152602960248201527f4552433732313a2061646472657373207a65726f206973206e6f7420612076616044820152683634b21037bbb732b960b91b6064820152608401610381565b506001600160a01b031660009081526003602052604090205490565b60606001805461028990610ffe565b61061e338383610a43565b5050565b61062c33836107b0565b6106485760405162461bcd60e51b815260040161038190611038565b61065484848484610b11565b50505050565b6000818152600260205260409020546060906001600160a01b03166106d95760405162461bcd60e51b815260206004820152602f60248201527f4552433732314d657461646174613a2055524920717565727920666f72206e6f60448201526e3732bc34b9ba32b73a103a37b5b2b760891b6064820152608401610381565b60006106f060408051602081019091526000815290565b90506000815111610710576040518060200160405280600081525061073b565b8061071a84610b44565b60405160200161072b929190611089565b6040516020818303038152906040525b9392505050565b600081815260046020526040902080546001600160a01b0319166001600160a01b038416908117909155819061077782610507565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b6000818152600260205260408120546001600160a01b03166108295760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a206f70657261746f7220717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b6064820152608401610381565b600061083483610507565b9050806001600160a01b0316846001600160a01b0316148061087b57506001600160a01b0380821660009081526005602090815260408083209388168352929052205460ff165b8061089f5750836001600160a01b03166108948461030c565b6001600160a01b0316145b949350505050565b826001600160a01b03166108ba82610507565b6001600160a01b03161461091e5760405162461bcd60e51b815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201526437bbb732b960d91b6064820152608401610381565b6001600160a01b0382166109805760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b6064820152608401610381565b61098b600082610742565b6001600160a01b03831660009081526003602052604081208054600192906109b49084906110ce565b90915550506001600160a01b03821660009081526003602052604081208054600192906109e29084906110e5565b909155505060008181526002602052604080822080546001600160a01b0319166001600160a01b0386811691821790925591518493918716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b816001600160a01b0316836001600160a01b031603610aa45760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c6572000000000000006044820152606401610381565b6001600160a01b03838116600081815260056020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b610b1c8484846108a7565b610b2884848484610c45565b6106545760405162461bcd60e51b8152600401610381906110fd565b606081600003610b6b5750506040805180820190915260018152600360fc1b602082015290565b8160005b8115610b955780610b7f8161114f565b9150610b8e9050600a8361117e565b9150610b6f565b60008167ffffffffffffffff811115610bb057610bb0610ed9565b6040519080825280601f01601f191660200182016040528015610bda576020820181803683370190505b5090505b841561089f57610bef6001836110ce565b9150610bfc600a86611192565b610c079060306110e5565b60f81b818381518110610c1c57610c1c6111a6565b60200101906001600160f81b031916908160001a905350610c3e600a8661117e565b9450610bde565b60006001600160a01b0384163b15610d3b57604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290610c899033908990889088906004016111bc565b6020604051808303816000875af1925050508015610cc4575060408051601f3d908101601f19168201909252610cc1918101906111f9565b60015b610d21573d808015610cf2576040519150601f19603f3d011682016040523d82523d6000602084013e610cf7565b606091505b508051600003610d195760405162461bcd60e51b8152600401610381906110fd565b805181602001fd5b6001600160e01b031916630a85bd0160e11b14905061089f565b506001949350505050565b6001600160e01b031981168114610d5c57600080fd5b50565b600060208284031215610d7157600080fd5b813561073b81610d46565b60005b83811015610d97578181015183820152602001610d7f565b838111156106545750506000910152565b60008151808452610dc0816020860160208601610d7c565b601f01601f19169290920160200192915050565b60208152600061073b6020830184610da8565b600060208284031215610df957600080fd5b5035919050565b80356001600160a01b0381168114610e1757600080fd5b919050565b60008060408385031215610e2f57600080fd5b610e3883610e00565b946020939093013593505050565b600080600060608486031215610e5b57600080fd5b610e6484610e00565b9250610e7260208501610e00565b9150604084013590509250925092565b600060208284031215610e9457600080fd5b61073b82610e00565b60008060408385031215610eb057600080fd5b610eb983610e00565b915060208301358015158114610ece57600080fd5b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b60008060008060808587031215610f0557600080fd5b610f0e85610e00565b9350610f1c60208601610e00565b925060408501359150606085013567ffffffffffffffff80821115610f4057600080fd5b818701915087601f830112610f5457600080fd5b813581811115610f6657610f66610ed9565b604051601f8201601f19908116603f01168101908382118183101715610f8e57610f8e610ed9565b816040528281528a6020848701011115610fa757600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008060408385031215610fde57600080fd5b610fe783610e00565b9150610ff560208401610e00565b90509250929050565b600181811c9082168061101257607f821691505b60208210810361103257634e487b7160e01b600052602260045260246000fd5b50919050565b60208082526031908201527f4552433732313a207472616e736665722063616c6c6572206973206e6f74206f6040820152701ddb995c881b9bdc88185c1c1c9bdd9959607a1b606082015260800190565b6000835161109b818460208801610d7c565b8351908301906110af818360208801610d7c565b01949350505050565b634e487b7160e01b600052601160045260246000fd5b6000828210156110e0576110e06110b8565b500390565b600082198211156110f8576110f86110b8565b500190565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b600060018201611161576111616110b8565b5060010190565b634e487b7160e01b600052601260045260246000fd5b60008261118d5761118d611168565b500490565b6000826111a1576111a1611168565b500690565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b03858116825284166020820152604081018390526080606082018190526000906111ef90830184610da8565b9695505050505050565b60006020828403121561120b57600080fd5b815161073b81610d4656fea264697066735822122027a7b56ae50caf19da6468b86362b2fa45867945b5d8d10d6390e267956bc0ad64736f6c634300080d0033"

// DeployERC721 deploys a new Klaytn contract, binding an instance of ERC721 to it.
func DeployERC721(auth *bind.TransactOpts, backend bind.ContractBackend, name_ string, symbol_ string) (common.Address, *types.Transaction, *ERC721, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721ABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ERC721Bin), backend, name_, symbol_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC721{ERC721Caller: ERC721Caller{contract: contract}, ERC721Transactor: ERC721Transactor{contract: contract}, ERC721Filterer: ERC721Filterer{contract: contract}}, nil
}

// ERC721 is an auto generated Go binding around a Klaytn contract.
type ERC721 struct {
	ERC721Caller     // Read-only binding to the contract
	ERC721Transactor // Write-only binding to the contract
	ERC721Filterer   // Log filterer for contract events
}

// ERC721Caller is an auto generated read-only Go binding around a Klaytn contract.
type ERC721Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721Transactor is an auto generated write-only Go binding around a Klaytn contract.
type ERC721Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721Filterer is an auto generated log filtering Go binding around a Klaytn contract events.
type ERC721Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721Session is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type ERC721Session struct {
	Contract     *ERC721           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721CallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type ERC721CallerSession struct {
	Contract *ERC721Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC721TransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type ERC721TransactorSession struct {
	Contract     *ERC721Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721Raw is an auto generated low-level Go binding around a Klaytn contract.
type ERC721Raw struct {
	Contract *ERC721 // Generic contract binding to access the raw methods on
}

// ERC721CallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type ERC721CallerRaw struct {
	Contract *ERC721Caller // Generic read-only contract binding to access the raw methods on
}

// ERC721TransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type ERC721TransactorRaw struct {
	Contract *ERC721Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721 creates a new instance of ERC721, bound to a specific deployed contract.
func NewERC721(address common.Address, backend bind.ContractBackend) (*ERC721, error) {
	contract, err := bindERC721(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721{ERC721Caller: ERC721Caller{contract: contract}, ERC721Transactor: ERC721Transactor{contract: contract}, ERC721Filterer: ERC721Filterer{contract: contract}}, nil
}

// NewERC721Caller creates a new read-only instance of ERC721, bound to a specific deployed contract.
func NewERC721Caller(address common.Address, caller bind.ContractCaller) (*ERC721Caller, error) {
	contract, err := bindERC721(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721Caller{contract: contract}, nil
}

// NewERC721Transactor creates a new write-only instance of ERC721, bound to a specific deployed contract.
func NewERC721Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC721Transactor, error) {
	contract, err := bindERC721(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721Transactor{contract: contract}, nil
}

// NewERC721Filterer creates a new log filterer instance of ERC721, bound to a specific deployed contract.
func NewERC721Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC721Filterer, error) {
	contract, err := bindERC721(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721Filterer{contract: contract}, nil
}

// bindERC721 binds a generic wrapper to an already deployed contract.
func bindERC721(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721 *ERC721Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721.Contract.ERC721Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721 *ERC721Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721.Contract.ERC721Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721 *ERC721Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721.Contract.ERC721Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721 *ERC721CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721 *ERC721TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721 *ERC721TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721 *ERC721Caller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "balanceOf", owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721 *ERC721Session) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ERC721.Contract.BalanceOf(&_ERC721.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721 *ERC721CallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ERC721.Contract.BalanceOf(&_ERC721.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721 *ERC721Caller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "getApproved", tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721 *ERC721Session) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ERC721.Contract.GetApproved(&_ERC721.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721 *ERC721CallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ERC721.Contract.GetApproved(&_ERC721.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721 *ERC721Caller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "isApprovedForAll", owner, operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721 *ERC721Session) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ERC721.Contract.IsApprovedForAll(&_ERC721.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721 *ERC721CallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ERC721.Contract.IsApprovedForAll(&_ERC721.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721 *ERC721Caller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721 *ERC721Session) Name() (string, error) {
	return _ERC721.Contract.Name(&_ERC721.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721 *ERC721CallerSession) Name() (string, error) {
	return _ERC721.Contract.Name(&_ERC721.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721 *ERC721Caller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "ownerOf", tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721 *ERC721Session) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ERC721.Contract.OwnerOf(&_ERC721.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721 *ERC721CallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ERC721.Contract.OwnerOf(&_ERC721.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721 *ERC721Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "supportsInterface", interfaceId)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721 *ERC721Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC721.Contract.SupportsInterface(&_ERC721.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721 *ERC721CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC721.Contract.SupportsInterface(&_ERC721.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721 *ERC721Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721 *ERC721Session) Symbol() (string, error) {
	return _ERC721.Contract.Symbol(&_ERC721.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721 *ERC721CallerSession) Symbol() (string, error) {
	return _ERC721.Contract.Symbol(&_ERC721.CallOpts)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721 *ERC721Caller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "tokenURI", tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721 *ERC721Session) TokenURI(tokenId *big.Int) (string, error) {
	return _ERC721.Contract.TokenURI(&_ERC721.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721 *ERC721CallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _ERC721.Contract.TokenURI(&_ERC721.CallOpts, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721 *ERC721Transactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721 *ERC721Session) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.Approve(&_ERC721.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721 *ERC721TransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.Approve(&_ERC721.TransactOpts, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721 *ERC721Transactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721 *ERC721Session) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.SafeTransferFrom(&_ERC721.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721 *ERC721TransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.SafeTransferFrom(&_ERC721.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721 *ERC721Transactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721 *ERC721Session) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721.Contract.SafeTransferFrom0(&_ERC721.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721 *ERC721TransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721.Contract.SafeTransferFrom0(&_ERC721.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721 *ERC721Transactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721 *ERC721Session) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721.Contract.SetApprovalForAll(&_ERC721.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721 *ERC721TransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721.Contract.SetApprovalForAll(&_ERC721.TransactOpts, operator, approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721 *ERC721Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721 *ERC721Session) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.TransferFrom(&_ERC721.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721 *ERC721TransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.TransferFrom(&_ERC721.TransactOpts, from, to, tokenId)
}

// ERC721ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721 contract.
type ERC721ApprovalIterator struct {
	Event *ERC721Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721Approval represents a Approval event raised by the ERC721 contract.
type ERC721Approval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721 *ERC721Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*ERC721ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ERC721ApprovalIterator{contract: _ERC721.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721 *ERC721Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721Approval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721Approval)
				if err := _ERC721.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721 *ERC721Filterer) ParseApproval(log types.Log) (*ERC721Approval, error) {
	event := new(ERC721Approval)
	if err := _ERC721.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721ApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721 contract.
type ERC721ApprovalForAllIterator struct {
	Event *ERC721ApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721ApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721ApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721ApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721ApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721ApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721ApprovalForAll represents a ApprovalForAll event raised by the ERC721 contract.
type ERC721ApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721 *ERC721Filterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*ERC721ApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ERC721.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721ApprovalForAllIterator{contract: _ERC721.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721 *ERC721Filterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721ApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ERC721.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721ApprovalForAll)
				if err := _ERC721.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721 *ERC721Filterer) ParseApprovalForAll(log types.Log) (*ERC721ApprovalForAll, error) {
	event := new(ERC721ApprovalForAll)
	if err := _ERC721.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721 contract.
type ERC721TransferIterator struct {
	Event *ERC721Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721Transfer represents a Transfer event raised by the ERC721 contract.
type ERC721Transfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721 *ERC721Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*ERC721TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ERC721TransferIterator{contract: _ERC721.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721 *ERC721Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721Transfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721Transfer)
				if err := _ERC721.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721 *ERC721Filterer) ParseTransfer(log types.Log) (*ERC721Transfer, error) {
	event := new(ERC721Transfer)
	if err := _ERC721.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BurnableABI is the input ABI used to generate the binding from.
const ERC721BurnableABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ERC721BurnableBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ERC721BurnableBinRuntime = ``

// ERC721BurnableFuncSigs maps the 4-byte function signature to its string representation.
var ERC721BurnableFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"42966c68": "burn(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"01ffc9a7": "supportsInterface(bytes4)",
	"95d89b41": "symbol()",
	"c87b56dd": "tokenURI(uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721Burnable is an auto generated Go binding around a Klaytn contract.
type ERC721Burnable struct {
	ERC721BurnableCaller     // Read-only binding to the contract
	ERC721BurnableTransactor // Write-only binding to the contract
	ERC721BurnableFilterer   // Log filterer for contract events
}

// ERC721BurnableCaller is an auto generated read-only Go binding around a Klaytn contract.
type ERC721BurnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BurnableTransactor is an auto generated write-only Go binding around a Klaytn contract.
type ERC721BurnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BurnableFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type ERC721BurnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BurnableSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type ERC721BurnableSession struct {
	Contract     *ERC721Burnable   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721BurnableCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type ERC721BurnableCallerSession struct {
	Contract *ERC721BurnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// ERC721BurnableTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type ERC721BurnableTransactorSession struct {
	Contract     *ERC721BurnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// ERC721BurnableRaw is an auto generated low-level Go binding around a Klaytn contract.
type ERC721BurnableRaw struct {
	Contract *ERC721Burnable // Generic contract binding to access the raw methods on
}

// ERC721BurnableCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type ERC721BurnableCallerRaw struct {
	Contract *ERC721BurnableCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721BurnableTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type ERC721BurnableTransactorRaw struct {
	Contract *ERC721BurnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721Burnable creates a new instance of ERC721Burnable, bound to a specific deployed contract.
func NewERC721Burnable(address common.Address, backend bind.ContractBackend) (*ERC721Burnable, error) {
	contract, err := bindERC721Burnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721Burnable{ERC721BurnableCaller: ERC721BurnableCaller{contract: contract}, ERC721BurnableTransactor: ERC721BurnableTransactor{contract: contract}, ERC721BurnableFilterer: ERC721BurnableFilterer{contract: contract}}, nil
}

// NewERC721BurnableCaller creates a new read-only instance of ERC721Burnable, bound to a specific deployed contract.
func NewERC721BurnableCaller(address common.Address, caller bind.ContractCaller) (*ERC721BurnableCaller, error) {
	contract, err := bindERC721Burnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721BurnableCaller{contract: contract}, nil
}

// NewERC721BurnableTransactor creates a new write-only instance of ERC721Burnable, bound to a specific deployed contract.
func NewERC721BurnableTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721BurnableTransactor, error) {
	contract, err := bindERC721Burnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721BurnableTransactor{contract: contract}, nil
}

// NewERC721BurnableFilterer creates a new log filterer instance of ERC721Burnable, bound to a specific deployed contract.
func NewERC721BurnableFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721BurnableFilterer, error) {
	contract, err := bindERC721Burnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721BurnableFilterer{contract: contract}, nil
}

// bindERC721Burnable binds a generic wrapper to an already deployed contract.
func bindERC721Burnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721BurnableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Burnable *ERC721BurnableRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Burnable.Contract.ERC721BurnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Burnable *ERC721BurnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.ERC721BurnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Burnable *ERC721BurnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.ERC721BurnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Burnable *ERC721BurnableCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Burnable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Burnable *ERC721BurnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Burnable *ERC721BurnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721Burnable *ERC721BurnableCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Burnable.contract.Call(opts, out, "balanceOf", owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721Burnable *ERC721BurnableSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ERC721Burnable.Contract.BalanceOf(&_ERC721Burnable.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721Burnable *ERC721BurnableCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ERC721Burnable.Contract.BalanceOf(&_ERC721Burnable.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721Burnable *ERC721BurnableCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Burnable.contract.Call(opts, out, "getApproved", tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721Burnable *ERC721BurnableSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ERC721Burnable.Contract.GetApproved(&_ERC721Burnable.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721Burnable *ERC721BurnableCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ERC721Burnable.Contract.GetApproved(&_ERC721Burnable.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721Burnable *ERC721BurnableCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Burnable.contract.Call(opts, out, "isApprovedForAll", owner, operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721Burnable *ERC721BurnableSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ERC721Burnable.Contract.IsApprovedForAll(&_ERC721Burnable.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721Burnable *ERC721BurnableCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ERC721Burnable.Contract.IsApprovedForAll(&_ERC721Burnable.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721Burnable *ERC721BurnableCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Burnable.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721Burnable *ERC721BurnableSession) Name() (string, error) {
	return _ERC721Burnable.Contract.Name(&_ERC721Burnable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721Burnable *ERC721BurnableCallerSession) Name() (string, error) {
	return _ERC721Burnable.Contract.Name(&_ERC721Burnable.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721Burnable *ERC721BurnableCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Burnable.contract.Call(opts, out, "ownerOf", tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721Burnable *ERC721BurnableSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ERC721Burnable.Contract.OwnerOf(&_ERC721Burnable.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721Burnable *ERC721BurnableCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ERC721Burnable.Contract.OwnerOf(&_ERC721Burnable.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721Burnable *ERC721BurnableCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Burnable.contract.Call(opts, out, "supportsInterface", interfaceId)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721Burnable *ERC721BurnableSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC721Burnable.Contract.SupportsInterface(&_ERC721Burnable.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721Burnable *ERC721BurnableCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC721Burnable.Contract.SupportsInterface(&_ERC721Burnable.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721Burnable *ERC721BurnableCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Burnable.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721Burnable *ERC721BurnableSession) Symbol() (string, error) {
	return _ERC721Burnable.Contract.Symbol(&_ERC721Burnable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721Burnable *ERC721BurnableCallerSession) Symbol() (string, error) {
	return _ERC721Burnable.Contract.Symbol(&_ERC721Burnable.CallOpts)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721Burnable *ERC721BurnableCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Burnable.contract.Call(opts, out, "tokenURI", tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721Burnable *ERC721BurnableSession) TokenURI(tokenId *big.Int) (string, error) {
	return _ERC721Burnable.Contract.TokenURI(&_ERC721Burnable.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721Burnable *ERC721BurnableCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _ERC721Burnable.Contract.TokenURI(&_ERC721Burnable.CallOpts, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.Approve(&_ERC721Burnable.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.Approve(&_ERC721Burnable.TransactOpts, to, tokenId)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableTransactor) Burn(opts *bind.TransactOpts, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.contract.Transact(opts, "burn", tokenId)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableSession) Burn(tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.Burn(&_ERC721Burnable.TransactOpts, tokenId)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableTransactorSession) Burn(tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.Burn(&_ERC721Burnable.TransactOpts, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.SafeTransferFrom(&_ERC721Burnable.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.SafeTransferFrom(&_ERC721Burnable.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721Burnable *ERC721BurnableTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721Burnable.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721Burnable *ERC721BurnableSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.SafeTransferFrom0(&_ERC721Burnable.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721Burnable *ERC721BurnableTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.SafeTransferFrom0(&_ERC721Burnable.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721Burnable *ERC721BurnableTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721Burnable.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721Burnable *ERC721BurnableSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.SetApprovalForAll(&_ERC721Burnable.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721Burnable *ERC721BurnableTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.SetApprovalForAll(&_ERC721Burnable.TransactOpts, operator, approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.TransferFrom(&_ERC721Burnable.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721Burnable *ERC721BurnableTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Burnable.Contract.TransferFrom(&_ERC721Burnable.TransactOpts, from, to, tokenId)
}

// ERC721BurnableApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721Burnable contract.
type ERC721BurnableApprovalIterator struct {
	Event *ERC721BurnableApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BurnableApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BurnableApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BurnableApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BurnableApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BurnableApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BurnableApproval represents a Approval event raised by the ERC721Burnable contract.
type ERC721BurnableApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721Burnable *ERC721BurnableFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*ERC721BurnableApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721Burnable.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BurnableApprovalIterator{contract: _ERC721Burnable.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721Burnable *ERC721BurnableFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721BurnableApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721Burnable.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BurnableApproval)
				if err := _ERC721Burnable.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721Burnable *ERC721BurnableFilterer) ParseApproval(log types.Log) (*ERC721BurnableApproval, error) {
	event := new(ERC721BurnableApproval)
	if err := _ERC721Burnable.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BurnableApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721Burnable contract.
type ERC721BurnableApprovalForAllIterator struct {
	Event *ERC721BurnableApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BurnableApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BurnableApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BurnableApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BurnableApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BurnableApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BurnableApprovalForAll represents a ApprovalForAll event raised by the ERC721Burnable contract.
type ERC721BurnableApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721Burnable *ERC721BurnableFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*ERC721BurnableApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ERC721Burnable.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BurnableApprovalForAllIterator{contract: _ERC721Burnable.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721Burnable *ERC721BurnableFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721BurnableApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ERC721Burnable.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BurnableApprovalForAll)
				if err := _ERC721Burnable.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721Burnable *ERC721BurnableFilterer) ParseApprovalForAll(log types.Log) (*ERC721BurnableApprovalForAll, error) {
	event := new(ERC721BurnableApprovalForAll)
	if err := _ERC721Burnable.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BurnableTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721Burnable contract.
type ERC721BurnableTransferIterator struct {
	Event *ERC721BurnableTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BurnableTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BurnableTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BurnableTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BurnableTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BurnableTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BurnableTransfer represents a Transfer event raised by the ERC721Burnable contract.
type ERC721BurnableTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721Burnable *ERC721BurnableFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*ERC721BurnableTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721Burnable.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BurnableTransferIterator{contract: _ERC721Burnable.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721Burnable *ERC721BurnableFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721BurnableTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721Burnable.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BurnableTransfer)
				if err := _ERC721Burnable.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721Burnable *ERC721BurnableFilterer) ParseTransfer(log types.Log) (*ERC721BurnableTransfer, error) {
	event := new(ERC721BurnableTransfer)
	if err := _ERC721Burnable.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721URIStorageABI is the input ABI used to generate the binding from.
const ERC721URIStorageABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ERC721URIStorageBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ERC721URIStorageBinRuntime = ``

// ERC721URIStorageFuncSigs maps the 4-byte function signature to its string representation.
var ERC721URIStorageFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"01ffc9a7": "supportsInterface(bytes4)",
	"95d89b41": "symbol()",
	"c87b56dd": "tokenURI(uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721URIStorage is an auto generated Go binding around a Klaytn contract.
type ERC721URIStorage struct {
	ERC721URIStorageCaller     // Read-only binding to the contract
	ERC721URIStorageTransactor // Write-only binding to the contract
	ERC721URIStorageFilterer   // Log filterer for contract events
}

// ERC721URIStorageCaller is an auto generated read-only Go binding around a Klaytn contract.
type ERC721URIStorageCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721URIStorageTransactor is an auto generated write-only Go binding around a Klaytn contract.
type ERC721URIStorageTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721URIStorageFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type ERC721URIStorageFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721URIStorageSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type ERC721URIStorageSession struct {
	Contract     *ERC721URIStorage // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721URIStorageCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type ERC721URIStorageCallerSession struct {
	Contract *ERC721URIStorageCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// ERC721URIStorageTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type ERC721URIStorageTransactorSession struct {
	Contract     *ERC721URIStorageTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// ERC721URIStorageRaw is an auto generated low-level Go binding around a Klaytn contract.
type ERC721URIStorageRaw struct {
	Contract *ERC721URIStorage // Generic contract binding to access the raw methods on
}

// ERC721URIStorageCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type ERC721URIStorageCallerRaw struct {
	Contract *ERC721URIStorageCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721URIStorageTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type ERC721URIStorageTransactorRaw struct {
	Contract *ERC721URIStorageTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721URIStorage creates a new instance of ERC721URIStorage, bound to a specific deployed contract.
func NewERC721URIStorage(address common.Address, backend bind.ContractBackend) (*ERC721URIStorage, error) {
	contract, err := bindERC721URIStorage(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721URIStorage{ERC721URIStorageCaller: ERC721URIStorageCaller{contract: contract}, ERC721URIStorageTransactor: ERC721URIStorageTransactor{contract: contract}, ERC721URIStorageFilterer: ERC721URIStorageFilterer{contract: contract}}, nil
}

// NewERC721URIStorageCaller creates a new read-only instance of ERC721URIStorage, bound to a specific deployed contract.
func NewERC721URIStorageCaller(address common.Address, caller bind.ContractCaller) (*ERC721URIStorageCaller, error) {
	contract, err := bindERC721URIStorage(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721URIStorageCaller{contract: contract}, nil
}

// NewERC721URIStorageTransactor creates a new write-only instance of ERC721URIStorage, bound to a specific deployed contract.
func NewERC721URIStorageTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721URIStorageTransactor, error) {
	contract, err := bindERC721URIStorage(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721URIStorageTransactor{contract: contract}, nil
}

// NewERC721URIStorageFilterer creates a new log filterer instance of ERC721URIStorage, bound to a specific deployed contract.
func NewERC721URIStorageFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721URIStorageFilterer, error) {
	contract, err := bindERC721URIStorage(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721URIStorageFilterer{contract: contract}, nil
}

// bindERC721URIStorage binds a generic wrapper to an already deployed contract.
func bindERC721URIStorage(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721URIStorageABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721URIStorage *ERC721URIStorageRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721URIStorage.Contract.ERC721URIStorageCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721URIStorage *ERC721URIStorageRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.ERC721URIStorageTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721URIStorage *ERC721URIStorageRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.ERC721URIStorageTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721URIStorage *ERC721URIStorageCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721URIStorage.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721URIStorage *ERC721URIStorageTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721URIStorage *ERC721URIStorageTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721URIStorage *ERC721URIStorageCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721URIStorage.contract.Call(opts, out, "balanceOf", owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721URIStorage *ERC721URIStorageSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ERC721URIStorage.Contract.BalanceOf(&_ERC721URIStorage.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_ERC721URIStorage *ERC721URIStorageCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ERC721URIStorage.Contract.BalanceOf(&_ERC721URIStorage.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721URIStorage *ERC721URIStorageCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721URIStorage.contract.Call(opts, out, "getApproved", tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721URIStorage *ERC721URIStorageSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ERC721URIStorage.Contract.GetApproved(&_ERC721URIStorage.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_ERC721URIStorage *ERC721URIStorageCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ERC721URIStorage.Contract.GetApproved(&_ERC721URIStorage.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721URIStorage *ERC721URIStorageCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721URIStorage.contract.Call(opts, out, "isApprovedForAll", owner, operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721URIStorage *ERC721URIStorageSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ERC721URIStorage.Contract.IsApprovedForAll(&_ERC721URIStorage.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ERC721URIStorage *ERC721URIStorageCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ERC721URIStorage.Contract.IsApprovedForAll(&_ERC721URIStorage.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721URIStorage *ERC721URIStorageCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721URIStorage.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721URIStorage *ERC721URIStorageSession) Name() (string, error) {
	return _ERC721URIStorage.Contract.Name(&_ERC721URIStorage.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC721URIStorage *ERC721URIStorageCallerSession) Name() (string, error) {
	return _ERC721URIStorage.Contract.Name(&_ERC721URIStorage.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721URIStorage *ERC721URIStorageCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721URIStorage.contract.Call(opts, out, "ownerOf", tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721URIStorage *ERC721URIStorageSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ERC721URIStorage.Contract.OwnerOf(&_ERC721URIStorage.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_ERC721URIStorage *ERC721URIStorageCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ERC721URIStorage.Contract.OwnerOf(&_ERC721URIStorage.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721URIStorage *ERC721URIStorageCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721URIStorage.contract.Call(opts, out, "supportsInterface", interfaceId)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721URIStorage *ERC721URIStorageSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC721URIStorage.Contract.SupportsInterface(&_ERC721URIStorage.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC721URIStorage *ERC721URIStorageCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC721URIStorage.Contract.SupportsInterface(&_ERC721URIStorage.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721URIStorage *ERC721URIStorageCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721URIStorage.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721URIStorage *ERC721URIStorageSession) Symbol() (string, error) {
	return _ERC721URIStorage.Contract.Symbol(&_ERC721URIStorage.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC721URIStorage *ERC721URIStorageCallerSession) Symbol() (string, error) {
	return _ERC721URIStorage.Contract.Symbol(&_ERC721URIStorage.CallOpts)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721URIStorage *ERC721URIStorageCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721URIStorage.contract.Call(opts, out, "tokenURI", tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721URIStorage *ERC721URIStorageSession) TokenURI(tokenId *big.Int) (string, error) {
	return _ERC721URIStorage.Contract.TokenURI(&_ERC721URIStorage.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_ERC721URIStorage *ERC721URIStorageCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _ERC721URIStorage.Contract.TokenURI(&_ERC721URIStorage.CallOpts, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.Approve(&_ERC721URIStorage.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.Approve(&_ERC721URIStorage.TransactOpts, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.SafeTransferFrom(&_ERC721URIStorage.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.SafeTransferFrom(&_ERC721URIStorage.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721URIStorage.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721URIStorage *ERC721URIStorageSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.SafeTransferFrom0(&_ERC721URIStorage.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.SafeTransferFrom0(&_ERC721URIStorage.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721URIStorage.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721URIStorage *ERC721URIStorageSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.SetApprovalForAll(&_ERC721URIStorage.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.SetApprovalForAll(&_ERC721URIStorage.TransactOpts, operator, approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.TransferFrom(&_ERC721URIStorage.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ERC721URIStorage *ERC721URIStorageTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721URIStorage.Contract.TransferFrom(&_ERC721URIStorage.TransactOpts, from, to, tokenId)
}

// ERC721URIStorageApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721URIStorage contract.
type ERC721URIStorageApprovalIterator struct {
	Event *ERC721URIStorageApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721URIStorageApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721URIStorageApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721URIStorageApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721URIStorageApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721URIStorageApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721URIStorageApproval represents a Approval event raised by the ERC721URIStorage contract.
type ERC721URIStorageApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721URIStorage *ERC721URIStorageFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*ERC721URIStorageApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721URIStorage.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ERC721URIStorageApprovalIterator{contract: _ERC721URIStorage.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721URIStorage *ERC721URIStorageFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721URIStorageApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721URIStorage.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721URIStorageApproval)
				if err := _ERC721URIStorage.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ERC721URIStorage *ERC721URIStorageFilterer) ParseApproval(log types.Log) (*ERC721URIStorageApproval, error) {
	event := new(ERC721URIStorageApproval)
	if err := _ERC721URIStorage.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721URIStorageApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721URIStorage contract.
type ERC721URIStorageApprovalForAllIterator struct {
	Event *ERC721URIStorageApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721URIStorageApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721URIStorageApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721URIStorageApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721URIStorageApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721URIStorageApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721URIStorageApprovalForAll represents a ApprovalForAll event raised by the ERC721URIStorage contract.
type ERC721URIStorageApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721URIStorage *ERC721URIStorageFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*ERC721URIStorageApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ERC721URIStorage.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721URIStorageApprovalForAllIterator{contract: _ERC721URIStorage.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721URIStorage *ERC721URIStorageFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721URIStorageApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ERC721URIStorage.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721URIStorageApprovalForAll)
				if err := _ERC721URIStorage.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ERC721URIStorage *ERC721URIStorageFilterer) ParseApprovalForAll(log types.Log) (*ERC721URIStorageApprovalForAll, error) {
	event := new(ERC721URIStorageApprovalForAll)
	if err := _ERC721URIStorage.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721URIStorageTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721URIStorage contract.
type ERC721URIStorageTransferIterator struct {
	Event *ERC721URIStorageTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721URIStorageTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721URIStorageTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721URIStorageTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721URIStorageTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721URIStorageTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721URIStorageTransfer represents a Transfer event raised by the ERC721URIStorage contract.
type ERC721URIStorageTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721URIStorage *ERC721URIStorageFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*ERC721URIStorageTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721URIStorage.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ERC721URIStorageTransferIterator{contract: _ERC721URIStorage.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721URIStorage *ERC721URIStorageFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721URIStorageTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ERC721URIStorage.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721URIStorageTransfer)
				if err := _ERC721URIStorage.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ERC721URIStorage *ERC721URIStorageFilterer) ParseTransfer(log types.Log) (*ERC721URIStorageTransfer, error) {
	event := new(ERC721URIStorageTransfer)
	if err := _ERC721URIStorage.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeABI is the input ABI used to generate the binding from.
const ExtBridgeABI = "[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_modeMintBurn\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ERC20FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"FeeReceiverChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"handleNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lowerHandleNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"HandleValueTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"KLAYFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"requestNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"RequestValueTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enumBridgeTransfer.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOrTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"requestNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"encodingVer\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encodedData\",\"type\":\"bytes\"}],\"name\":\"RequestValueTransferEncoded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_OPERATOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"callback\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"closedValueTransferVotes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"deregisterOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"deregisterToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeOfERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOfKLAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"addresspayable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_requestNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_requestBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"handleERC20Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_requestNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_requestBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"handleERC721Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"handleNoncesToBlockNums\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"handledRequestTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexOfTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerHandleNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modeMintBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onERC20Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"operatorThresholds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryBlockNumber\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"registerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredTokenList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"requestERC20Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"requestERC721Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"requestSellERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"requestSellERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_requestNonce\",\"type\":\"uint64\"}],\"name\":\"setERC20Fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enumBridgeOperator.VoteType\",\"name\":\"_voteType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"}],\"name\":\"setOperatorThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"unlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperHandleNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ExtBridgeBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const ExtBridgeBinRuntime = `608060405234801561001057600080fd5b506004361061028a5760003560e01c80638a75eee21161015c578063bab2af1d116100ce578063d8cf98ca11610087578063d8cf98ca14610676578063ea21eade14610689578063ee2aec6514610691578063efdcd974146106a4578063f1656e53146106b7578063f2fde38b146106ca57600080fd5b8063bab2af1d1461060e578063c263b5d614610621578063c5e490731461062a578063c877cf371461063d578063cb38f40714610650578063cf0da2901461066357600080fd5b8063989ba0d311610120578063989ba0d3146105935780639ef2017b146105ad578063ac6fff0b146105c0578063afb60223146105d3578063b2c01030146105e6578063b3f00674146105fb57600080fd5b80638a75eee2146105005780638c0bd916146105235780638da5cb5b1461054c5780638daa63ac1461055d5780639832c1d71461057057600080fd5b8063407e6bae1161020057806354edad72116101b957806354edad721461045f5780635526f76b146104725780635eb7413a146104a75780636e176ec2146104ca578063715018a6146104de5780637c1a0302146104e657600080fd5b8063407e6bae146103be5780634739f7e5146103d1578063488af871146103e457806348a18a6a146104125780634b40b826146104325780634c5146f51461044c57600080fd5b80632260474211610252578063226047421461035c57806326c23b541461036f5780632f88396c1461037d5780633682a450146103905780633a3099d1146103a35780633e4fe949146103ab57600080fd5b8063083b27321461028f57806310693fcd146102bf57806313a6738a146102d457806313e7c9d8146103155780632014e5d114610348575b600080fd5b6011546102a2906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6102d26102cd366004612aa4565b6106dd565b005b6102fd6102e2366004612ad8565b6010602052600090815260409020546001600160401b031681565b6040516001600160401b0390911681526020016102b6565b610338610323366004612aa4565b600b6020526000908152604090205460ff1681565b60405190151581526020016102b6565b600e5461033890600160481b900460ff1681565b6102d261036a366004612bb6565b6107d2565b6102d261036a366004612c21565b6102d261038b366004612c96565b610808565b6102d261039e366004612aa4565b610854565b6102fd600c81565b6102a26103b9366004612cd4565b610984565b6102d26103cc366004612ced565b6109ae565b6102d26103df366004612d96565b610b41565b6104046103f2366004612aa4565b60036020526000908152604090205481565b6040519081526020016102b6565b610404610420366004612aa4565b60066020526000908152604090205481565b600e546102fd90600160901b90046001600160401b031681565b6102d261045a366004612dcf565b610c66565b600f546102fd906001600160401b031681565b610495610480366004612e26565b600d6020526000908152604090205460ff1681565b60405160ff90911681526020016102b6565b6103386104b5366004612aa4565b60086020526000908152604090205460ff1681565b600e5461033890600160401b900460ff1681565b6102d2610c99565b600e546102fd90600160501b90046001600160401b031681565b61033861050e366004612cd4565b60006020819052908152604090205460ff1681565b6102a2610531366004612aa4565b6005602052600090815260409020546001600160a01b031681565b6004546001600160a01b03166102a2565b6102d261056b366004612aa4565b610ccf565b61033861057e366004612ad8565b600a6020526000908152604090205460ff1681565b600f546102fd90600160401b90046001600160401b031681565b6102d26105bb366004612aa4565b610d1b565b600e546102fd906001600160401b031681565b6102d26105e1366004612e41565b610e29565b6105ee610fbd565b6040516102b69190612f0f565b6001546102a2906001600160a01b031681565b6102d261061c366004612aa4565b61101f565b61040460025481565b6102d2610638366004612f5c565b611200565b6102d261064b366004612fbb565b611235565b6102a261065e366004612cd4565b611283565b6102d2610671366004612fd8565b611293565b6102d2610684366004612aa4565b6112a0565b6105ee611418565b6102d261069f36600461302b565b611478565b6102d26106b2366004612aa4565b61157b565b6102d26106c5366004612c21565b6115b1565b6102d26106d8366004612aa4565b6115bf565b6004546001600160a01b031633146107105760405162461bcd60e51b815260040161070790613064565b60405180910390fd5b6001600160a01b038082166000908152600560205260409020548291166107495760405162461bcd60e51b815260040161070790613099565b6001600160a01b038216600090815260086020526040902054829060ff16156107845760405162461bcd60e51b8152600401610707906130c4565b6001600160a01b038316600081815260086020526040808220805460ff19166001179055517fca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd79190a2505050565b60405162461bcd60e51b815260206004820152600b60248201526a1b9bdd081cdd5c1c1bdc9d60aa1b6044820152606401610707565b336000908152600b602052604090205460ff166108375760405162461bcd60e51b8152600401610707906130ea565b61084081611657565b1561084f5761084f8383611726565b505050565b6004546001600160a01b0316331461087e5760405162461bcd60e51b815260040161070790613064565b600c8054106108c45760405162461bcd60e51b81526020600482015260126024820152711b585e081bdc195c985d1bdc881b1a5b5a5d60721b6044820152606401610707565b6001600160a01b0381166000908152600b602052604090205460ff161561091e5760405162461bcd60e51b815260206004820152600e60248201526d32bc34b9ba1037b832b930ba37b960911b6044820152606401610707565b6001600160a01b03166000818152600b60205260408120805460ff19166001908117909155600c805491820181559091527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c70180546001600160a01b0319169091179055565b6007818154811061099457600080fd5b6000918252602090912001546001600160a01b0316905081565b80516020146109f65760405162461bcd60e51b815260206004820152601460248201527332bc3a3930a230ba309039b4bd329032b93937b960611b6044820152606401610707565b6011546001600160a01b0316610a475760405162461bcd60e51b815260206004820152601660248201527531b0b6363130b1b59030b2323932b9b99032b93937b960511b6044820152606401610707565b600081806020019051810190610a5d9190613121565b905060008111610aa25760405162461bcd60e51b815260206004820152601060248201526f37b33332b9283934b1b29032b93937b960811b6044820152606401610707565b601154610ac0908a908a906001600160a01b0316898989898961176d565b601154604051632f6233f160e11b81526001600160a01b0389811660048301526024820188905288811660448301526064820184905290911690635ec467e2906084015b600060405180830381600087803b158015610b1e57600080fd5b505af1158015610b32573d6000803e3d6000fd5b50505050505050505050505050565b6004546001600160a01b03163314610b6b5760405162461bcd60e51b815260040161070790613064565b6001600160a01b0380831660009081526005602052604090205483911615610bc55760405162461bcd60e51b815260206004820152600d60248201526c30b63637bbb2b2103a37b5b2b760991b6044820152606401610707565b6001600160a01b03808416600081815260056020908152604080832080549588166001600160a01b031996871617905560078054600690935281842083905560018301815583527fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c68890910180549094168317909355915190917f158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d91a2505050565b610c9384848484604051602001610c7f91815260200190565b6040516020818303038152906040526119cd565b50505050565b6004546001600160a01b03163314610cc35760405162461bcd60e51b815260040161070790613064565b610ccd6000611a40565b565b6004546001600160a01b03163314610cf95760405162461bcd60e51b815260040161070790613064565b601180546001600160a01b0319166001600160a01b0392909216919091179055565b6004546001600160a01b03163314610d455760405162461bcd60e51b815260040161070790613064565b6001600160a01b03808216600090815260056020526040902054829116610d7e5760405162461bcd60e51b815260040161070790613099565b6001600160a01b038216600090815260086020526040902054829060ff161515600114610dde5760405162461bcd60e51b815260206004820152600e60248201526d3ab73637b1b5b2b2103a37b5b2b760911b6044820152606401610707565b6001600160a01b038316600081815260086020526040808220805460ff19169055517f81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec9190a2505050565b8051602014610e715760405162461bcd60e51b815260206004820152601460248201527332bc3a3930a230ba309039b4bd329032b93937b960611b6044820152606401610707565b6011546001600160a01b0316610ec25760405162461bcd60e51b815260206004820152601660248201527531b0b6363130b1b59030b2323932b9b99032b93937b960511b6044820152606401610707565b600081806020019051810190610ed89190613121565b905060008111610f1d5760405162461bcd60e51b815260206004820152601060248201526f37b33332b9283934b1b29032b93937b960811b6044820152606401610707565b601154610f3c908b908b906001600160a01b03168a8a8a8a8a8a611a92565b601154604051632f6233f160e11b81526001600160a01b038a811660048301526024820189905289811660448301526064820184905290911690635ec467e290608401600060405180830381600087803b158015610f9957600080fd5b505af1158015610fad573d6000803e3d6000fd5b5050505050505050505050505050565b6060600c80548060200260200160405190810160405280929190818152602001828054801561101557602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610ff7575b5050505050905090565b6004546001600160a01b031633146110495760405162461bcd60e51b815260040161070790613064565b6001600160a01b038082166000908152600560205260409020548291166110825760405162461bcd60e51b815260040161070790613099565b6001600160a01b038216600090815260056020908152604080832080546001600160a01b031916905560088252808320805460ff191690556006909152812080549190556007546110d590600190613150565b81101561119457600780546110ec90600190613150565b815481106110fc576110fc613167565b600091825260209091200154600780546001600160a01b03909216918390811061112857611128613167565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b0316021790555080600660006007848154811061116e5761116e613167565b60009182526020808320909101546001600160a01b031683528201929092526040019020555b60078054806111a5576111a561317d565b600082815260208120820160001990810180546001600160a01b03191690559091019091556040516001600160a01b038516917f1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b691a2505050565b61122e858585858560405160200161121a91815260200190565b604051602081830303815290604052611c63565b5050505050565b6004546001600160a01b0316331461125f5760405162461bcd60e51b815260040161070790613064565b600e8054911515600160481b0269ff00000000000000000019909216919091179055565b600c818154811061099457600080fd5b610c933385848685611d62565b6004546001600160a01b031633146112ca5760405162461bcd60e51b815260040161070790613064565b6001600160a01b0381166000908152600b602052604090205460ff166112ef57600080fd5b6001600160a01b0381166000908152600b60205260408120805460ff191690555b600c5481101561141457816001600160a01b0316600c828154811061133757611337613167565b6000918252602090912001546001600160a01b03160361140257600c805461136190600190613150565b8154811061137157611371613167565b600091825260209091200154600c80546001600160a01b03909216918390811061139d5761139d613167565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600c8054806113dc576113dc61317d565b600082815260209020810160001990810180546001600160a01b03191690550190555050565b8061140c81613193565b915050611310565b5050565b60606007805480602002602001604051908101604052809291908181526020018280548015611015576020028201919060005260206000209081546001600160a01b03168152600190910190602001808311610ff7575050505050905090565b6004546001600160a01b031633146114a25760405162461bcd60e51b815260040161070790613064565b60008160ff16116114e65760405162461bcd60e51b815260206004820152600e60248201526d1e995c9bc81d1a1c995cda1bdb1960921b6044820152606401610707565b600c5460ff8216111561153b5760405162461bcd60e51b815260206004820152601c60248201527f626967676572207468616e206e756d206f66206f70657261746f7273000000006044820152606401610707565b80600d6000846002811115611552576115526131ac565b60ff90811682526020820192909252604001600020805460ff1916929091169190911790555050565b6004546001600160a01b031633146115a55760405162461bcd60e51b815260040161070790613064565b6115ae81611fe5565b50565b61122e33868686868661202f565b6004546001600160a01b031633146115e95760405162461bcd60e51b815260040161070790613064565b6001600160a01b03811661164e5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610707565b6115ae81611a40565b600e546000906001600160401b038381169116146116a85760405162461bcd60e51b815260206004820152600e60248201526d0dcdedcc6ca40dad2e6dac2e8c6d60931b6044820152606401610707565b600080366040516116ba9291906131c2565b604051809103902090506116d06001848361226e565b1561171d57600e80546001600160401b03169060006116ee836131d2565b91906101000a8154816001600160401b0302191690836001600160401b03160217905550506001915050919050565b50600092915050565b6001600160a01b038216600081815260036020526040808220849055518392917fdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b91a35050565b336000908152600b602052604090205460ff1661179c5760405162461bcd60e51b8152600401610707906130ea565b6117a583612411565b6117ae83612465565b156119c3576117d2886000908152602081905260409020805460ff19166001179055565b6001600160401b038381166000908152601060205260409020805467ffffffffffffffff191691841691909117905561180a83612513565b846001600160a01b0316866001600160a01b0316886001600160a01b03167f12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea101758b60018989600e60129054906101000a90046001600160401b03168960405161187796959493929190613272565b60405180910390a4600e54600160401b900460ff16156118f8576040516340c10f1960e01b81526001600160a01b038781166004830152602482018690528616906340c10f1990604401600060405180830381600087803b1580156118db57600080fd5b505af11580156118ef573d6000803e3d6000fd5b505050506119c3565b60405163a9059cbb60e01b81526001600160a01b0387811660048301526024820186905286169063a9059cbb906044016020604051808303816000875af1158015611947573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061196b91906132c3565b6119c35760405162461bcd60e51b8152602060048201526024808201527f68616e646c6545524332305472616e736665723a207472616e736665722066616044820152631a5b195960e21b6064820152608401610707565b5050505050505050565b6040516323b872dd60e01b8152336004820152306024820152604481018390526001600160a01b038516906323b872dd90606401600060405180830381600087803b158015611a1b57600080fd5b505af1158015611a2f573d6000803e3d6000fd5b50505050610c938433858585611d62565b600480546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b336000908152600b602052604090205460ff16611ac15760405162461bcd60e51b8152600401610707906130ea565b611aca84612411565b611ad384612465565b15611c5857611af7896000908152602081905260409020805460ff19166001179055565b6001600160401b038481166000908152601060205260409020805467ffffffffffffffff1916918516919091179055611b2f84612513565b856001600160a01b0316876001600160a01b0316896001600160a01b03167f12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea101758c60028a8a600e60129054906101000a90046001600160401b031689604051611b9c96959493929190613272565b60405180910390a4600e54600160401b900460ff1615611c1d576040516350bb4e7f60e01b81526001600160a01b038716906350bb4e7f90611be6908a90899087906004016132e0565b600060405180830381600087803b158015611c0057600080fd5b505af1158015611c14573d6000803e3d6000fd5b50505050611c58565b604051632142170760e11b81523060048201526001600160a01b038881166024830152604482018790528716906342842e0e90606401610b04565b505050505050505050565b6001600160a01b0385166323b872dd3330611c7e8688613310565b6040516001600160e01b031960e086901b1681526001600160a01b03938416600482015292909116602483015260448201526064016020604051808303816000875af1158015611cd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cf691906132c3565b611d545760405162461bcd60e51b815260206004820152602960248201527f7265717565737445524332305472616e736665723a207472616e7366657246726044820152681bdb4819985a5b195960ba1b6064820152608401610707565b61122e85338686868661202f565b6001600160a01b03808616600090815260056020526040902054869116611d9b5760405162461bcd60e51b815260040161070790613099565b6001600160a01b038616600090815260086020526040902054869060ff1615611dd65760405162461bcd60e51b8152600401610707906130c4565b600e54600160481b900460ff16611e205760405162461bcd60e51b815260206004820152600e60248201526d73746f707065642062726964676560901b6044820152606401610707565b60405163c87b56dd60e01b8152600481018590526000906001600160a01b0389169063c87b56dd90602401600060405180830381865afa158015611e68573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611e909190810190613328565b600e54909150600160401b900460ff1615611f0057604051630852cd8d60e31b8152600481018690526001600160a01b038916906342966c6890602401600060405180830381600087803b158015611ee757600080fd5b505af1158015611efb573d6000803e3d6000fd5b505050505b876001600160a01b0316866001600160a01b0316886001600160a01b03167f17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f600289600e600a9054906101000a90046001600160401b031660008b60028a604051602001611f6e9190613395565b60408051601f1981840301815290829052611f8e979695949392916133a8565b60405180910390a4600e8054600160501b90046001600160401b031690600a611fb6836131d2565b91906101000a8154816001600160401b0302191690836001600160401b03160217905550505050505050505050565b600180546001600160a01b0319166001600160a01b0383169081179091556040517f647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f78605990600090a250565b6001600160a01b038087166000908152600560205260409020548791166120685760405162461bcd60e51b815260040161070790613099565b6001600160a01b038716600090815260086020526040902054879060ff16156120a35760405162461bcd60e51b8152600401610707906130c4565b600e54600160481b900460ff166120ed5760405162461bcd60e51b815260206004820152600e60248201526d73746f707065642062726964676560901b6044820152606401610707565b6000851161212e5760405162461bcd60e51b815260206004820152600e60248201526d7a65726f206d73672e76616c756560901b6044820152606401610707565b600061213b888a87612685565b600e54909150600160401b900460ff16156121ab57604051630852cd8d60e31b8152600481018790526001600160a01b038a16906342966c6890602401600060405180830381600087803b15801561219257600080fd5b505af11580156121a6573d6000803e3d6000fd5b505050505b886001600160a01b0316876001600160a01b0316896001600160a01b03167feff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f0960018a600e600a9054906101000a90046001600160401b0316878b60405161221695949392919061340c565b60405180910390a4600e8054600160501b90046001600160401b031690600a61223e836131d2565b91906101000a8154816001600160401b0302191690836001600160401b0316021790555050505050505050505050565b60008060096000866002811115612287576122876131ac565b60ff168152602080820192909252604090810160009081206001600160401b03881682528352818120338252600181019093522054909150806122eb5781546001810183556000838152602090200180546001600160a01b03191633179055612324565b60008181526003830160205260408120805460ff169161230a83613452565b91906101000a81548160ff021916908360ff160217905550505b33600090815260018301602090815260408083208790558683526003850190915281205460ff16900361236c5760028201805460018101825560009182526020909120018490555b60008481526003830160205260408120805460ff169161238b8361346f565b91906101000a81548160ff021916908360ff16021790555050600d60008760028111156123ba576123ba6131ac565b60ff90811682526020808301939093526040918201600090812054888252600387019094529190912054918116911610612403576123f886866128ed565b60019250505061240a565b6000925050505b9392505050565b600e546001600160401b03808316600160901b9092041611156115ae5760405162461bcd60e51b815260206004820152600c60248201526b72656d6f76656420766f746560a01b6044820152606401610707565b6001600160401b0381166000908152600a602052604081205460ff16156124bc5760405162461bcd60e51b815260206004820152600b60248201526a636c6f73656420766f746560a81b6044820152606401610707565b600080366040516124ce9291906131c2565b604051809103902090506124e46000848361226e565b1561171d5750506001600160401b03166000908152600a60205260409020805460ff1916600190811790915590565b600f546001600160401b03908116908216111561254757600f805467ffffffffffffffff19166001600160401b0383161790555b600e5460009061256890600160901b90046001600160401b031660c861348e565b600f549091506001600160401b0390811690821611156125905750600f546001600160401b03165b600e54600160901b90046001600160401b03165b816001600160401b0316816001600160401b0316111580156125df57506001600160401b038082166000908152601060205260409020541615155b15612656576001600160401b0381811660009081526010602090815260408083208054600f80546fffffffffffffffff0000000000000000191691909616600160401b0217909455835467ffffffffffffffff1916909355600a905220805460ff191690558061264e816131d2565b9150506125a4565b600e80546001600160401b03909216600160901b0267ffffffffffffffff60901b199092169190911790555050565b6001600160a01b038083166000908152600360205260408120546001549192909116158015906126b55750600081115b1561285357808310156127025760405162461bcd60e51b81526020600482015260156024820152741a5b9cdd59999a58da595b9d08199959531a5b5a5d605a1b6044820152606401610707565b60015460405163a9059cbb60e01b81526001600160a01b039182166004820152602481018390529085169063a9059cbb906044016020604051808303816000875af1158015612755573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061277991906132c3565b6127955760405162461bcd60e51b8152600401610707906134b9565b60006127a18285613150565b111561284c576001600160a01b03841663a9059cbb866127c18487613150565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af115801561280c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061283091906132c3565b61284c5760405162461bcd60e51b8152600401610707906134b9565b905061240a565b60405163a9059cbb60e01b81526001600160a01b0386811660048301526024820185905285169063a9059cbb906044016020604051808303816000875af11580156128a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128c691906132c3565b6128e25760405162461bcd60e51b8152600401610707906134b9565b506000949350505050565b600060096000846002811115612905576129056131ac565b60ff168152602080820192909252604090810160009081206001600160401b0386168252909252812091505b815460ff8216101561299257816001016000836000018360ff168154811061295b5761295b613167565b60009182526020808320909101546001600160a01b031683528201929092526040018120558061298a8161346f565b915050612931565b5060005b600282015460ff821610156129f857816003016000836002018360ff16815481106129c3576129c3613167565b600091825260208083209091015483528201929092526040019020805460ff19169055806129f08161346f565b915050612996565b5060096000846002811115612a0f57612a0f6131ac565b60ff168152602080820192909252604090810160009081206001600160401b0386168252909252812090612a438282612a4d565b61122e6002830160005b50805460008255906000526020600020908101906115ae91905b80821115612a7b5760008155600101612a67565b5090565b6001600160a01b03811681146115ae57600080fd5b8035612a9f81612a7f565b919050565b600060208284031215612ab657600080fd5b813561240a81612a7f565b80356001600160401b0381168114612a9f57600080fd5b600060208284031215612aea57600080fd5b61240a82612ac1565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715612b3157612b31612af3565b604052919050565b60006001600160401b03821115612b5257612b52612af3565b50601f01601f191660200190565b600082601f830112612b7157600080fd5b8135612b84612b7f82612b39565b612b09565b818152846020838601011115612b9957600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215612bcc57600080fd5b8435612bd781612a7f565b93506020850135612be781612a7f565b92506040850135915060608501356001600160401b03811115612c0957600080fd5b612c1587828801612b60565b91505092959194509250565b600080600080600060a08688031215612c3957600080fd5b8535612c4481612a7f565b94506020860135612c5481612a7f565b9350604086013592506060860135915060808601356001600160401b03811115612c7d57600080fd5b612c8988828901612b60565b9150509295509295909350565b600080600060608486031215612cab57600080fd5b8335612cb681612a7f565b925060208401359150612ccb60408501612ac1565b90509250925092565b600060208284031215612ce657600080fd5b5035919050565b600080600080600080600080610100898b031215612d0a57600080fd5b883597506020890135612d1c81612a7f565b96506040890135612d2c81612a7f565b95506060890135612d3c81612a7f565b945060808901359350612d5160a08a01612ac1565b9250612d5f60c08a01612ac1565b915060e08901356001600160401b03811115612d7a57600080fd5b612d868b828c01612b60565b9150509295985092959890939650565b60008060408385031215612da957600080fd5b8235612db481612a7f565b91506020830135612dc481612a7f565b809150509250929050565b60008060008060808587031215612de557600080fd5b8435612df081612a7f565b93506020850135612e0081612a7f565b93969395505050506040820135916060013590565b803560ff81168114612a9f57600080fd5b600060208284031215612e3857600080fd5b61240a82612e15565b60008060008060008060008060006101208a8c031215612e6057600080fd5b8935985060208a0135612e7281612a7f565b975060408a0135612e8281612a7f565b9650612e9060608b01612a94565b955060808a01359450612ea560a08b01612ac1565b9350612eb360c08b01612ac1565b925060e08a01356001600160401b0380821115612ecf57600080fd5b612edb8d838e01612b60565b93506101008c0135915080821115612ef257600080fd5b50612eff8c828d01612b60565b9150509295985092959850929598565b6020808252825182820181905260009190848201906040850190845b81811015612f505783516001600160a01b031683529284019291840191600101612f2b565b50909695505050505050565b600080600080600060a08688031215612f7457600080fd5b8535612f7f81612a7f565b94506020860135612f8f81612a7f565b94979496505050506040830135926060810135926080909101359150565b80151581146115ae57600080fd5b600060208284031215612fcd57600080fd5b813561240a81612fad565b60008060008060808587031215612fee57600080fd5b8435612ff981612a7f565b935060208501359250604085013561301081612a7f565b915060608501356001600160401b03811115612c0957600080fd5b6000806040838503121561303e57600080fd5b82356003811061304d57600080fd5b915061305b60208401612e15565b90509250929050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6020808252601190820152703737ba1030b63637bbb2b2103a37b5b2b760791b604082015260600190565b6020808252600c908201526b3637b1b5b2b2103a37b5b2b760a11b604082015260600190565b6020808252601d908201527f6d73672e73656e646572206973206e6f7420616e206f70657261746f72000000604082015260600190565b60006020828403121561313357600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b6000828210156131625761316261313a565b500390565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052603160045260246000fd5b6000600182016131a5576131a561313a565b5060010190565b634e487b7160e01b600052602160045260246000fd5b8183823760009101908152919050565b60006001600160401b038083168181036131ee576131ee61313a565b6001019392505050565b6003811061321657634e487b7160e01b600052602160045260246000fd5b9052565b60005b8381101561323557818101518382015260200161321d565b83811115610c935750506000910152565b6000815180845261325e81602086016020860161321a565b601f01601f19169290920160200192915050565b86815261328260208201876131f8565b84604082015260006001600160401b03808616606084015280851660808401525060c060a08301526132b760c0830184613246565b98975050505050505050565b6000602082840312156132d557600080fd5b815161240a81612fad565b60018060a01b03841681528260208201526060604082015260006133076060830184613246565b95945050505050565b600082198211156133235761332361313a565b500190565b60006020828403121561333a57600080fd5b81516001600160401b0381111561335057600080fd5b8201601f8101841361336157600080fd5b805161336f612b7f82612b39565b81815285602083850101111561338457600080fd5b61330782602083016020860161321a565b60208152600061240a6020830184613246565b6133b281896131f8565b8660208201526001600160401b038616604082015284606082015260e0608082015260006133e360e0830186613246565b60ff851660a084015282810360c08401526133fe8185613246565b9a9950505050505050505050565b61341681876131f8565b8460208201526001600160401b038416604082015282606082015260a06080820152600061344760a0830184613246565b979650505050505050565b600060ff8216806134655761346561313a565b6000190192915050565b600060ff821660ff81036134855761348561313a565b60010192915050565b60006001600160401b038083168185168083038211156134b0576134b061313a565b01949350505050565b6020808252602c908201527f5f7061794552433230466565416e64526566756e644368616e67653a2074726160408201526b1b9cd9995c8819985a5b195960a21b60608201526080019056fea26469706673582212205cf87b23b399dead346815b6bdba714143f76420b383ef693f449f229f20556664736f6c634300080d0033`

// ExtBridgeFuncSigs maps the 4-byte function signature to its string representation.
var ExtBridgeFuncSigs = map[string]string{
	"3a3099d1": "MAX_OPERATOR()",
	"083b2732": "callback()",
	"9832c1d7": "closedValueTransferVotes(uint64)",
	"ac6fff0b": "configurationNonce()",
	"d8cf98ca": "deregisterOperator(address)",
	"bab2af1d": "deregisterToken(address)",
	"488af871": "feeOfERC20(address)",
	"c263b5d6": "feeOfKLAY()",
	"b3f00674": "feeReceiver()",
	"b2c01030": "getOperatorList()",
	"ea21eade": "getRegisteredTokenList()",
	"407e6bae": "handleERC20Transfer(bytes32,address,address,address,uint256,uint64,uint64,bytes)",
	"afb60223": "handleERC721Transfer(bytes32,address,address,address,uint256,uint64,uint64,string,bytes)",
	"13a6738a": "handleNoncesToBlockNums(uint64)",
	"8a75eee2": "handledRequestTx(bytes32)",
	"48a18a6a": "indexOfTokens(address)",
	"2014e5d1": "isRunning()",
	"10693fcd": "lockToken(address)",
	"5eb7413a": "lockedTokens(address)",
	"4b40b826": "lowerHandleNonce()",
	"6e176ec2": "modeMintBurn()",
	"f1656e53": "onERC20Received(address,address,uint256,uint256,bytes)",
	"cf0da290": "onERC721Received(address,uint256,address,bytes)",
	"cb38f407": "operatorList(uint256)",
	"5526f76b": "operatorThresholds(uint8)",
	"13e7c9d8": "operators(address)",
	"8da5cb5b": "owner()",
	"989ba0d3": "recoveryBlockNumber()",
	"3682a450": "registerOperator(address)",
	"4739f7e5": "registerToken(address,address)",
	"3e4fe949": "registeredTokenList(uint256)",
	"8c0bd916": "registeredTokens(address)",
	"715018a6": "renounceOwnership()",
	"26c23b54": "requestERC20Transfer(address,address,uint256,uint256,bytes)",
	"22604742": "requestERC721Transfer(address,address,uint256,bytes)",
	"7c1a0302": "requestNonce()",
	"c5e49073": "requestSellERC20(address,address,uint256,uint256,uint256)",
	"4c5146f5": "requestSellERC721(address,address,uint256,uint256)",
	"8daa63ac": "setCallback(address)",
	"2f88396c": "setERC20Fee(address,uint256,uint64)",
	"efdcd974": "setFeeReceiver(address)",
	"ee2aec65": "setOperatorThreshold(uint8,uint8)",
	"c877cf37": "start(bool)",
	"f2fde38b": "transferOwnership(address)",
	"9ef2017b": "unlockToken(address)",
	"54edad72": "upperHandleNonce()",
}

// ExtBridgeBin is the compiled bytecode used for deploying new contracts.
var ExtBridgeBin = "0x60806040819052600180546001600160a01b03199081169091556000600255600e805461ffff60401b19166901000000000000000000179055600f8054600160401b600160801b0319166801000000000000000017905560118054909116905562003757388190039081908339810160408190526200007e91620001b3565b600180546001600160a01b0319169055806200009a3362000161565b60005b600260ff82161015620000dc5760ff81166000908152600d60205260409020805460ff1916600117905580620000d381620001de565b9150506200009d565b50336000818152600b60205260408120805460ff19166001908117909155600c805491820181559091527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c70180546001600160a01b0319169091179055600e8054911515680100000000000000000260ff60401b19909216919091179055506200020c565b600480546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600060208284031215620001c657600080fd5b81518015158114620001d757600080fd5b9392505050565b600060ff821660ff81036200020357634e487b7160e01b600052601160045260246000fd5b60010192915050565b61353b806200021c6000396000f3fe608060405234801561001057600080fd5b506004361061028a5760003560e01c80638a75eee21161015c578063bab2af1d116100ce578063d8cf98ca11610087578063d8cf98ca14610676578063ea21eade14610689578063ee2aec6514610691578063efdcd974146106a4578063f1656e53146106b7578063f2fde38b146106ca57600080fd5b8063bab2af1d1461060e578063c263b5d614610621578063c5e490731461062a578063c877cf371461063d578063cb38f40714610650578063cf0da2901461066357600080fd5b8063989ba0d311610120578063989ba0d3146105935780639ef2017b146105ad578063ac6fff0b146105c0578063afb60223146105d3578063b2c01030146105e6578063b3f00674146105fb57600080fd5b80638a75eee2146105005780638c0bd916146105235780638da5cb5b1461054c5780638daa63ac1461055d5780639832c1d71461057057600080fd5b8063407e6bae1161020057806354edad72116101b957806354edad721461045f5780635526f76b146104725780635eb7413a146104a75780636e176ec2146104ca578063715018a6146104de5780637c1a0302146104e657600080fd5b8063407e6bae146103be5780634739f7e5146103d1578063488af871146103e457806348a18a6a146104125780634b40b826146104325780634c5146f51461044c57600080fd5b80632260474211610252578063226047421461035c57806326c23b541461036f5780632f88396c1461037d5780633682a450146103905780633a3099d1146103a35780633e4fe949146103ab57600080fd5b8063083b27321461028f57806310693fcd146102bf57806313a6738a146102d457806313e7c9d8146103155780632014e5d114610348575b600080fd5b6011546102a2906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6102d26102cd366004612aa4565b6106dd565b005b6102fd6102e2366004612ad8565b6010602052600090815260409020546001600160401b031681565b6040516001600160401b0390911681526020016102b6565b610338610323366004612aa4565b600b6020526000908152604090205460ff1681565b60405190151581526020016102b6565b600e5461033890600160481b900460ff1681565b6102d261036a366004612bb6565b6107d2565b6102d261036a366004612c21565b6102d261038b366004612c96565b610808565b6102d261039e366004612aa4565b610854565b6102fd600c81565b6102a26103b9366004612cd4565b610984565b6102d26103cc366004612ced565b6109ae565b6102d26103df366004612d96565b610b41565b6104046103f2366004612aa4565b60036020526000908152604090205481565b6040519081526020016102b6565b610404610420366004612aa4565b60066020526000908152604090205481565b600e546102fd90600160901b90046001600160401b031681565b6102d261045a366004612dcf565b610c66565b600f546102fd906001600160401b031681565b610495610480366004612e26565b600d6020526000908152604090205460ff1681565b60405160ff90911681526020016102b6565b6103386104b5366004612aa4565b60086020526000908152604090205460ff1681565b600e5461033890600160401b900460ff1681565b6102d2610c99565b600e546102fd90600160501b90046001600160401b031681565b61033861050e366004612cd4565b60006020819052908152604090205460ff1681565b6102a2610531366004612aa4565b6005602052600090815260409020546001600160a01b031681565b6004546001600160a01b03166102a2565b6102d261056b366004612aa4565b610ccf565b61033861057e366004612ad8565b600a6020526000908152604090205460ff1681565b600f546102fd90600160401b90046001600160401b031681565b6102d26105bb366004612aa4565b610d1b565b600e546102fd906001600160401b031681565b6102d26105e1366004612e41565b610e29565b6105ee610fbd565b6040516102b69190612f0f565b6001546102a2906001600160a01b031681565b6102d261061c366004612aa4565b61101f565b61040460025481565b6102d2610638366004612f5c565b611200565b6102d261064b366004612fbb565b611235565b6102a261065e366004612cd4565b611283565b6102d2610671366004612fd8565b611293565b6102d2610684366004612aa4565b6112a0565b6105ee611418565b6102d261069f36600461302b565b611478565b6102d26106b2366004612aa4565b61157b565b6102d26106c5366004612c21565b6115b1565b6102d26106d8366004612aa4565b6115bf565b6004546001600160a01b031633146107105760405162461bcd60e51b815260040161070790613064565b60405180910390fd5b6001600160a01b038082166000908152600560205260409020548291166107495760405162461bcd60e51b815260040161070790613099565b6001600160a01b038216600090815260086020526040902054829060ff16156107845760405162461bcd60e51b8152600401610707906130c4565b6001600160a01b038316600081815260086020526040808220805460ff19166001179055517fca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd79190a2505050565b60405162461bcd60e51b815260206004820152600b60248201526a1b9bdd081cdd5c1c1bdc9d60aa1b6044820152606401610707565b336000908152600b602052604090205460ff166108375760405162461bcd60e51b8152600401610707906130ea565b61084081611657565b1561084f5761084f8383611726565b505050565b6004546001600160a01b0316331461087e5760405162461bcd60e51b815260040161070790613064565b600c8054106108c45760405162461bcd60e51b81526020600482015260126024820152711b585e081bdc195c985d1bdc881b1a5b5a5d60721b6044820152606401610707565b6001600160a01b0381166000908152600b602052604090205460ff161561091e5760405162461bcd60e51b815260206004820152600e60248201526d32bc34b9ba1037b832b930ba37b960911b6044820152606401610707565b6001600160a01b03166000818152600b60205260408120805460ff19166001908117909155600c805491820181559091527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c70180546001600160a01b0319169091179055565b6007818154811061099457600080fd5b6000918252602090912001546001600160a01b0316905081565b80516020146109f65760405162461bcd60e51b815260206004820152601460248201527332bc3a3930a230ba309039b4bd329032b93937b960611b6044820152606401610707565b6011546001600160a01b0316610a475760405162461bcd60e51b815260206004820152601660248201527531b0b6363130b1b59030b2323932b9b99032b93937b960511b6044820152606401610707565b600081806020019051810190610a5d9190613121565b905060008111610aa25760405162461bcd60e51b815260206004820152601060248201526f37b33332b9283934b1b29032b93937b960811b6044820152606401610707565b601154610ac0908a908a906001600160a01b0316898989898961176d565b601154604051632f6233f160e11b81526001600160a01b0389811660048301526024820188905288811660448301526064820184905290911690635ec467e2906084015b600060405180830381600087803b158015610b1e57600080fd5b505af1158015610b32573d6000803e3d6000fd5b50505050505050505050505050565b6004546001600160a01b03163314610b6b5760405162461bcd60e51b815260040161070790613064565b6001600160a01b0380831660009081526005602052604090205483911615610bc55760405162461bcd60e51b815260206004820152600d60248201526c30b63637bbb2b2103a37b5b2b760991b6044820152606401610707565b6001600160a01b03808416600081815260056020908152604080832080549588166001600160a01b031996871617905560078054600690935281842083905560018301815583527fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c68890910180549094168317909355915190917f158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d91a2505050565b610c9384848484604051602001610c7f91815260200190565b6040516020818303038152906040526119cd565b50505050565b6004546001600160a01b03163314610cc35760405162461bcd60e51b815260040161070790613064565b610ccd6000611a40565b565b6004546001600160a01b03163314610cf95760405162461bcd60e51b815260040161070790613064565b601180546001600160a01b0319166001600160a01b0392909216919091179055565b6004546001600160a01b03163314610d455760405162461bcd60e51b815260040161070790613064565b6001600160a01b03808216600090815260056020526040902054829116610d7e5760405162461bcd60e51b815260040161070790613099565b6001600160a01b038216600090815260086020526040902054829060ff161515600114610dde5760405162461bcd60e51b815260206004820152600e60248201526d3ab73637b1b5b2b2103a37b5b2b760911b6044820152606401610707565b6001600160a01b038316600081815260086020526040808220805460ff19169055517f81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec9190a2505050565b8051602014610e715760405162461bcd60e51b815260206004820152601460248201527332bc3a3930a230ba309039b4bd329032b93937b960611b6044820152606401610707565b6011546001600160a01b0316610ec25760405162461bcd60e51b815260206004820152601660248201527531b0b6363130b1b59030b2323932b9b99032b93937b960511b6044820152606401610707565b600081806020019051810190610ed89190613121565b905060008111610f1d5760405162461bcd60e51b815260206004820152601060248201526f37b33332b9283934b1b29032b93937b960811b6044820152606401610707565b601154610f3c908b908b906001600160a01b03168a8a8a8a8a8a611a92565b601154604051632f6233f160e11b81526001600160a01b038a811660048301526024820189905289811660448301526064820184905290911690635ec467e290608401600060405180830381600087803b158015610f9957600080fd5b505af1158015610fad573d6000803e3d6000fd5b5050505050505050505050505050565b6060600c80548060200260200160405190810160405280929190818152602001828054801561101557602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610ff7575b5050505050905090565b6004546001600160a01b031633146110495760405162461bcd60e51b815260040161070790613064565b6001600160a01b038082166000908152600560205260409020548291166110825760405162461bcd60e51b815260040161070790613099565b6001600160a01b038216600090815260056020908152604080832080546001600160a01b031916905560088252808320805460ff191690556006909152812080549190556007546110d590600190613150565b81101561119457600780546110ec90600190613150565b815481106110fc576110fc613167565b600091825260209091200154600780546001600160a01b03909216918390811061112857611128613167565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b0316021790555080600660006007848154811061116e5761116e613167565b60009182526020808320909101546001600160a01b031683528201929092526040019020555b60078054806111a5576111a561317d565b600082815260208120820160001990810180546001600160a01b03191690559091019091556040516001600160a01b038516917f1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b691a2505050565b61122e858585858560405160200161121a91815260200190565b604051602081830303815290604052611c63565b5050505050565b6004546001600160a01b0316331461125f5760405162461bcd60e51b815260040161070790613064565b600e8054911515600160481b0269ff00000000000000000019909216919091179055565b600c818154811061099457600080fd5b610c933385848685611d62565b6004546001600160a01b031633146112ca5760405162461bcd60e51b815260040161070790613064565b6001600160a01b0381166000908152600b602052604090205460ff166112ef57600080fd5b6001600160a01b0381166000908152600b60205260408120805460ff191690555b600c5481101561141457816001600160a01b0316600c828154811061133757611337613167565b6000918252602090912001546001600160a01b03160361140257600c805461136190600190613150565b8154811061137157611371613167565b600091825260209091200154600c80546001600160a01b03909216918390811061139d5761139d613167565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600c8054806113dc576113dc61317d565b600082815260209020810160001990810180546001600160a01b03191690550190555050565b8061140c81613193565b915050611310565b5050565b60606007805480602002602001604051908101604052809291908181526020018280548015611015576020028201919060005260206000209081546001600160a01b03168152600190910190602001808311610ff7575050505050905090565b6004546001600160a01b031633146114a25760405162461bcd60e51b815260040161070790613064565b60008160ff16116114e65760405162461bcd60e51b815260206004820152600e60248201526d1e995c9bc81d1a1c995cda1bdb1960921b6044820152606401610707565b600c5460ff8216111561153b5760405162461bcd60e51b815260206004820152601c60248201527f626967676572207468616e206e756d206f66206f70657261746f7273000000006044820152606401610707565b80600d6000846002811115611552576115526131ac565b60ff90811682526020820192909252604001600020805460ff1916929091169190911790555050565b6004546001600160a01b031633146115a55760405162461bcd60e51b815260040161070790613064565b6115ae81611fe5565b50565b61122e33868686868661202f565b6004546001600160a01b031633146115e95760405162461bcd60e51b815260040161070790613064565b6001600160a01b03811661164e5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610707565b6115ae81611a40565b600e546000906001600160401b038381169116146116a85760405162461bcd60e51b815260206004820152600e60248201526d0dcdedcc6ca40dad2e6dac2e8c6d60931b6044820152606401610707565b600080366040516116ba9291906131c2565b604051809103902090506116d06001848361226e565b1561171d57600e80546001600160401b03169060006116ee836131d2565b91906101000a8154816001600160401b0302191690836001600160401b03160217905550506001915050919050565b50600092915050565b6001600160a01b038216600081815260036020526040808220849055518392917fdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b91a35050565b336000908152600b602052604090205460ff1661179c5760405162461bcd60e51b8152600401610707906130ea565b6117a583612411565b6117ae83612465565b156119c3576117d2886000908152602081905260409020805460ff19166001179055565b6001600160401b038381166000908152601060205260409020805467ffffffffffffffff191691841691909117905561180a83612513565b846001600160a01b0316866001600160a01b0316886001600160a01b03167f12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea101758b60018989600e60129054906101000a90046001600160401b03168960405161187796959493929190613272565b60405180910390a4600e54600160401b900460ff16156118f8576040516340c10f1960e01b81526001600160a01b038781166004830152602482018690528616906340c10f1990604401600060405180830381600087803b1580156118db57600080fd5b505af11580156118ef573d6000803e3d6000fd5b505050506119c3565b60405163a9059cbb60e01b81526001600160a01b0387811660048301526024820186905286169063a9059cbb906044016020604051808303816000875af1158015611947573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061196b91906132c3565b6119c35760405162461bcd60e51b8152602060048201526024808201527f68616e646c6545524332305472616e736665723a207472616e736665722066616044820152631a5b195960e21b6064820152608401610707565b5050505050505050565b6040516323b872dd60e01b8152336004820152306024820152604481018390526001600160a01b038516906323b872dd90606401600060405180830381600087803b158015611a1b57600080fd5b505af1158015611a2f573d6000803e3d6000fd5b50505050610c938433858585611d62565b600480546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b336000908152600b602052604090205460ff16611ac15760405162461bcd60e51b8152600401610707906130ea565b611aca84612411565b611ad384612465565b15611c5857611af7896000908152602081905260409020805460ff19166001179055565b6001600160401b038481166000908152601060205260409020805467ffffffffffffffff1916918516919091179055611b2f84612513565b856001600160a01b0316876001600160a01b0316896001600160a01b03167f12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea101758c60028a8a600e60129054906101000a90046001600160401b031689604051611b9c96959493929190613272565b60405180910390a4600e54600160401b900460ff1615611c1d576040516350bb4e7f60e01b81526001600160a01b038716906350bb4e7f90611be6908a90899087906004016132e0565b600060405180830381600087803b158015611c0057600080fd5b505af1158015611c14573d6000803e3d6000fd5b50505050611c58565b604051632142170760e11b81523060048201526001600160a01b038881166024830152604482018790528716906342842e0e90606401610b04565b505050505050505050565b6001600160a01b0385166323b872dd3330611c7e8688613310565b6040516001600160e01b031960e086901b1681526001600160a01b03938416600482015292909116602483015260448201526064016020604051808303816000875af1158015611cd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cf691906132c3565b611d545760405162461bcd60e51b815260206004820152602960248201527f7265717565737445524332305472616e736665723a207472616e7366657246726044820152681bdb4819985a5b195960ba1b6064820152608401610707565b61122e85338686868661202f565b6001600160a01b03808616600090815260056020526040902054869116611d9b5760405162461bcd60e51b815260040161070790613099565b6001600160a01b038616600090815260086020526040902054869060ff1615611dd65760405162461bcd60e51b8152600401610707906130c4565b600e54600160481b900460ff16611e205760405162461bcd60e51b815260206004820152600e60248201526d73746f707065642062726964676560901b6044820152606401610707565b60405163c87b56dd60e01b8152600481018590526000906001600160a01b0389169063c87b56dd90602401600060405180830381865afa158015611e68573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611e909190810190613328565b600e54909150600160401b900460ff1615611f0057604051630852cd8d60e31b8152600481018690526001600160a01b038916906342966c6890602401600060405180830381600087803b158015611ee757600080fd5b505af1158015611efb573d6000803e3d6000fd5b505050505b876001600160a01b0316866001600160a01b0316886001600160a01b03167f17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f600289600e600a9054906101000a90046001600160401b031660008b60028a604051602001611f6e9190613395565b60408051601f1981840301815290829052611f8e979695949392916133a8565b60405180910390a4600e8054600160501b90046001600160401b031690600a611fb6836131d2565b91906101000a8154816001600160401b0302191690836001600160401b03160217905550505050505050505050565b600180546001600160a01b0319166001600160a01b0383169081179091556040517f647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f78605990600090a250565b6001600160a01b038087166000908152600560205260409020548791166120685760405162461bcd60e51b815260040161070790613099565b6001600160a01b038716600090815260086020526040902054879060ff16156120a35760405162461bcd60e51b8152600401610707906130c4565b600e54600160481b900460ff166120ed5760405162461bcd60e51b815260206004820152600e60248201526d73746f707065642062726964676560901b6044820152606401610707565b6000851161212e5760405162461bcd60e51b815260206004820152600e60248201526d7a65726f206d73672e76616c756560901b6044820152606401610707565b600061213b888a87612685565b600e54909150600160401b900460ff16156121ab57604051630852cd8d60e31b8152600481018790526001600160a01b038a16906342966c6890602401600060405180830381600087803b15801561219257600080fd5b505af11580156121a6573d6000803e3d6000fd5b505050505b886001600160a01b0316876001600160a01b0316896001600160a01b03167feff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f0960018a600e600a9054906101000a90046001600160401b0316878b60405161221695949392919061340c565b60405180910390a4600e8054600160501b90046001600160401b031690600a61223e836131d2565b91906101000a8154816001600160401b0302191690836001600160401b0316021790555050505050505050505050565b60008060096000866002811115612287576122876131ac565b60ff168152602080820192909252604090810160009081206001600160401b03881682528352818120338252600181019093522054909150806122eb5781546001810183556000838152602090200180546001600160a01b03191633179055612324565b60008181526003830160205260408120805460ff169161230a83613452565b91906101000a81548160ff021916908360ff160217905550505b33600090815260018301602090815260408083208790558683526003850190915281205460ff16900361236c5760028201805460018101825560009182526020909120018490555b60008481526003830160205260408120805460ff169161238b8361346f565b91906101000a81548160ff021916908360ff16021790555050600d60008760028111156123ba576123ba6131ac565b60ff90811682526020808301939093526040918201600090812054888252600387019094529190912054918116911610612403576123f886866128ed565b60019250505061240a565b6000925050505b9392505050565b600e546001600160401b03808316600160901b9092041611156115ae5760405162461bcd60e51b815260206004820152600c60248201526b72656d6f76656420766f746560a01b6044820152606401610707565b6001600160401b0381166000908152600a602052604081205460ff16156124bc5760405162461bcd60e51b815260206004820152600b60248201526a636c6f73656420766f746560a81b6044820152606401610707565b600080366040516124ce9291906131c2565b604051809103902090506124e46000848361226e565b1561171d5750506001600160401b03166000908152600a60205260409020805460ff1916600190811790915590565b600f546001600160401b03908116908216111561254757600f805467ffffffffffffffff19166001600160401b0383161790555b600e5460009061256890600160901b90046001600160401b031660c861348e565b600f549091506001600160401b0390811690821611156125905750600f546001600160401b03165b600e54600160901b90046001600160401b03165b816001600160401b0316816001600160401b0316111580156125df57506001600160401b038082166000908152601060205260409020541615155b15612656576001600160401b0381811660009081526010602090815260408083208054600f80546fffffffffffffffff0000000000000000191691909616600160401b0217909455835467ffffffffffffffff1916909355600a905220805460ff191690558061264e816131d2565b9150506125a4565b600e80546001600160401b03909216600160901b0267ffffffffffffffff60901b199092169190911790555050565b6001600160a01b038083166000908152600360205260408120546001549192909116158015906126b55750600081115b1561285357808310156127025760405162461bcd60e51b81526020600482015260156024820152741a5b9cdd59999a58da595b9d08199959531a5b5a5d605a1b6044820152606401610707565b60015460405163a9059cbb60e01b81526001600160a01b039182166004820152602481018390529085169063a9059cbb906044016020604051808303816000875af1158015612755573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061277991906132c3565b6127955760405162461bcd60e51b8152600401610707906134b9565b60006127a18285613150565b111561284c576001600160a01b03841663a9059cbb866127c18487613150565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af115801561280c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061283091906132c3565b61284c5760405162461bcd60e51b8152600401610707906134b9565b905061240a565b60405163a9059cbb60e01b81526001600160a01b0386811660048301526024820185905285169063a9059cbb906044016020604051808303816000875af11580156128a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128c691906132c3565b6128e25760405162461bcd60e51b8152600401610707906134b9565b506000949350505050565b600060096000846002811115612905576129056131ac565b60ff168152602080820192909252604090810160009081206001600160401b0386168252909252812091505b815460ff8216101561299257816001016000836000018360ff168154811061295b5761295b613167565b60009182526020808320909101546001600160a01b031683528201929092526040018120558061298a8161346f565b915050612931565b5060005b600282015460ff821610156129f857816003016000836002018360ff16815481106129c3576129c3613167565b600091825260208083209091015483528201929092526040019020805460ff19169055806129f08161346f565b915050612996565b5060096000846002811115612a0f57612a0f6131ac565b60ff168152602080820192909252604090810160009081206001600160401b0386168252909252812090612a438282612a4d565b61122e6002830160005b50805460008255906000526020600020908101906115ae91905b80821115612a7b5760008155600101612a67565b5090565b6001600160a01b03811681146115ae57600080fd5b8035612a9f81612a7f565b919050565b600060208284031215612ab657600080fd5b813561240a81612a7f565b80356001600160401b0381168114612a9f57600080fd5b600060208284031215612aea57600080fd5b61240a82612ac1565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715612b3157612b31612af3565b604052919050565b60006001600160401b03821115612b5257612b52612af3565b50601f01601f191660200190565b600082601f830112612b7157600080fd5b8135612b84612b7f82612b39565b612b09565b818152846020838601011115612b9957600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215612bcc57600080fd5b8435612bd781612a7f565b93506020850135612be781612a7f565b92506040850135915060608501356001600160401b03811115612c0957600080fd5b612c1587828801612b60565b91505092959194509250565b600080600080600060a08688031215612c3957600080fd5b8535612c4481612a7f565b94506020860135612c5481612a7f565b9350604086013592506060860135915060808601356001600160401b03811115612c7d57600080fd5b612c8988828901612b60565b9150509295509295909350565b600080600060608486031215612cab57600080fd5b8335612cb681612a7f565b925060208401359150612ccb60408501612ac1565b90509250925092565b600060208284031215612ce657600080fd5b5035919050565b600080600080600080600080610100898b031215612d0a57600080fd5b883597506020890135612d1c81612a7f565b96506040890135612d2c81612a7f565b95506060890135612d3c81612a7f565b945060808901359350612d5160a08a01612ac1565b9250612d5f60c08a01612ac1565b915060e08901356001600160401b03811115612d7a57600080fd5b612d868b828c01612b60565b9150509295985092959890939650565b60008060408385031215612da957600080fd5b8235612db481612a7f565b91506020830135612dc481612a7f565b809150509250929050565b60008060008060808587031215612de557600080fd5b8435612df081612a7f565b93506020850135612e0081612a7f565b93969395505050506040820135916060013590565b803560ff81168114612a9f57600080fd5b600060208284031215612e3857600080fd5b61240a82612e15565b60008060008060008060008060006101208a8c031215612e6057600080fd5b8935985060208a0135612e7281612a7f565b975060408a0135612e8281612a7f565b9650612e9060608b01612a94565b955060808a01359450612ea560a08b01612ac1565b9350612eb360c08b01612ac1565b925060e08a01356001600160401b0380821115612ecf57600080fd5b612edb8d838e01612b60565b93506101008c0135915080821115612ef257600080fd5b50612eff8c828d01612b60565b9150509295985092959850929598565b6020808252825182820181905260009190848201906040850190845b81811015612f505783516001600160a01b031683529284019291840191600101612f2b565b50909695505050505050565b600080600080600060a08688031215612f7457600080fd5b8535612f7f81612a7f565b94506020860135612f8f81612a7f565b94979496505050506040830135926060810135926080909101359150565b80151581146115ae57600080fd5b600060208284031215612fcd57600080fd5b813561240a81612fad565b60008060008060808587031215612fee57600080fd5b8435612ff981612a7f565b935060208501359250604085013561301081612a7f565b915060608501356001600160401b03811115612c0957600080fd5b6000806040838503121561303e57600080fd5b82356003811061304d57600080fd5b915061305b60208401612e15565b90509250929050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6020808252601190820152703737ba1030b63637bbb2b2103a37b5b2b760791b604082015260600190565b6020808252600c908201526b3637b1b5b2b2103a37b5b2b760a11b604082015260600190565b6020808252601d908201527f6d73672e73656e646572206973206e6f7420616e206f70657261746f72000000604082015260600190565b60006020828403121561313357600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b6000828210156131625761316261313a565b500390565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052603160045260246000fd5b6000600182016131a5576131a561313a565b5060010190565b634e487b7160e01b600052602160045260246000fd5b8183823760009101908152919050565b60006001600160401b038083168181036131ee576131ee61313a565b6001019392505050565b6003811061321657634e487b7160e01b600052602160045260246000fd5b9052565b60005b8381101561323557818101518382015260200161321d565b83811115610c935750506000910152565b6000815180845261325e81602086016020860161321a565b601f01601f19169290920160200192915050565b86815261328260208201876131f8565b84604082015260006001600160401b03808616606084015280851660808401525060c060a08301526132b760c0830184613246565b98975050505050505050565b6000602082840312156132d557600080fd5b815161240a81612fad565b60018060a01b03841681528260208201526060604082015260006133076060830184613246565b95945050505050565b600082198211156133235761332361313a565b500190565b60006020828403121561333a57600080fd5b81516001600160401b0381111561335057600080fd5b8201601f8101841361336157600080fd5b805161336f612b7f82612b39565b81815285602083850101111561338457600080fd5b61330782602083016020860161321a565b60208152600061240a6020830184613246565b6133b281896131f8565b8660208201526001600160401b038616604082015284606082015260e0608082015260006133e360e0830186613246565b60ff851660a084015282810360c08401526133fe8185613246565b9a9950505050505050505050565b61341681876131f8565b8460208201526001600160401b038416604082015282606082015260a06080820152600061344760a0830184613246565b979650505050505050565b600060ff8216806134655761346561313a565b6000190192915050565b600060ff821660ff81036134855761348561313a565b60010192915050565b60006001600160401b038083168185168083038211156134b0576134b061313a565b01949350505050565b6020808252602c908201527f5f7061794552433230466565416e64526566756e644368616e67653a2074726160408201526b1b9cd9995c8819985a5b195960a21b60608201526080019056fea26469706673582212205cf87b23b399dead346815b6bdba714143f76420b383ef693f449f229f20556664736f6c634300080d0033"

// DeployExtBridge deploys a new Klaytn contract, binding an instance of ExtBridge to it.
func DeployExtBridge(auth *bind.TransactOpts, backend bind.ContractBackend, _modeMintBurn bool) (common.Address, *types.Transaction, *ExtBridge, error) {
	parsed, err := abi.JSON(strings.NewReader(ExtBridgeABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ExtBridgeBin), backend, _modeMintBurn)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExtBridge{ExtBridgeCaller: ExtBridgeCaller{contract: contract}, ExtBridgeTransactor: ExtBridgeTransactor{contract: contract}, ExtBridgeFilterer: ExtBridgeFilterer{contract: contract}}, nil
}

// ExtBridge is an auto generated Go binding around a Klaytn contract.
type ExtBridge struct {
	ExtBridgeCaller     // Read-only binding to the contract
	ExtBridgeTransactor // Write-only binding to the contract
	ExtBridgeFilterer   // Log filterer for contract events
}

// ExtBridgeCaller is an auto generated read-only Go binding around a Klaytn contract.
type ExtBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExtBridgeTransactor is an auto generated write-only Go binding around a Klaytn contract.
type ExtBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExtBridgeFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type ExtBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExtBridgeSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type ExtBridgeSession struct {
	Contract     *ExtBridge        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ExtBridgeCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type ExtBridgeCallerSession struct {
	Contract *ExtBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// ExtBridgeTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type ExtBridgeTransactorSession struct {
	Contract     *ExtBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ExtBridgeRaw is an auto generated low-level Go binding around a Klaytn contract.
type ExtBridgeRaw struct {
	Contract *ExtBridge // Generic contract binding to access the raw methods on
}

// ExtBridgeCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type ExtBridgeCallerRaw struct {
	Contract *ExtBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// ExtBridgeTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type ExtBridgeTransactorRaw struct {
	Contract *ExtBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExtBridge creates a new instance of ExtBridge, bound to a specific deployed contract.
func NewExtBridge(address common.Address, backend bind.ContractBackend) (*ExtBridge, error) {
	contract, err := bindExtBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExtBridge{ExtBridgeCaller: ExtBridgeCaller{contract: contract}, ExtBridgeTransactor: ExtBridgeTransactor{contract: contract}, ExtBridgeFilterer: ExtBridgeFilterer{contract: contract}}, nil
}

// NewExtBridgeCaller creates a new read-only instance of ExtBridge, bound to a specific deployed contract.
func NewExtBridgeCaller(address common.Address, caller bind.ContractCaller) (*ExtBridgeCaller, error) {
	contract, err := bindExtBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeCaller{contract: contract}, nil
}

// NewExtBridgeTransactor creates a new write-only instance of ExtBridge, bound to a specific deployed contract.
func NewExtBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*ExtBridgeTransactor, error) {
	contract, err := bindExtBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeTransactor{contract: contract}, nil
}

// NewExtBridgeFilterer creates a new log filterer instance of ExtBridge, bound to a specific deployed contract.
func NewExtBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*ExtBridgeFilterer, error) {
	contract, err := bindExtBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeFilterer{contract: contract}, nil
}

// bindExtBridge binds a generic wrapper to an already deployed contract.
func bindExtBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ExtBridgeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExtBridge *ExtBridgeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ExtBridge.Contract.ExtBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExtBridge *ExtBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExtBridge.Contract.ExtBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExtBridge *ExtBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExtBridge.Contract.ExtBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExtBridge *ExtBridgeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ExtBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExtBridge *ExtBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExtBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExtBridge *ExtBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExtBridge.Contract.contract.Transact(opts, method, params...)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_ExtBridge *ExtBridgeCaller) MAXOPERATOR(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "MAX_OPERATOR")
	return *ret0, err
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_ExtBridge *ExtBridgeSession) MAXOPERATOR() (uint64, error) {
	return _ExtBridge.Contract.MAXOPERATOR(&_ExtBridge.CallOpts)
}

// MAXOPERATOR is a free data retrieval call binding the contract method 0x3a3099d1.
//
// Solidity: function MAX_OPERATOR() view returns(uint64)
func (_ExtBridge *ExtBridgeCallerSession) MAXOPERATOR() (uint64, error) {
	return _ExtBridge.Contract.MAXOPERATOR(&_ExtBridge.CallOpts)
}

// Callback is a free data retrieval call binding the contract method 0x083b2732.
//
// Solidity: function callback() view returns(address)
func (_ExtBridge *ExtBridgeCaller) Callback(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "callback")
	return *ret0, err
}

// Callback is a free data retrieval call binding the contract method 0x083b2732.
//
// Solidity: function callback() view returns(address)
func (_ExtBridge *ExtBridgeSession) Callback() (common.Address, error) {
	return _ExtBridge.Contract.Callback(&_ExtBridge.CallOpts)
}

// Callback is a free data retrieval call binding the contract method 0x083b2732.
//
// Solidity: function callback() view returns(address)
func (_ExtBridge *ExtBridgeCallerSession) Callback() (common.Address, error) {
	return _ExtBridge.Contract.Callback(&_ExtBridge.CallOpts)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_ExtBridge *ExtBridgeCaller) ClosedValueTransferVotes(opts *bind.CallOpts, arg0 uint64) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "closedValueTransferVotes", arg0)
	return *ret0, err
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_ExtBridge *ExtBridgeSession) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _ExtBridge.Contract.ClosedValueTransferVotes(&_ExtBridge.CallOpts, arg0)
}

// ClosedValueTransferVotes is a free data retrieval call binding the contract method 0x9832c1d7.
//
// Solidity: function closedValueTransferVotes(uint64 ) view returns(bool)
func (_ExtBridge *ExtBridgeCallerSession) ClosedValueTransferVotes(arg0 uint64) (bool, error) {
	return _ExtBridge.Contract.ClosedValueTransferVotes(&_ExtBridge.CallOpts, arg0)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeCaller) ConfigurationNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "configurationNonce")
	return *ret0, err
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeSession) ConfigurationNonce() (uint64, error) {
	return _ExtBridge.Contract.ConfigurationNonce(&_ExtBridge.CallOpts)
}

// ConfigurationNonce is a free data retrieval call binding the contract method 0xac6fff0b.
//
// Solidity: function configurationNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeCallerSession) ConfigurationNonce() (uint64, error) {
	return _ExtBridge.Contract.ConfigurationNonce(&_ExtBridge.CallOpts)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_ExtBridge *ExtBridgeCaller) FeeOfERC20(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "feeOfERC20", arg0)
	return *ret0, err
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_ExtBridge *ExtBridgeSession) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _ExtBridge.Contract.FeeOfERC20(&_ExtBridge.CallOpts, arg0)
}

// FeeOfERC20 is a free data retrieval call binding the contract method 0x488af871.
//
// Solidity: function feeOfERC20(address ) view returns(uint256)
func (_ExtBridge *ExtBridgeCallerSession) FeeOfERC20(arg0 common.Address) (*big.Int, error) {
	return _ExtBridge.Contract.FeeOfERC20(&_ExtBridge.CallOpts, arg0)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_ExtBridge *ExtBridgeCaller) FeeOfKLAY(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "feeOfKLAY")
	return *ret0, err
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_ExtBridge *ExtBridgeSession) FeeOfKLAY() (*big.Int, error) {
	return _ExtBridge.Contract.FeeOfKLAY(&_ExtBridge.CallOpts)
}

// FeeOfKLAY is a free data retrieval call binding the contract method 0xc263b5d6.
//
// Solidity: function feeOfKLAY() view returns(uint256)
func (_ExtBridge *ExtBridgeCallerSession) FeeOfKLAY() (*big.Int, error) {
	return _ExtBridge.Contract.FeeOfKLAY(&_ExtBridge.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_ExtBridge *ExtBridgeCaller) FeeReceiver(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "feeReceiver")
	return *ret0, err
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_ExtBridge *ExtBridgeSession) FeeReceiver() (common.Address, error) {
	return _ExtBridge.Contract.FeeReceiver(&_ExtBridge.CallOpts)
}

// FeeReceiver is a free data retrieval call binding the contract method 0xb3f00674.
//
// Solidity: function feeReceiver() view returns(address)
func (_ExtBridge *ExtBridgeCallerSession) FeeReceiver() (common.Address, error) {
	return _ExtBridge.Contract.FeeReceiver(&_ExtBridge.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_ExtBridge *ExtBridgeCaller) GetOperatorList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "getOperatorList")
	return *ret0, err
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_ExtBridge *ExtBridgeSession) GetOperatorList() ([]common.Address, error) {
	return _ExtBridge.Contract.GetOperatorList(&_ExtBridge.CallOpts)
}

// GetOperatorList is a free data retrieval call binding the contract method 0xb2c01030.
//
// Solidity: function getOperatorList() view returns(address[])
func (_ExtBridge *ExtBridgeCallerSession) GetOperatorList() ([]common.Address, error) {
	return _ExtBridge.Contract.GetOperatorList(&_ExtBridge.CallOpts)
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_ExtBridge *ExtBridgeCaller) GetRegisteredTokenList(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "getRegisteredTokenList")
	return *ret0, err
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_ExtBridge *ExtBridgeSession) GetRegisteredTokenList() ([]common.Address, error) {
	return _ExtBridge.Contract.GetRegisteredTokenList(&_ExtBridge.CallOpts)
}

// GetRegisteredTokenList is a free data retrieval call binding the contract method 0xea21eade.
//
// Solidity: function getRegisteredTokenList() view returns(address[])
func (_ExtBridge *ExtBridgeCallerSession) GetRegisteredTokenList() ([]common.Address, error) {
	return _ExtBridge.Contract.GetRegisteredTokenList(&_ExtBridge.CallOpts)
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_ExtBridge *ExtBridgeCaller) HandleNoncesToBlockNums(opts *bind.CallOpts, arg0 uint64) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "handleNoncesToBlockNums", arg0)
	return *ret0, err
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_ExtBridge *ExtBridgeSession) HandleNoncesToBlockNums(arg0 uint64) (uint64, error) {
	return _ExtBridge.Contract.HandleNoncesToBlockNums(&_ExtBridge.CallOpts, arg0)
}

// HandleNoncesToBlockNums is a free data retrieval call binding the contract method 0x13a6738a.
//
// Solidity: function handleNoncesToBlockNums(uint64 ) view returns(uint64)
func (_ExtBridge *ExtBridgeCallerSession) HandleNoncesToBlockNums(arg0 uint64) (uint64, error) {
	return _ExtBridge.Contract.HandleNoncesToBlockNums(&_ExtBridge.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_ExtBridge *ExtBridgeCaller) HandledRequestTx(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "handledRequestTx", arg0)
	return *ret0, err
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_ExtBridge *ExtBridgeSession) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _ExtBridge.Contract.HandledRequestTx(&_ExtBridge.CallOpts, arg0)
}

// HandledRequestTx is a free data retrieval call binding the contract method 0x8a75eee2.
//
// Solidity: function handledRequestTx(bytes32 ) view returns(bool)
func (_ExtBridge *ExtBridgeCallerSession) HandledRequestTx(arg0 [32]byte) (bool, error) {
	return _ExtBridge.Contract.HandledRequestTx(&_ExtBridge.CallOpts, arg0)
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_ExtBridge *ExtBridgeCaller) IndexOfTokens(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "indexOfTokens", arg0)
	return *ret0, err
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_ExtBridge *ExtBridgeSession) IndexOfTokens(arg0 common.Address) (*big.Int, error) {
	return _ExtBridge.Contract.IndexOfTokens(&_ExtBridge.CallOpts, arg0)
}

// IndexOfTokens is a free data retrieval call binding the contract method 0x48a18a6a.
//
// Solidity: function indexOfTokens(address ) view returns(uint256)
func (_ExtBridge *ExtBridgeCallerSession) IndexOfTokens(arg0 common.Address) (*big.Int, error) {
	return _ExtBridge.Contract.IndexOfTokens(&_ExtBridge.CallOpts, arg0)
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_ExtBridge *ExtBridgeCaller) IsRunning(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "isRunning")
	return *ret0, err
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_ExtBridge *ExtBridgeSession) IsRunning() (bool, error) {
	return _ExtBridge.Contract.IsRunning(&_ExtBridge.CallOpts)
}

// IsRunning is a free data retrieval call binding the contract method 0x2014e5d1.
//
// Solidity: function isRunning() view returns(bool)
func (_ExtBridge *ExtBridgeCallerSession) IsRunning() (bool, error) {
	return _ExtBridge.Contract.IsRunning(&_ExtBridge.CallOpts)
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_ExtBridge *ExtBridgeCaller) LockedTokens(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "lockedTokens", arg0)
	return *ret0, err
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_ExtBridge *ExtBridgeSession) LockedTokens(arg0 common.Address) (bool, error) {
	return _ExtBridge.Contract.LockedTokens(&_ExtBridge.CallOpts, arg0)
}

// LockedTokens is a free data retrieval call binding the contract method 0x5eb7413a.
//
// Solidity: function lockedTokens(address ) view returns(bool)
func (_ExtBridge *ExtBridgeCallerSession) LockedTokens(arg0 common.Address) (bool, error) {
	return _ExtBridge.Contract.LockedTokens(&_ExtBridge.CallOpts, arg0)
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeCaller) LowerHandleNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "lowerHandleNonce")
	return *ret0, err
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeSession) LowerHandleNonce() (uint64, error) {
	return _ExtBridge.Contract.LowerHandleNonce(&_ExtBridge.CallOpts)
}

// LowerHandleNonce is a free data retrieval call binding the contract method 0x4b40b826.
//
// Solidity: function lowerHandleNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeCallerSession) LowerHandleNonce() (uint64, error) {
	return _ExtBridge.Contract.LowerHandleNonce(&_ExtBridge.CallOpts)
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_ExtBridge *ExtBridgeCaller) ModeMintBurn(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "modeMintBurn")
	return *ret0, err
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_ExtBridge *ExtBridgeSession) ModeMintBurn() (bool, error) {
	return _ExtBridge.Contract.ModeMintBurn(&_ExtBridge.CallOpts)
}

// ModeMintBurn is a free data retrieval call binding the contract method 0x6e176ec2.
//
// Solidity: function modeMintBurn() view returns(bool)
func (_ExtBridge *ExtBridgeCallerSession) ModeMintBurn() (bool, error) {
	return _ExtBridge.Contract.ModeMintBurn(&_ExtBridge.CallOpts)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_ExtBridge *ExtBridgeCaller) OperatorList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "operatorList", arg0)
	return *ret0, err
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_ExtBridge *ExtBridgeSession) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _ExtBridge.Contract.OperatorList(&_ExtBridge.CallOpts, arg0)
}

// OperatorList is a free data retrieval call binding the contract method 0xcb38f407.
//
// Solidity: function operatorList(uint256 ) view returns(address)
func (_ExtBridge *ExtBridgeCallerSession) OperatorList(arg0 *big.Int) (common.Address, error) {
	return _ExtBridge.Contract.OperatorList(&_ExtBridge.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_ExtBridge *ExtBridgeCaller) OperatorThresholds(opts *bind.CallOpts, arg0 uint8) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "operatorThresholds", arg0)
	return *ret0, err
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_ExtBridge *ExtBridgeSession) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _ExtBridge.Contract.OperatorThresholds(&_ExtBridge.CallOpts, arg0)
}

// OperatorThresholds is a free data retrieval call binding the contract method 0x5526f76b.
//
// Solidity: function operatorThresholds(uint8 ) view returns(uint8)
func (_ExtBridge *ExtBridgeCallerSession) OperatorThresholds(arg0 uint8) (uint8, error) {
	return _ExtBridge.Contract.OperatorThresholds(&_ExtBridge.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_ExtBridge *ExtBridgeCaller) Operators(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "operators", arg0)
	return *ret0, err
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_ExtBridge *ExtBridgeSession) Operators(arg0 common.Address) (bool, error) {
	return _ExtBridge.Contract.Operators(&_ExtBridge.CallOpts, arg0)
}

// Operators is a free data retrieval call binding the contract method 0x13e7c9d8.
//
// Solidity: function operators(address ) view returns(bool)
func (_ExtBridge *ExtBridgeCallerSession) Operators(arg0 common.Address) (bool, error) {
	return _ExtBridge.Contract.Operators(&_ExtBridge.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExtBridge *ExtBridgeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExtBridge *ExtBridgeSession) Owner() (common.Address, error) {
	return _ExtBridge.Contract.Owner(&_ExtBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExtBridge *ExtBridgeCallerSession) Owner() (common.Address, error) {
	return _ExtBridge.Contract.Owner(&_ExtBridge.CallOpts)
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_ExtBridge *ExtBridgeCaller) RecoveryBlockNumber(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "recoveryBlockNumber")
	return *ret0, err
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_ExtBridge *ExtBridgeSession) RecoveryBlockNumber() (uint64, error) {
	return _ExtBridge.Contract.RecoveryBlockNumber(&_ExtBridge.CallOpts)
}

// RecoveryBlockNumber is a free data retrieval call binding the contract method 0x989ba0d3.
//
// Solidity: function recoveryBlockNumber() view returns(uint64)
func (_ExtBridge *ExtBridgeCallerSession) RecoveryBlockNumber() (uint64, error) {
	return _ExtBridge.Contract.RecoveryBlockNumber(&_ExtBridge.CallOpts)
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_ExtBridge *ExtBridgeCaller) RegisteredTokenList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "registeredTokenList", arg0)
	return *ret0, err
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_ExtBridge *ExtBridgeSession) RegisteredTokenList(arg0 *big.Int) (common.Address, error) {
	return _ExtBridge.Contract.RegisteredTokenList(&_ExtBridge.CallOpts, arg0)
}

// RegisteredTokenList is a free data retrieval call binding the contract method 0x3e4fe949.
//
// Solidity: function registeredTokenList(uint256 ) view returns(address)
func (_ExtBridge *ExtBridgeCallerSession) RegisteredTokenList(arg0 *big.Int) (common.Address, error) {
	return _ExtBridge.Contract.RegisteredTokenList(&_ExtBridge.CallOpts, arg0)
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_ExtBridge *ExtBridgeCaller) RegisteredTokens(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "registeredTokens", arg0)
	return *ret0, err
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_ExtBridge *ExtBridgeSession) RegisteredTokens(arg0 common.Address) (common.Address, error) {
	return _ExtBridge.Contract.RegisteredTokens(&_ExtBridge.CallOpts, arg0)
}

// RegisteredTokens is a free data retrieval call binding the contract method 0x8c0bd916.
//
// Solidity: function registeredTokens(address ) view returns(address)
func (_ExtBridge *ExtBridgeCallerSession) RegisteredTokens(arg0 common.Address) (common.Address, error) {
	return _ExtBridge.Contract.RegisteredTokens(&_ExtBridge.CallOpts, arg0)
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeCaller) RequestNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "requestNonce")
	return *ret0, err
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeSession) RequestNonce() (uint64, error) {
	return _ExtBridge.Contract.RequestNonce(&_ExtBridge.CallOpts)
}

// RequestNonce is a free data retrieval call binding the contract method 0x7c1a0302.
//
// Solidity: function requestNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeCallerSession) RequestNonce() (uint64, error) {
	return _ExtBridge.Contract.RequestNonce(&_ExtBridge.CallOpts)
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeCaller) UpperHandleNonce(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _ExtBridge.contract.Call(opts, out, "upperHandleNonce")
	return *ret0, err
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeSession) UpperHandleNonce() (uint64, error) {
	return _ExtBridge.Contract.UpperHandleNonce(&_ExtBridge.CallOpts)
}

// UpperHandleNonce is a free data retrieval call binding the contract method 0x54edad72.
//
// Solidity: function upperHandleNonce() view returns(uint64)
func (_ExtBridge *ExtBridgeCallerSession) UpperHandleNonce() (uint64, error) {
	return _ExtBridge.Contract.UpperHandleNonce(&_ExtBridge.CallOpts)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_ExtBridge *ExtBridgeTransactor) DeregisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "deregisterOperator", _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_ExtBridge *ExtBridgeSession) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.DeregisterOperator(&_ExtBridge.TransactOpts, _operator)
}

// DeregisterOperator is a paid mutator transaction binding the contract method 0xd8cf98ca.
//
// Solidity: function deregisterOperator(address _operator) returns()
func (_ExtBridge *ExtBridgeTransactorSession) DeregisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.DeregisterOperator(&_ExtBridge.TransactOpts, _operator)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_ExtBridge *ExtBridgeTransactor) DeregisterToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "deregisterToken", _token)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_ExtBridge *ExtBridgeSession) DeregisterToken(_token common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.DeregisterToken(&_ExtBridge.TransactOpts, _token)
}

// DeregisterToken is a paid mutator transaction binding the contract method 0xbab2af1d.
//
// Solidity: function deregisterToken(address _token) returns()
func (_ExtBridge *ExtBridgeTransactorSession) DeregisterToken(_token common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.DeregisterToken(&_ExtBridge.TransactOpts, _token)
}

// HandleERC20Transfer is a paid mutator transaction binding the contract method 0x407e6bae.
//
// Solidity: function handleERC20Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _value, uint64 _requestNonce, uint64 _requestBlockNumber, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactor) HandleERC20Transfer(opts *bind.TransactOpts, _requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _value *big.Int, _requestNonce uint64, _requestBlockNumber uint64, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "handleERC20Transfer", _requestTxHash, _from, _to, _tokenAddress, _value, _requestNonce, _requestBlockNumber, _extraData)
}

// HandleERC20Transfer is a paid mutator transaction binding the contract method 0x407e6bae.
//
// Solidity: function handleERC20Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _value, uint64 _requestNonce, uint64 _requestBlockNumber, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeSession) HandleERC20Transfer(_requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _value *big.Int, _requestNonce uint64, _requestBlockNumber uint64, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.HandleERC20Transfer(&_ExtBridge.TransactOpts, _requestTxHash, _from, _to, _tokenAddress, _value, _requestNonce, _requestBlockNumber, _extraData)
}

// HandleERC20Transfer is a paid mutator transaction binding the contract method 0x407e6bae.
//
// Solidity: function handleERC20Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _value, uint64 _requestNonce, uint64 _requestBlockNumber, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactorSession) HandleERC20Transfer(_requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _value *big.Int, _requestNonce uint64, _requestBlockNumber uint64, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.HandleERC20Transfer(&_ExtBridge.TransactOpts, _requestTxHash, _from, _to, _tokenAddress, _value, _requestNonce, _requestBlockNumber, _extraData)
}

// HandleERC721Transfer is a paid mutator transaction binding the contract method 0xafb60223.
//
// Solidity: function handleERC721Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _tokenId, uint64 _requestNonce, uint64 _requestBlockNumber, string _tokenURI, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactor) HandleERC721Transfer(opts *bind.TransactOpts, _requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _tokenId *big.Int, _requestNonce uint64, _requestBlockNumber uint64, _tokenURI string, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "handleERC721Transfer", _requestTxHash, _from, _to, _tokenAddress, _tokenId, _requestNonce, _requestBlockNumber, _tokenURI, _extraData)
}

// HandleERC721Transfer is a paid mutator transaction binding the contract method 0xafb60223.
//
// Solidity: function handleERC721Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _tokenId, uint64 _requestNonce, uint64 _requestBlockNumber, string _tokenURI, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeSession) HandleERC721Transfer(_requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _tokenId *big.Int, _requestNonce uint64, _requestBlockNumber uint64, _tokenURI string, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.HandleERC721Transfer(&_ExtBridge.TransactOpts, _requestTxHash, _from, _to, _tokenAddress, _tokenId, _requestNonce, _requestBlockNumber, _tokenURI, _extraData)
}

// HandleERC721Transfer is a paid mutator transaction binding the contract method 0xafb60223.
//
// Solidity: function handleERC721Transfer(bytes32 _requestTxHash, address _from, address _to, address _tokenAddress, uint256 _tokenId, uint64 _requestNonce, uint64 _requestBlockNumber, string _tokenURI, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactorSession) HandleERC721Transfer(_requestTxHash [32]byte, _from common.Address, _to common.Address, _tokenAddress common.Address, _tokenId *big.Int, _requestNonce uint64, _requestBlockNumber uint64, _tokenURI string, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.HandleERC721Transfer(&_ExtBridge.TransactOpts, _requestTxHash, _from, _to, _tokenAddress, _tokenId, _requestNonce, _requestBlockNumber, _tokenURI, _extraData)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_ExtBridge *ExtBridgeTransactor) LockToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "lockToken", _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_ExtBridge *ExtBridgeSession) LockToken(_token common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.LockToken(&_ExtBridge.TransactOpts, _token)
}

// LockToken is a paid mutator transaction binding the contract method 0x10693fcd.
//
// Solidity: function lockToken(address _token) returns()
func (_ExtBridge *ExtBridgeTransactorSession) LockToken(_token common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.LockToken(&_ExtBridge.TransactOpts, _token)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactor) OnERC20Received(opts *bind.TransactOpts, _from common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "onERC20Received", _from, _to, _value, _feeLimit, _extraData)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeSession) OnERC20Received(_from common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.OnERC20Received(&_ExtBridge.TransactOpts, _from, _to, _value, _feeLimit, _extraData)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactorSession) OnERC20Received(_from common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.OnERC20Received(&_ExtBridge.TransactOpts, _from, _to, _value, _feeLimit, _extraData)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactor) OnERC721Received(opts *bind.TransactOpts, _from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "onERC721Received", _from, _tokenId, _to, _extraData)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeSession) OnERC721Received(_from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.OnERC721Received(&_ExtBridge.TransactOpts, _from, _tokenId, _to, _extraData)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactorSession) OnERC721Received(_from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.OnERC721Received(&_ExtBridge.TransactOpts, _from, _tokenId, _to, _extraData)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_ExtBridge *ExtBridgeTransactor) RegisterOperator(opts *bind.TransactOpts, _operator common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "registerOperator", _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_ExtBridge *ExtBridgeSession) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.RegisterOperator(&_ExtBridge.TransactOpts, _operator)
}

// RegisterOperator is a paid mutator transaction binding the contract method 0x3682a450.
//
// Solidity: function registerOperator(address _operator) returns()
func (_ExtBridge *ExtBridgeTransactorSession) RegisterOperator(_operator common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.RegisterOperator(&_ExtBridge.TransactOpts, _operator)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_ExtBridge *ExtBridgeTransactor) RegisterToken(opts *bind.TransactOpts, _token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "registerToken", _token, _cToken)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_ExtBridge *ExtBridgeSession) RegisterToken(_token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.RegisterToken(&_ExtBridge.TransactOpts, _token, _cToken)
}

// RegisterToken is a paid mutator transaction binding the contract method 0x4739f7e5.
//
// Solidity: function registerToken(address _token, address _cToken) returns()
func (_ExtBridge *ExtBridgeTransactorSession) RegisterToken(_token common.Address, _cToken common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.RegisterToken(&_ExtBridge.TransactOpts, _token, _cToken)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExtBridge *ExtBridgeTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExtBridge *ExtBridgeSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExtBridge.Contract.RenounceOwnership(&_ExtBridge.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExtBridge *ExtBridgeTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExtBridge.Contract.RenounceOwnership(&_ExtBridge.TransactOpts)
}

// RequestERC20Transfer is a paid mutator transaction binding the contract method 0x26c23b54.
//
// Solidity: function requestERC20Transfer(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactor) RequestERC20Transfer(opts *bind.TransactOpts, _tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "requestERC20Transfer", _tokenAddress, _to, _value, _feeLimit, _extraData)
}

// RequestERC20Transfer is a paid mutator transaction binding the contract method 0x26c23b54.
//
// Solidity: function requestERC20Transfer(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeSession) RequestERC20Transfer(_tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.RequestERC20Transfer(&_ExtBridge.TransactOpts, _tokenAddress, _to, _value, _feeLimit, _extraData)
}

// RequestERC20Transfer is a paid mutator transaction binding the contract method 0x26c23b54.
//
// Solidity: function requestERC20Transfer(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactorSession) RequestERC20Transfer(_tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.RequestERC20Transfer(&_ExtBridge.TransactOpts, _tokenAddress, _to, _value, _feeLimit, _extraData)
}

// RequestERC721Transfer is a paid mutator transaction binding the contract method 0x22604742.
//
// Solidity: function requestERC721Transfer(address _tokenAddress, address _to, uint256 _tokenId, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactor) RequestERC721Transfer(opts *bind.TransactOpts, _tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "requestERC721Transfer", _tokenAddress, _to, _tokenId, _extraData)
}

// RequestERC721Transfer is a paid mutator transaction binding the contract method 0x22604742.
//
// Solidity: function requestERC721Transfer(address _tokenAddress, address _to, uint256 _tokenId, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeSession) RequestERC721Transfer(_tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.RequestERC721Transfer(&_ExtBridge.TransactOpts, _tokenAddress, _to, _tokenId, _extraData)
}

// RequestERC721Transfer is a paid mutator transaction binding the contract method 0x22604742.
//
// Solidity: function requestERC721Transfer(address _tokenAddress, address _to, uint256 _tokenId, bytes _extraData) returns()
func (_ExtBridge *ExtBridgeTransactorSession) RequestERC721Transfer(_tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _ExtBridge.Contract.RequestERC721Transfer(&_ExtBridge.TransactOpts, _tokenAddress, _to, _tokenId, _extraData)
}

// RequestSellERC20 is a paid mutator transaction binding the contract method 0xc5e49073.
//
// Solidity: function requestSellERC20(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, uint256 _price) returns()
func (_ExtBridge *ExtBridgeTransactor) RequestSellERC20(opts *bind.TransactOpts, _tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _price *big.Int) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "requestSellERC20", _tokenAddress, _to, _value, _feeLimit, _price)
}

// RequestSellERC20 is a paid mutator transaction binding the contract method 0xc5e49073.
//
// Solidity: function requestSellERC20(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, uint256 _price) returns()
func (_ExtBridge *ExtBridgeSession) RequestSellERC20(_tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _price *big.Int) (*types.Transaction, error) {
	return _ExtBridge.Contract.RequestSellERC20(&_ExtBridge.TransactOpts, _tokenAddress, _to, _value, _feeLimit, _price)
}

// RequestSellERC20 is a paid mutator transaction binding the contract method 0xc5e49073.
//
// Solidity: function requestSellERC20(address _tokenAddress, address _to, uint256 _value, uint256 _feeLimit, uint256 _price) returns()
func (_ExtBridge *ExtBridgeTransactorSession) RequestSellERC20(_tokenAddress common.Address, _to common.Address, _value *big.Int, _feeLimit *big.Int, _price *big.Int) (*types.Transaction, error) {
	return _ExtBridge.Contract.RequestSellERC20(&_ExtBridge.TransactOpts, _tokenAddress, _to, _value, _feeLimit, _price)
}

// RequestSellERC721 is a paid mutator transaction binding the contract method 0x4c5146f5.
//
// Solidity: function requestSellERC721(address _tokenAddress, address _to, uint256 _tokenId, uint256 _price) returns()
func (_ExtBridge *ExtBridgeTransactor) RequestSellERC721(opts *bind.TransactOpts, _tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _price *big.Int) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "requestSellERC721", _tokenAddress, _to, _tokenId, _price)
}

// RequestSellERC721 is a paid mutator transaction binding the contract method 0x4c5146f5.
//
// Solidity: function requestSellERC721(address _tokenAddress, address _to, uint256 _tokenId, uint256 _price) returns()
func (_ExtBridge *ExtBridgeSession) RequestSellERC721(_tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _price *big.Int) (*types.Transaction, error) {
	return _ExtBridge.Contract.RequestSellERC721(&_ExtBridge.TransactOpts, _tokenAddress, _to, _tokenId, _price)
}

// RequestSellERC721 is a paid mutator transaction binding the contract method 0x4c5146f5.
//
// Solidity: function requestSellERC721(address _tokenAddress, address _to, uint256 _tokenId, uint256 _price) returns()
func (_ExtBridge *ExtBridgeTransactorSession) RequestSellERC721(_tokenAddress common.Address, _to common.Address, _tokenId *big.Int, _price *big.Int) (*types.Transaction, error) {
	return _ExtBridge.Contract.RequestSellERC721(&_ExtBridge.TransactOpts, _tokenAddress, _to, _tokenId, _price)
}

// SetCallback is a paid mutator transaction binding the contract method 0x8daa63ac.
//
// Solidity: function setCallback(address _addr) returns()
func (_ExtBridge *ExtBridgeTransactor) SetCallback(opts *bind.TransactOpts, _addr common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "setCallback", _addr)
}

// SetCallback is a paid mutator transaction binding the contract method 0x8daa63ac.
//
// Solidity: function setCallback(address _addr) returns()
func (_ExtBridge *ExtBridgeSession) SetCallback(_addr common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.SetCallback(&_ExtBridge.TransactOpts, _addr)
}

// SetCallback is a paid mutator transaction binding the contract method 0x8daa63ac.
//
// Solidity: function setCallback(address _addr) returns()
func (_ExtBridge *ExtBridgeTransactorSession) SetCallback(_addr common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.SetCallback(&_ExtBridge.TransactOpts, _addr)
}

// SetERC20Fee is a paid mutator transaction binding the contract method 0x2f88396c.
//
// Solidity: function setERC20Fee(address _token, uint256 _fee, uint64 _requestNonce) returns()
func (_ExtBridge *ExtBridgeTransactor) SetERC20Fee(opts *bind.TransactOpts, _token common.Address, _fee *big.Int, _requestNonce uint64) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "setERC20Fee", _token, _fee, _requestNonce)
}

// SetERC20Fee is a paid mutator transaction binding the contract method 0x2f88396c.
//
// Solidity: function setERC20Fee(address _token, uint256 _fee, uint64 _requestNonce) returns()
func (_ExtBridge *ExtBridgeSession) SetERC20Fee(_token common.Address, _fee *big.Int, _requestNonce uint64) (*types.Transaction, error) {
	return _ExtBridge.Contract.SetERC20Fee(&_ExtBridge.TransactOpts, _token, _fee, _requestNonce)
}

// SetERC20Fee is a paid mutator transaction binding the contract method 0x2f88396c.
//
// Solidity: function setERC20Fee(address _token, uint256 _fee, uint64 _requestNonce) returns()
func (_ExtBridge *ExtBridgeTransactorSession) SetERC20Fee(_token common.Address, _fee *big.Int, _requestNonce uint64) (*types.Transaction, error) {
	return _ExtBridge.Contract.SetERC20Fee(&_ExtBridge.TransactOpts, _token, _fee, _requestNonce)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_ExtBridge *ExtBridgeTransactor) SetFeeReceiver(opts *bind.TransactOpts, _feeReceiver common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "setFeeReceiver", _feeReceiver)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_ExtBridge *ExtBridgeSession) SetFeeReceiver(_feeReceiver common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.SetFeeReceiver(&_ExtBridge.TransactOpts, _feeReceiver)
}

// SetFeeReceiver is a paid mutator transaction binding the contract method 0xefdcd974.
//
// Solidity: function setFeeReceiver(address _feeReceiver) returns()
func (_ExtBridge *ExtBridgeTransactorSession) SetFeeReceiver(_feeReceiver common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.SetFeeReceiver(&_ExtBridge.TransactOpts, _feeReceiver)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_ExtBridge *ExtBridgeTransactor) SetOperatorThreshold(opts *bind.TransactOpts, _voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "setOperatorThreshold", _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_ExtBridge *ExtBridgeSession) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _ExtBridge.Contract.SetOperatorThreshold(&_ExtBridge.TransactOpts, _voteType, _threshold)
}

// SetOperatorThreshold is a paid mutator transaction binding the contract method 0xee2aec65.
//
// Solidity: function setOperatorThreshold(uint8 _voteType, uint8 _threshold) returns()
func (_ExtBridge *ExtBridgeTransactorSession) SetOperatorThreshold(_voteType uint8, _threshold uint8) (*types.Transaction, error) {
	return _ExtBridge.Contract.SetOperatorThreshold(&_ExtBridge.TransactOpts, _voteType, _threshold)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_ExtBridge *ExtBridgeTransactor) Start(opts *bind.TransactOpts, _status bool) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "start", _status)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_ExtBridge *ExtBridgeSession) Start(_status bool) (*types.Transaction, error) {
	return _ExtBridge.Contract.Start(&_ExtBridge.TransactOpts, _status)
}

// Start is a paid mutator transaction binding the contract method 0xc877cf37.
//
// Solidity: function start(bool _status) returns()
func (_ExtBridge *ExtBridgeTransactorSession) Start(_status bool) (*types.Transaction, error) {
	return _ExtBridge.Contract.Start(&_ExtBridge.TransactOpts, _status)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExtBridge *ExtBridgeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExtBridge *ExtBridgeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.TransferOwnership(&_ExtBridge.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExtBridge *ExtBridgeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.TransferOwnership(&_ExtBridge.TransactOpts, newOwner)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_ExtBridge *ExtBridgeTransactor) UnlockToken(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _ExtBridge.contract.Transact(opts, "unlockToken", _token)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_ExtBridge *ExtBridgeSession) UnlockToken(_token common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.UnlockToken(&_ExtBridge.TransactOpts, _token)
}

// UnlockToken is a paid mutator transaction binding the contract method 0x9ef2017b.
//
// Solidity: function unlockToken(address _token) returns()
func (_ExtBridge *ExtBridgeTransactorSession) UnlockToken(_token common.Address) (*types.Transaction, error) {
	return _ExtBridge.Contract.UnlockToken(&_ExtBridge.TransactOpts, _token)
}

// ExtBridgeERC20FeeChangedIterator is returned from FilterERC20FeeChanged and is used to iterate over the raw logs and unpacked data for ERC20FeeChanged events raised by the ExtBridge contract.
type ExtBridgeERC20FeeChangedIterator struct {
	Event *ExtBridgeERC20FeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeERC20FeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeERC20FeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeERC20FeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeERC20FeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeERC20FeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeERC20FeeChanged represents a ERC20FeeChanged event raised by the ExtBridge contract.
type ExtBridgeERC20FeeChanged struct {
	Token common.Address
	Fee   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterERC20FeeChanged is a free log retrieval operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_ExtBridge *ExtBridgeFilterer) FilterERC20FeeChanged(opts *bind.FilterOpts, token []common.Address, fee []*big.Int) (*ExtBridgeERC20FeeChangedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeERC20FeeChangedIterator{contract: _ExtBridge.contract, event: "ERC20FeeChanged", logs: logs, sub: sub}, nil
}

// WatchERC20FeeChanged is a free log subscription operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_ExtBridge *ExtBridgeFilterer) WatchERC20FeeChanged(opts *bind.WatchOpts, sink chan<- *ExtBridgeERC20FeeChanged, token []common.Address, fee []*big.Int) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "ERC20FeeChanged", tokenRule, feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeERC20FeeChanged)
				if err := _ExtBridge.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20FeeChanged is a log parse operation binding the contract event 0xdb5ad2e76ae20cfa4e7adbc7305d7538442164d85ead9937c98620a1aa4c255b.
//
// Solidity: event ERC20FeeChanged(address indexed token, uint256 indexed fee)
func (_ExtBridge *ExtBridgeFilterer) ParseERC20FeeChanged(log types.Log) (*ExtBridgeERC20FeeChanged, error) {
	event := new(ExtBridgeERC20FeeChanged)
	if err := _ExtBridge.contract.UnpackLog(event, "ERC20FeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeFeeReceiverChangedIterator is returned from FilterFeeReceiverChanged and is used to iterate over the raw logs and unpacked data for FeeReceiverChanged events raised by the ExtBridge contract.
type ExtBridgeFeeReceiverChangedIterator struct {
	Event *ExtBridgeFeeReceiverChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeFeeReceiverChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeFeeReceiverChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeFeeReceiverChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeFeeReceiverChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeFeeReceiverChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeFeeReceiverChanged represents a FeeReceiverChanged event raised by the ExtBridge contract.
type ExtBridgeFeeReceiverChanged struct {
	FeeReceiver common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterFeeReceiverChanged is a free log retrieval operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_ExtBridge *ExtBridgeFilterer) FilterFeeReceiverChanged(opts *bind.FilterOpts, feeReceiver []common.Address) (*ExtBridgeFeeReceiverChangedIterator, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeFeeReceiverChangedIterator{contract: _ExtBridge.contract, event: "FeeReceiverChanged", logs: logs, sub: sub}, nil
}

// WatchFeeReceiverChanged is a free log subscription operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_ExtBridge *ExtBridgeFilterer) WatchFeeReceiverChanged(opts *bind.WatchOpts, sink chan<- *ExtBridgeFeeReceiverChanged, feeReceiver []common.Address) (event.Subscription, error) {

	var feeReceiverRule []interface{}
	for _, feeReceiverItem := range feeReceiver {
		feeReceiverRule = append(feeReceiverRule, feeReceiverItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "FeeReceiverChanged", feeReceiverRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeFeeReceiverChanged)
				if err := _ExtBridge.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeReceiverChanged is a log parse operation binding the contract event 0x647672599d3468abcfa241a13c9e3d34383caadb5cc80fb67c3cdfcd5f786059.
//
// Solidity: event FeeReceiverChanged(address indexed feeReceiver)
func (_ExtBridge *ExtBridgeFilterer) ParseFeeReceiverChanged(log types.Log) (*ExtBridgeFeeReceiverChanged, error) {
	event := new(ExtBridgeFeeReceiverChanged)
	if err := _ExtBridge.contract.UnpackLog(event, "FeeReceiverChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeHandleValueTransferIterator is returned from FilterHandleValueTransfer and is used to iterate over the raw logs and unpacked data for HandleValueTransfer events raised by the ExtBridge contract.
type ExtBridgeHandleValueTransferIterator struct {
	Event *ExtBridgeHandleValueTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeHandleValueTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeHandleValueTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeHandleValueTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeHandleValueTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeHandleValueTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeHandleValueTransfer represents a HandleValueTransfer event raised by the ExtBridge contract.
type ExtBridgeHandleValueTransfer struct {
	RequestTxHash    [32]byte
	TokenType        uint8
	From             common.Address
	To               common.Address
	TokenAddress     common.Address
	ValueOrTokenId   *big.Int
	HandleNonce      uint64
	LowerHandleNonce uint64
	ExtraData        []byte
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterHandleValueTransfer is a free log retrieval operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_ExtBridge *ExtBridgeFilterer) FilterHandleValueTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*ExtBridgeHandleValueTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "HandleValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeHandleValueTransferIterator{contract: _ExtBridge.contract, event: "HandleValueTransfer", logs: logs, sub: sub}, nil
}

// WatchHandleValueTransfer is a free log subscription operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_ExtBridge *ExtBridgeFilterer) WatchHandleValueTransfer(opts *bind.WatchOpts, sink chan<- *ExtBridgeHandleValueTransfer, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "HandleValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeHandleValueTransfer)
				if err := _ExtBridge.contract.UnpackLog(event, "HandleValueTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseHandleValueTransfer is a log parse operation binding the contract event 0x12b02f226d965a2881e0e8ffed6c421803a22d57ad91f9ef996fe0748ea10175.
//
// Solidity: event HandleValueTransfer(bytes32 requestTxHash, uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 handleNonce, uint64 lowerHandleNonce, bytes extraData)
func (_ExtBridge *ExtBridgeFilterer) ParseHandleValueTransfer(log types.Log) (*ExtBridgeHandleValueTransfer, error) {
	event := new(ExtBridgeHandleValueTransfer)
	if err := _ExtBridge.contract.UnpackLog(event, "HandleValueTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeKLAYFeeChangedIterator is returned from FilterKLAYFeeChanged and is used to iterate over the raw logs and unpacked data for KLAYFeeChanged events raised by the ExtBridge contract.
type ExtBridgeKLAYFeeChangedIterator struct {
	Event *ExtBridgeKLAYFeeChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeKLAYFeeChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeKLAYFeeChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeKLAYFeeChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeKLAYFeeChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeKLAYFeeChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeKLAYFeeChanged represents a KLAYFeeChanged event raised by the ExtBridge contract.
type ExtBridgeKLAYFeeChanged struct {
	Fee *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterKLAYFeeChanged is a free log retrieval operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_ExtBridge *ExtBridgeFilterer) FilterKLAYFeeChanged(opts *bind.FilterOpts, fee []*big.Int) (*ExtBridgeKLAYFeeChangedIterator, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeKLAYFeeChangedIterator{contract: _ExtBridge.contract, event: "KLAYFeeChanged", logs: logs, sub: sub}, nil
}

// WatchKLAYFeeChanged is a free log subscription operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_ExtBridge *ExtBridgeFilterer) WatchKLAYFeeChanged(opts *bind.WatchOpts, sink chan<- *ExtBridgeKLAYFeeChanged, fee []*big.Int) (event.Subscription, error) {

	var feeRule []interface{}
	for _, feeItem := range fee {
		feeRule = append(feeRule, feeItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "KLAYFeeChanged", feeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeKLAYFeeChanged)
				if err := _ExtBridge.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseKLAYFeeChanged is a log parse operation binding the contract event 0xa7a33d0996347e1aa55ca2206015b61b9534bdd881d59d59aa680e25eefac365.
//
// Solidity: event KLAYFeeChanged(uint256 indexed fee)
func (_ExtBridge *ExtBridgeFilterer) ParseKLAYFeeChanged(log types.Log) (*ExtBridgeKLAYFeeChanged, error) {
	event := new(ExtBridgeKLAYFeeChanged)
	if err := _ExtBridge.contract.UnpackLog(event, "KLAYFeeChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the ExtBridge contract.
type ExtBridgeOwnershipTransferredIterator struct {
	Event *ExtBridgeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeOwnershipTransferred represents a OwnershipTransferred event raised by the ExtBridge contract.
type ExtBridgeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExtBridge *ExtBridgeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*ExtBridgeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeOwnershipTransferredIterator{contract: _ExtBridge.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExtBridge *ExtBridgeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *ExtBridgeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeOwnershipTransferred)
				if err := _ExtBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExtBridge *ExtBridgeFilterer) ParseOwnershipTransferred(log types.Log) (*ExtBridgeOwnershipTransferred, error) {
	event := new(ExtBridgeOwnershipTransferred)
	if err := _ExtBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeRequestValueTransferIterator is returned from FilterRequestValueTransfer and is used to iterate over the raw logs and unpacked data for RequestValueTransfer events raised by the ExtBridge contract.
type ExtBridgeRequestValueTransferIterator struct {
	Event *ExtBridgeRequestValueTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeRequestValueTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeRequestValueTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeRequestValueTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeRequestValueTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeRequestValueTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeRequestValueTransfer represents a RequestValueTransfer event raised by the ExtBridge contract.
type ExtBridgeRequestValueTransfer struct {
	TokenType      uint8
	From           common.Address
	To             common.Address
	TokenAddress   common.Address
	ValueOrTokenId *big.Int
	RequestNonce   uint64
	Fee            *big.Int
	ExtraData      []byte
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterRequestValueTransfer is a free log retrieval operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_ExtBridge *ExtBridgeFilterer) FilterRequestValueTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*ExtBridgeRequestValueTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "RequestValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeRequestValueTransferIterator{contract: _ExtBridge.contract, event: "RequestValueTransfer", logs: logs, sub: sub}, nil
}

// WatchRequestValueTransfer is a free log subscription operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_ExtBridge *ExtBridgeFilterer) WatchRequestValueTransfer(opts *bind.WatchOpts, sink chan<- *ExtBridgeRequestValueTransfer, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "RequestValueTransfer", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeRequestValueTransfer)
				if err := _ExtBridge.contract.UnpackLog(event, "RequestValueTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestValueTransfer is a log parse operation binding the contract event 0xeff76c36e53fa5ff52f27acc8a34d5047a8246abb07b77b12f1309f71e337f09.
//
// Solidity: event RequestValueTransfer(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData)
func (_ExtBridge *ExtBridgeFilterer) ParseRequestValueTransfer(log types.Log) (*ExtBridgeRequestValueTransfer, error) {
	event := new(ExtBridgeRequestValueTransfer)
	if err := _ExtBridge.contract.UnpackLog(event, "RequestValueTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeRequestValueTransferEncodedIterator is returned from FilterRequestValueTransferEncoded and is used to iterate over the raw logs and unpacked data for RequestValueTransferEncoded events raised by the ExtBridge contract.
type ExtBridgeRequestValueTransferEncodedIterator struct {
	Event *ExtBridgeRequestValueTransferEncoded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeRequestValueTransferEncodedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeRequestValueTransferEncoded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeRequestValueTransferEncoded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeRequestValueTransferEncodedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeRequestValueTransferEncodedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeRequestValueTransferEncoded represents a RequestValueTransferEncoded event raised by the ExtBridge contract.
type ExtBridgeRequestValueTransferEncoded struct {
	TokenType      uint8
	From           common.Address
	To             common.Address
	TokenAddress   common.Address
	ValueOrTokenId *big.Int
	RequestNonce   uint64
	Fee            *big.Int
	ExtraData      []byte
	EncodingVer    uint8
	EncodedData    []byte
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterRequestValueTransferEncoded is a free log retrieval operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_ExtBridge *ExtBridgeFilterer) FilterRequestValueTransferEncoded(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenAddress []common.Address) (*ExtBridgeRequestValueTransferEncodedIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "RequestValueTransferEncoded", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeRequestValueTransferEncodedIterator{contract: _ExtBridge.contract, event: "RequestValueTransferEncoded", logs: logs, sub: sub}, nil
}

// WatchRequestValueTransferEncoded is a free log subscription operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_ExtBridge *ExtBridgeFilterer) WatchRequestValueTransferEncoded(opts *bind.WatchOpts, sink chan<- *ExtBridgeRequestValueTransferEncoded, from []common.Address, to []common.Address, tokenAddress []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "RequestValueTransferEncoded", fromRule, toRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeRequestValueTransferEncoded)
				if err := _ExtBridge.contract.UnpackLog(event, "RequestValueTransferEncoded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestValueTransferEncoded is a log parse operation binding the contract event 0x17d76053ca34a4dd8c402fe6498deb797fac89bf7ed02f3f5161aa9368cc8c1f.
//
// Solidity: event RequestValueTransferEncoded(uint8 tokenType, address indexed from, address indexed to, address indexed tokenAddress, uint256 valueOrTokenId, uint64 requestNonce, uint256 fee, bytes extraData, uint8 encodingVer, bytes encodedData)
func (_ExtBridge *ExtBridgeFilterer) ParseRequestValueTransferEncoded(log types.Log) (*ExtBridgeRequestValueTransferEncoded, error) {
	event := new(ExtBridgeRequestValueTransferEncoded)
	if err := _ExtBridge.contract.UnpackLog(event, "RequestValueTransferEncoded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeTokenDeregisteredIterator is returned from FilterTokenDeregistered and is used to iterate over the raw logs and unpacked data for TokenDeregistered events raised by the ExtBridge contract.
type ExtBridgeTokenDeregisteredIterator struct {
	Event *ExtBridgeTokenDeregistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeTokenDeregisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeTokenDeregistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeTokenDeregistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeTokenDeregisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeTokenDeregisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeTokenDeregistered represents a TokenDeregistered event raised by the ExtBridge contract.
type ExtBridgeTokenDeregistered struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenDeregistered is a free log retrieval operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) FilterTokenDeregistered(opts *bind.FilterOpts, token []common.Address) (*ExtBridgeTokenDeregisteredIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "TokenDeregistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeTokenDeregisteredIterator{contract: _ExtBridge.contract, event: "TokenDeregistered", logs: logs, sub: sub}, nil
}

// WatchTokenDeregistered is a free log subscription operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) WatchTokenDeregistered(opts *bind.WatchOpts, sink chan<- *ExtBridgeTokenDeregistered, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "TokenDeregistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeTokenDeregistered)
				if err := _ExtBridge.contract.UnpackLog(event, "TokenDeregistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenDeregistered is a log parse operation binding the contract event 0x1d735ca20b63676dde668b718be78606b061d6bd7534ff815a90a121a6c084b6.
//
// Solidity: event TokenDeregistered(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) ParseTokenDeregistered(log types.Log) (*ExtBridgeTokenDeregistered, error) {
	event := new(ExtBridgeTokenDeregistered)
	if err := _ExtBridge.contract.UnpackLog(event, "TokenDeregistered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeTokenLockedIterator is returned from FilterTokenLocked and is used to iterate over the raw logs and unpacked data for TokenLocked events raised by the ExtBridge contract.
type ExtBridgeTokenLockedIterator struct {
	Event *ExtBridgeTokenLocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeTokenLockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeTokenLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeTokenLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeTokenLockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeTokenLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeTokenLocked represents a TokenLocked event raised by the ExtBridge contract.
type ExtBridgeTokenLocked struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenLocked is a free log retrieval operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) FilterTokenLocked(opts *bind.FilterOpts, token []common.Address) (*ExtBridgeTokenLockedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "TokenLocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeTokenLockedIterator{contract: _ExtBridge.contract, event: "TokenLocked", logs: logs, sub: sub}, nil
}

// WatchTokenLocked is a free log subscription operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) WatchTokenLocked(opts *bind.WatchOpts, sink chan<- *ExtBridgeTokenLocked, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "TokenLocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeTokenLocked)
				if err := _ExtBridge.contract.UnpackLog(event, "TokenLocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenLocked is a log parse operation binding the contract event 0xca1b0a14e18ada4c44846768dd186e35630cdc5cfeaca83c404ae4acaafbecd7.
//
// Solidity: event TokenLocked(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) ParseTokenLocked(log types.Log) (*ExtBridgeTokenLocked, error) {
	event := new(ExtBridgeTokenLocked)
	if err := _ExtBridge.contract.UnpackLog(event, "TokenLocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeTokenRegisteredIterator is returned from FilterTokenRegistered and is used to iterate over the raw logs and unpacked data for TokenRegistered events raised by the ExtBridge contract.
type ExtBridgeTokenRegisteredIterator struct {
	Event *ExtBridgeTokenRegistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeTokenRegisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeTokenRegistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeTokenRegistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeTokenRegisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeTokenRegisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeTokenRegistered represents a TokenRegistered event raised by the ExtBridge contract.
type ExtBridgeTokenRegistered struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenRegistered is a free log retrieval operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) FilterTokenRegistered(opts *bind.FilterOpts, token []common.Address) (*ExtBridgeTokenRegisteredIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "TokenRegistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeTokenRegisteredIterator{contract: _ExtBridge.contract, event: "TokenRegistered", logs: logs, sub: sub}, nil
}

// WatchTokenRegistered is a free log subscription operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) WatchTokenRegistered(opts *bind.WatchOpts, sink chan<- *ExtBridgeTokenRegistered, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "TokenRegistered", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeTokenRegistered)
				if err := _ExtBridge.contract.UnpackLog(event, "TokenRegistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenRegistered is a log parse operation binding the contract event 0x158412daecdc1456d01568828bcdb18464cc7f1ce0215ddbc3f3cfede9d1e63d.
//
// Solidity: event TokenRegistered(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) ParseTokenRegistered(log types.Log) (*ExtBridgeTokenRegistered, error) {
	event := new(ExtBridgeTokenRegistered)
	if err := _ExtBridge.contract.UnpackLog(event, "TokenRegistered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ExtBridgeTokenUnlockedIterator is returned from FilterTokenUnlocked and is used to iterate over the raw logs and unpacked data for TokenUnlocked events raised by the ExtBridge contract.
type ExtBridgeTokenUnlockedIterator struct {
	Event *ExtBridgeTokenUnlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExtBridgeTokenUnlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExtBridgeTokenUnlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExtBridgeTokenUnlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExtBridgeTokenUnlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExtBridgeTokenUnlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExtBridgeTokenUnlocked represents a TokenUnlocked event raised by the ExtBridge contract.
type ExtBridgeTokenUnlocked struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTokenUnlocked is a free log retrieval operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) FilterTokenUnlocked(opts *bind.FilterOpts, token []common.Address) (*ExtBridgeTokenUnlockedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _ExtBridge.contract.FilterLogs(opts, "TokenUnlocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return &ExtBridgeTokenUnlockedIterator{contract: _ExtBridge.contract, event: "TokenUnlocked", logs: logs, sub: sub}, nil
}

// WatchTokenUnlocked is a free log subscription operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) WatchTokenUnlocked(opts *bind.WatchOpts, sink chan<- *ExtBridgeTokenUnlocked, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _ExtBridge.contract.WatchLogs(opts, "TokenUnlocked", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExtBridgeTokenUnlocked)
				if err := _ExtBridge.contract.UnpackLog(event, "TokenUnlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenUnlocked is a log parse operation binding the contract event 0x81ec08d3372506e176c49e626d8beb7e091712ef92908a130f4ccc6524fe2eec.
//
// Solidity: event TokenUnlocked(address indexed token)
func (_ExtBridge *ExtBridgeFilterer) ParseTokenUnlocked(log types.Log) (*ExtBridgeTokenUnlocked, error) {
	event := new(ExtBridgeTokenUnlocked)
	if err := _ExtBridge.contract.UnpackLog(event, "TokenUnlocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC165ABI is the input ABI used to generate the binding from.
const IERC165ABI = "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// IERC165BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC165BinRuntime = ``

// IERC165FuncSigs maps the 4-byte function signature to its string representation.
var IERC165FuncSigs = map[string]string{
	"01ffc9a7": "supportsInterface(bytes4)",
}

// IERC165 is an auto generated Go binding around a Klaytn contract.
type IERC165 struct {
	IERC165Caller     // Read-only binding to the contract
	IERC165Transactor // Write-only binding to the contract
	IERC165Filterer   // Log filterer for contract events
}

// IERC165Caller is an auto generated read-only Go binding around a Klaytn contract.
type IERC165Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Transactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC165Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Filterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC165Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Session is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC165Session struct {
	Contract     *IERC165          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC165CallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC165CallerSession struct {
	Contract *IERC165Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// IERC165TransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC165TransactorSession struct {
	Contract     *IERC165Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IERC165Raw is an auto generated low-level Go binding around a Klaytn contract.
type IERC165Raw struct {
	Contract *IERC165 // Generic contract binding to access the raw methods on
}

// IERC165CallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC165CallerRaw struct {
	Contract *IERC165Caller // Generic read-only contract binding to access the raw methods on
}

// IERC165TransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC165TransactorRaw struct {
	Contract *IERC165Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC165 creates a new instance of IERC165, bound to a specific deployed contract.
func NewIERC165(address common.Address, backend bind.ContractBackend) (*IERC165, error) {
	contract, err := bindIERC165(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC165{IERC165Caller: IERC165Caller{contract: contract}, IERC165Transactor: IERC165Transactor{contract: contract}, IERC165Filterer: IERC165Filterer{contract: contract}}, nil
}

// NewIERC165Caller creates a new read-only instance of IERC165, bound to a specific deployed contract.
func NewIERC165Caller(address common.Address, caller bind.ContractCaller) (*IERC165Caller, error) {
	contract, err := bindIERC165(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC165Caller{contract: contract}, nil
}

// NewIERC165Transactor creates a new write-only instance of IERC165, bound to a specific deployed contract.
func NewIERC165Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC165Transactor, error) {
	contract, err := bindIERC165(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC165Transactor{contract: contract}, nil
}

// NewIERC165Filterer creates a new log filterer instance of IERC165, bound to a specific deployed contract.
func NewIERC165Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC165Filterer, error) {
	contract, err := bindIERC165(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC165Filterer{contract: contract}, nil
}

// bindIERC165 binds a generic wrapper to an already deployed contract.
func bindIERC165(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC165ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC165 *IERC165Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC165.Contract.IERC165Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC165 *IERC165Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC165.Contract.IERC165Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC165 *IERC165Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC165.Contract.IERC165Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC165 *IERC165CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC165.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC165 *IERC165TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC165.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC165 *IERC165TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC165.Contract.contract.Transact(opts, method, params...)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _IERC165.contract.Call(opts, out, "supportsInterface", interfaceId)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC165.Contract.SupportsInterface(&_IERC165.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC165.Contract.SupportsInterface(&_IERC165.CallOpts, interfaceId)
}

// IERC20ABI is the input ABI used to generate the binding from.
const IERC20ABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC20BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC20BinRuntime = ``

// IERC20FuncSigs maps the 4-byte function signature to its string representation.
var IERC20FuncSigs = map[string]string{
	"dd62ed3e": "allowance(address,address)",
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"18160ddd": "totalSupply()",
	"a9059cbb": "transfer(address,uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// IERC20 is an auto generated Go binding around a Klaytn contract.
type IERC20 struct {
	IERC20Caller     // Read-only binding to the contract
	IERC20Transactor // Write-only binding to the contract
	IERC20Filterer   // Log filterer for contract events
}

// IERC20Caller is an auto generated read-only Go binding around a Klaytn contract.
type IERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Transactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Filterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Session is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC20Session struct {
	Contract     *IERC20           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20CallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC20CallerSession struct {
	Contract *IERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IERC20TransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC20TransactorSession struct {
	Contract     *IERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20Raw is an auto generated low-level Go binding around a Klaytn contract.
type IERC20Raw struct {
	Contract *IERC20 // Generic contract binding to access the raw methods on
}

// IERC20CallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC20CallerRaw struct {
	Contract *IERC20Caller // Generic read-only contract binding to access the raw methods on
}

// IERC20TransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC20TransactorRaw struct {
	Contract *IERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20 creates a new instance of IERC20, bound to a specific deployed contract.
func NewIERC20(address common.Address, backend bind.ContractBackend) (*IERC20, error) {
	contract, err := bindIERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20{IERC20Caller: IERC20Caller{contract: contract}, IERC20Transactor: IERC20Transactor{contract: contract}, IERC20Filterer: IERC20Filterer{contract: contract}}, nil
}

// NewIERC20Caller creates a new read-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Caller(address common.Address, caller bind.ContractCaller) (*IERC20Caller, error) {
	contract, err := bindIERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Caller{contract: contract}, nil
}

// NewIERC20Transactor creates a new write-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC20Transactor, error) {
	contract, err := bindIERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Transactor{contract: contract}, nil
}

// NewIERC20Filterer creates a new log filterer instance of IERC20, bound to a specific deployed contract.
func NewIERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC20Filterer, error) {
	contract, err := bindIERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20Filterer{contract: contract}, nil
}

// bindIERC20 binds a generic wrapper to an already deployed contract.
func bindIERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.IERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _IERC20.contract.Call(opts, out, "allowance", owner, spender)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _IERC20.contract.Call(opts, out, "balanceOf", account)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _IERC20.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Session) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// IERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20 contract.
type IERC20ApprovalIterator struct {
	Event *IERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Approval represents a Approval event raised by the IERC20 contract.
type IERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20ApprovalIterator{contract: _IERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Approval)
				if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) ParseApproval(log types.Log) (*IERC20Approval, error) {
	event := new(IERC20Approval)
	if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20 contract.
type IERC20TransferIterator struct {
	Event *IERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Transfer represents a Transfer event raised by the IERC20 contract.
type IERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20TransferIterator{contract: _IERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Transfer)
				if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) ParseTransfer(log types.Log) (*IERC20Transfer, error) {
	event := new(IERC20Transfer)
	if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC20BridgeReceiverABI is the input ABI used to generate the binding from.
const IERC20BridgeReceiverABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onERC20Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC20BridgeReceiverBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC20BridgeReceiverBinRuntime = ``

// IERC20BridgeReceiverFuncSigs maps the 4-byte function signature to its string representation.
var IERC20BridgeReceiverFuncSigs = map[string]string{
	"f1656e53": "onERC20Received(address,address,uint256,uint256,bytes)",
}

// IERC20BridgeReceiver is an auto generated Go binding around a Klaytn contract.
type IERC20BridgeReceiver struct {
	IERC20BridgeReceiverCaller     // Read-only binding to the contract
	IERC20BridgeReceiverTransactor // Write-only binding to the contract
	IERC20BridgeReceiverFilterer   // Log filterer for contract events
}

// IERC20BridgeReceiverCaller is an auto generated read-only Go binding around a Klaytn contract.
type IERC20BridgeReceiverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20BridgeReceiverTransactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC20BridgeReceiverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20BridgeReceiverFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC20BridgeReceiverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20BridgeReceiverSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC20BridgeReceiverSession struct {
	Contract     *IERC20BridgeReceiver // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IERC20BridgeReceiverCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC20BridgeReceiverCallerSession struct {
	Contract *IERC20BridgeReceiverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// IERC20BridgeReceiverTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC20BridgeReceiverTransactorSession struct {
	Contract     *IERC20BridgeReceiverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// IERC20BridgeReceiverRaw is an auto generated low-level Go binding around a Klaytn contract.
type IERC20BridgeReceiverRaw struct {
	Contract *IERC20BridgeReceiver // Generic contract binding to access the raw methods on
}

// IERC20BridgeReceiverCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC20BridgeReceiverCallerRaw struct {
	Contract *IERC20BridgeReceiverCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20BridgeReceiverTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC20BridgeReceiverTransactorRaw struct {
	Contract *IERC20BridgeReceiverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20BridgeReceiver creates a new instance of IERC20BridgeReceiver, bound to a specific deployed contract.
func NewIERC20BridgeReceiver(address common.Address, backend bind.ContractBackend) (*IERC20BridgeReceiver, error) {
	contract, err := bindIERC20BridgeReceiver(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeReceiver{IERC20BridgeReceiverCaller: IERC20BridgeReceiverCaller{contract: contract}, IERC20BridgeReceiverTransactor: IERC20BridgeReceiverTransactor{contract: contract}, IERC20BridgeReceiverFilterer: IERC20BridgeReceiverFilterer{contract: contract}}, nil
}

// NewIERC20BridgeReceiverCaller creates a new read-only instance of IERC20BridgeReceiver, bound to a specific deployed contract.
func NewIERC20BridgeReceiverCaller(address common.Address, caller bind.ContractCaller) (*IERC20BridgeReceiverCaller, error) {
	contract, err := bindIERC20BridgeReceiver(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeReceiverCaller{contract: contract}, nil
}

// NewIERC20BridgeReceiverTransactor creates a new write-only instance of IERC20BridgeReceiver, bound to a specific deployed contract.
func NewIERC20BridgeReceiverTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20BridgeReceiverTransactor, error) {
	contract, err := bindIERC20BridgeReceiver(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeReceiverTransactor{contract: contract}, nil
}

// NewIERC20BridgeReceiverFilterer creates a new log filterer instance of IERC20BridgeReceiver, bound to a specific deployed contract.
func NewIERC20BridgeReceiverFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20BridgeReceiverFilterer, error) {
	contract, err := bindIERC20BridgeReceiver(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeReceiverFilterer{contract: contract}, nil
}

// bindIERC20BridgeReceiver binds a generic wrapper to an already deployed contract.
func bindIERC20BridgeReceiver(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20BridgeReceiverABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20BridgeReceiver *IERC20BridgeReceiverRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC20BridgeReceiver.Contract.IERC20BridgeReceiverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20BridgeReceiver *IERC20BridgeReceiverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20BridgeReceiver.Contract.IERC20BridgeReceiverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20BridgeReceiver *IERC20BridgeReceiverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20BridgeReceiver.Contract.IERC20BridgeReceiverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20BridgeReceiver *IERC20BridgeReceiverCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC20BridgeReceiver.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20BridgeReceiver *IERC20BridgeReceiverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20BridgeReceiver.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20BridgeReceiver *IERC20BridgeReceiverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20BridgeReceiver.Contract.contract.Transact(opts, method, params...)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _amount, uint256 _feeLimit, bytes _extraData) returns()
func (_IERC20BridgeReceiver *IERC20BridgeReceiverTransactor) OnERC20Received(opts *bind.TransactOpts, _from common.Address, _to common.Address, _amount *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _IERC20BridgeReceiver.contract.Transact(opts, "onERC20Received", _from, _to, _amount, _feeLimit, _extraData)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _amount, uint256 _feeLimit, bytes _extraData) returns()
func (_IERC20BridgeReceiver *IERC20BridgeReceiverSession) OnERC20Received(_from common.Address, _to common.Address, _amount *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _IERC20BridgeReceiver.Contract.OnERC20Received(&_IERC20BridgeReceiver.TransactOpts, _from, _to, _amount, _feeLimit, _extraData)
}

// OnERC20Received is a paid mutator transaction binding the contract method 0xf1656e53.
//
// Solidity: function onERC20Received(address _from, address _to, uint256 _amount, uint256 _feeLimit, bytes _extraData) returns()
func (_IERC20BridgeReceiver *IERC20BridgeReceiverTransactorSession) OnERC20Received(_from common.Address, _to common.Address, _amount *big.Int, _feeLimit *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _IERC20BridgeReceiver.Contract.OnERC20Received(&_IERC20BridgeReceiver.TransactOpts, _from, _to, _amount, _feeLimit, _extraData)
}

// IERC20MetadataABI is the input ABI used to generate the binding from.
const IERC20MetadataABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC20MetadataBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC20MetadataBinRuntime = ``

// IERC20MetadataFuncSigs maps the 4-byte function signature to its string representation.
var IERC20MetadataFuncSigs = map[string]string{
	"dd62ed3e": "allowance(address,address)",
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"313ce567": "decimals()",
	"06fdde03": "name()",
	"95d89b41": "symbol()",
	"18160ddd": "totalSupply()",
	"a9059cbb": "transfer(address,uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// IERC20Metadata is an auto generated Go binding around a Klaytn contract.
type IERC20Metadata struct {
	IERC20MetadataCaller     // Read-only binding to the contract
	IERC20MetadataTransactor // Write-only binding to the contract
	IERC20MetadataFilterer   // Log filterer for contract events
}

// IERC20MetadataCaller is an auto generated read-only Go binding around a Klaytn contract.
type IERC20MetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataTransactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC20MetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC20MetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC20MetadataSession struct {
	Contract     *IERC20Metadata   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20MetadataCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC20MetadataCallerSession struct {
	Contract *IERC20MetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IERC20MetadataTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC20MetadataTransactorSession struct {
	Contract     *IERC20MetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IERC20MetadataRaw is an auto generated low-level Go binding around a Klaytn contract.
type IERC20MetadataRaw struct {
	Contract *IERC20Metadata // Generic contract binding to access the raw methods on
}

// IERC20MetadataCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC20MetadataCallerRaw struct {
	Contract *IERC20MetadataCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20MetadataTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC20MetadataTransactorRaw struct {
	Contract *IERC20MetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Metadata creates a new instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20Metadata(address common.Address, backend bind.ContractBackend) (*IERC20Metadata, error) {
	contract, err := bindIERC20Metadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Metadata{IERC20MetadataCaller: IERC20MetadataCaller{contract: contract}, IERC20MetadataTransactor: IERC20MetadataTransactor{contract: contract}, IERC20MetadataFilterer: IERC20MetadataFilterer{contract: contract}}, nil
}

// NewIERC20MetadataCaller creates a new read-only instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataCaller(address common.Address, caller bind.ContractCaller) (*IERC20MetadataCaller, error) {
	contract, err := bindIERC20Metadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataCaller{contract: contract}, nil
}

// NewIERC20MetadataTransactor creates a new write-only instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20MetadataTransactor, error) {
	contract, err := bindIERC20Metadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataTransactor{contract: contract}, nil
}

// NewIERC20MetadataFilterer creates a new log filterer instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20MetadataFilterer, error) {
	contract, err := bindIERC20Metadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataFilterer{contract: contract}, nil
}

// bindIERC20Metadata binds a generic wrapper to an already deployed contract.
func bindIERC20Metadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20MetadataABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Metadata *IERC20MetadataRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC20Metadata.Contract.IERC20MetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Metadata *IERC20MetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.IERC20MetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Metadata *IERC20MetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.IERC20MetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Metadata *IERC20MetadataCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC20Metadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Metadata *IERC20MetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Metadata *IERC20MetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _IERC20Metadata.contract.Call(opts, out, "allowance", owner, spender)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.Allowance(&_IERC20Metadata.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.Allowance(&_IERC20Metadata.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _IERC20Metadata.contract.Call(opts, out, "balanceOf", account)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.BalanceOf(&_IERC20Metadata.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.BalanceOf(&_IERC20Metadata.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _IERC20Metadata.contract.Call(opts, out, "decimals")
	return *ret0, err
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataSession) Decimals() (uint8, error) {
	return _IERC20Metadata.Contract.Decimals(&_IERC20Metadata.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataCallerSession) Decimals() (uint8, error) {
	return _IERC20Metadata.Contract.Decimals(&_IERC20Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _IERC20Metadata.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataSession) Name() (string, error) {
	return _IERC20Metadata.Contract.Name(&_IERC20Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataCallerSession) Name() (string, error) {
	return _IERC20Metadata.Contract.Name(&_IERC20Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _IERC20Metadata.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataSession) Symbol() (string, error) {
	return _IERC20Metadata.Contract.Symbol(&_IERC20Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataCallerSession) Symbol() (string, error) {
	return _IERC20Metadata.Contract.Symbol(&_IERC20Metadata.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _IERC20Metadata.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) TotalSupply() (*big.Int, error) {
	return _IERC20Metadata.Contract.TotalSupply(&_IERC20Metadata.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20Metadata.Contract.TotalSupply(&_IERC20Metadata.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Approve(&_IERC20Metadata.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Approve(&_IERC20Metadata.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Transfer(&_IERC20Metadata.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Transfer(&_IERC20Metadata.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.TransferFrom(&_IERC20Metadata.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.TransferFrom(&_IERC20Metadata.TransactOpts, from, to, amount)
}

// IERC20MetadataApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20Metadata contract.
type IERC20MetadataApprovalIterator struct {
	Event *IERC20MetadataApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataApproval represents a Approval event raised by the IERC20Metadata contract.
type IERC20MetadataApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20MetadataApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Metadata.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataApprovalIterator{contract: _IERC20Metadata.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20MetadataApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Metadata.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataApproval)
				if err := _IERC20Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) ParseApproval(log types.Log) (*IERC20MetadataApproval, error) {
	event := new(IERC20MetadataApproval)
	if err := _IERC20Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC20MetadataTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20Metadata contract.
type IERC20MetadataTransferIterator struct {
	Event *IERC20MetadataTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataTransfer represents a Transfer event raised by the IERC20Metadata contract.
type IERC20MetadataTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20MetadataTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Metadata.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataTransferIterator{contract: _IERC20Metadata.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20MetadataTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Metadata.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataTransfer)
				if err := _IERC20Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) ParseTransfer(log types.Log) (*IERC20MetadataTransfer, error) {
	event := new(IERC20MetadataTransfer)
	if err := _IERC20Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC20MintABI is the input ABI used to generate the binding from.
const IERC20MintABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC20MintBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC20MintBinRuntime = ``

// IERC20MintFuncSigs maps the 4-byte function signature to its string representation.
var IERC20MintFuncSigs = map[string]string{
	"40c10f19": "mint(address,uint256)",
}

// IERC20Mint is an auto generated Go binding around a Klaytn contract.
type IERC20Mint struct {
	IERC20MintCaller     // Read-only binding to the contract
	IERC20MintTransactor // Write-only binding to the contract
	IERC20MintFilterer   // Log filterer for contract events
}

// IERC20MintCaller is an auto generated read-only Go binding around a Klaytn contract.
type IERC20MintCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MintTransactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC20MintTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MintFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC20MintFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MintSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC20MintSession struct {
	Contract     *IERC20Mint       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20MintCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC20MintCallerSession struct {
	Contract *IERC20MintCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// IERC20MintTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC20MintTransactorSession struct {
	Contract     *IERC20MintTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IERC20MintRaw is an auto generated low-level Go binding around a Klaytn contract.
type IERC20MintRaw struct {
	Contract *IERC20Mint // Generic contract binding to access the raw methods on
}

// IERC20MintCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC20MintCallerRaw struct {
	Contract *IERC20MintCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20MintTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC20MintTransactorRaw struct {
	Contract *IERC20MintTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Mint creates a new instance of IERC20Mint, bound to a specific deployed contract.
func NewIERC20Mint(address common.Address, backend bind.ContractBackend) (*IERC20Mint, error) {
	contract, err := bindIERC20Mint(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Mint{IERC20MintCaller: IERC20MintCaller{contract: contract}, IERC20MintTransactor: IERC20MintTransactor{contract: contract}, IERC20MintFilterer: IERC20MintFilterer{contract: contract}}, nil
}

// NewIERC20MintCaller creates a new read-only instance of IERC20Mint, bound to a specific deployed contract.
func NewIERC20MintCaller(address common.Address, caller bind.ContractCaller) (*IERC20MintCaller, error) {
	contract, err := bindIERC20Mint(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MintCaller{contract: contract}, nil
}

// NewIERC20MintTransactor creates a new write-only instance of IERC20Mint, bound to a specific deployed contract.
func NewIERC20MintTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20MintTransactor, error) {
	contract, err := bindIERC20Mint(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MintTransactor{contract: contract}, nil
}

// NewIERC20MintFilterer creates a new log filterer instance of IERC20Mint, bound to a specific deployed contract.
func NewIERC20MintFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20MintFilterer, error) {
	contract, err := bindIERC20Mint(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20MintFilterer{contract: contract}, nil
}

// bindIERC20Mint binds a generic wrapper to an already deployed contract.
func bindIERC20Mint(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20MintABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Mint *IERC20MintRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC20Mint.Contract.IERC20MintCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Mint *IERC20MintRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Mint.Contract.IERC20MintTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Mint *IERC20MintRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Mint.Contract.IERC20MintTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Mint *IERC20MintCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC20Mint.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Mint *IERC20MintTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Mint.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Mint *IERC20MintTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Mint.Contract.contract.Transact(opts, method, params...)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_IERC20Mint *IERC20MintTransactor) Mint(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Mint.contract.Transact(opts, "mint", to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_IERC20Mint *IERC20MintSession) Mint(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Mint.Contract.Mint(&_IERC20Mint.TransactOpts, to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_IERC20Mint *IERC20MintTransactorSession) Mint(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Mint.Contract.Mint(&_IERC20Mint.TransactOpts, to, amount)
}

// IERC721ABI is the input ABI used to generate the binding from.
const IERC721ABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC721BinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC721BinRuntime = ``

// IERC721FuncSigs maps the 4-byte function signature to its string representation.
var IERC721FuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"01ffc9a7": "supportsInterface(bytes4)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// IERC721 is an auto generated Go binding around a Klaytn contract.
type IERC721 struct {
	IERC721Caller     // Read-only binding to the contract
	IERC721Transactor // Write-only binding to the contract
	IERC721Filterer   // Log filterer for contract events
}

// IERC721Caller is an auto generated read-only Go binding around a Klaytn contract.
type IERC721Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721Transactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC721Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721Filterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC721Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721Session is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC721Session struct {
	Contract     *IERC721          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC721CallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC721CallerSession struct {
	Contract *IERC721Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// IERC721TransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC721TransactorSession struct {
	Contract     *IERC721Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IERC721Raw is an auto generated low-level Go binding around a Klaytn contract.
type IERC721Raw struct {
	Contract *IERC721 // Generic contract binding to access the raw methods on
}

// IERC721CallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC721CallerRaw struct {
	Contract *IERC721Caller // Generic read-only contract binding to access the raw methods on
}

// IERC721TransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC721TransactorRaw struct {
	Contract *IERC721Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC721 creates a new instance of IERC721, bound to a specific deployed contract.
func NewIERC721(address common.Address, backend bind.ContractBackend) (*IERC721, error) {
	contract, err := bindIERC721(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC721{IERC721Caller: IERC721Caller{contract: contract}, IERC721Transactor: IERC721Transactor{contract: contract}, IERC721Filterer: IERC721Filterer{contract: contract}}, nil
}

// NewIERC721Caller creates a new read-only instance of IERC721, bound to a specific deployed contract.
func NewIERC721Caller(address common.Address, caller bind.ContractCaller) (*IERC721Caller, error) {
	contract, err := bindIERC721(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721Caller{contract: contract}, nil
}

// NewIERC721Transactor creates a new write-only instance of IERC721, bound to a specific deployed contract.
func NewIERC721Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC721Transactor, error) {
	contract, err := bindIERC721(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721Transactor{contract: contract}, nil
}

// NewIERC721Filterer creates a new log filterer instance of IERC721, bound to a specific deployed contract.
func NewIERC721Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC721Filterer, error) {
	contract, err := bindIERC721(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC721Filterer{contract: contract}, nil
}

// bindIERC721 binds a generic wrapper to an already deployed contract.
func bindIERC721(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC721ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721 *IERC721Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721.Contract.IERC721Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721 *IERC721Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721.Contract.IERC721Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721 *IERC721Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721.Contract.IERC721Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721 *IERC721CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721 *IERC721TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721 *IERC721TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_IERC721 *IERC721Caller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _IERC721.contract.Call(opts, out, "balanceOf", owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_IERC721 *IERC721Session) BalanceOf(owner common.Address) (*big.Int, error) {
	return _IERC721.Contract.BalanceOf(&_IERC721.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_IERC721 *IERC721CallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _IERC721.Contract.BalanceOf(&_IERC721.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_IERC721 *IERC721Caller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _IERC721.contract.Call(opts, out, "getApproved", tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_IERC721 *IERC721Session) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _IERC721.Contract.GetApproved(&_IERC721.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_IERC721 *IERC721CallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _IERC721.Contract.GetApproved(&_IERC721.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_IERC721 *IERC721Caller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _IERC721.contract.Call(opts, out, "isApprovedForAll", owner, operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_IERC721 *IERC721Session) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _IERC721.Contract.IsApprovedForAll(&_IERC721.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_IERC721 *IERC721CallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _IERC721.Contract.IsApprovedForAll(&_IERC721.CallOpts, owner, operator)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_IERC721 *IERC721Caller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _IERC721.contract.Call(opts, out, "ownerOf", tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_IERC721 *IERC721Session) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _IERC721.Contract.OwnerOf(&_IERC721.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_IERC721 *IERC721CallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _IERC721.Contract.OwnerOf(&_IERC721.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC721 *IERC721Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _IERC721.contract.Call(opts, out, "supportsInterface", interfaceId)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC721 *IERC721Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC721.Contract.SupportsInterface(&_IERC721.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC721 *IERC721CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC721.Contract.SupportsInterface(&_IERC721.CallOpts, interfaceId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_IERC721 *IERC721Transactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_IERC721 *IERC721Session) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.Contract.Approve(&_IERC721.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_IERC721 *IERC721TransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.Contract.Approve(&_IERC721.TransactOpts, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721 *IERC721Transactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721 *IERC721Session) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.Contract.SafeTransferFrom(&_IERC721.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721 *IERC721TransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.Contract.SafeTransferFrom(&_IERC721.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_IERC721 *IERC721Transactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_IERC721 *IERC721Session) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721.Contract.SafeTransferFrom0(&_IERC721.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_IERC721 *IERC721TransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721.Contract.SafeTransferFrom0(&_IERC721.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool _approved) returns()
func (_IERC721 *IERC721Transactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, _approved bool) (*types.Transaction, error) {
	return _IERC721.contract.Transact(opts, "setApprovalForAll", operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool _approved) returns()
func (_IERC721 *IERC721Session) SetApprovalForAll(operator common.Address, _approved bool) (*types.Transaction, error) {
	return _IERC721.Contract.SetApprovalForAll(&_IERC721.TransactOpts, operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool _approved) returns()
func (_IERC721 *IERC721TransactorSession) SetApprovalForAll(operator common.Address, _approved bool) (*types.Transaction, error) {
	return _IERC721.Contract.SetApprovalForAll(&_IERC721.TransactOpts, operator, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721 *IERC721Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721 *IERC721Session) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.Contract.TransferFrom(&_IERC721.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721 *IERC721TransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721.Contract.TransferFrom(&_IERC721.TransactOpts, from, to, tokenId)
}

// IERC721ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC721 contract.
type IERC721ApprovalIterator struct {
	Event *IERC721Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC721ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC721Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC721Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC721ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC721ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC721Approval represents a Approval event raised by the IERC721 contract.
type IERC721Approval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_IERC721 *IERC721Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*IERC721ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _IERC721.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &IERC721ApprovalIterator{contract: _IERC721.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_IERC721 *IERC721Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC721Approval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _IERC721.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC721Approval)
				if err := _IERC721.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_IERC721 *IERC721Filterer) ParseApproval(log types.Log) (*IERC721Approval, error) {
	event := new(IERC721Approval)
	if err := _IERC721.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC721ApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the IERC721 contract.
type IERC721ApprovalForAllIterator struct {
	Event *IERC721ApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC721ApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC721ApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC721ApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC721ApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC721ApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC721ApprovalForAll represents a ApprovalForAll event raised by the IERC721 contract.
type IERC721ApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_IERC721 *IERC721Filterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*IERC721ApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IERC721.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &IERC721ApprovalForAllIterator{contract: _IERC721.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_IERC721 *IERC721Filterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *IERC721ApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IERC721.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC721ApprovalForAll)
				if err := _IERC721.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_IERC721 *IERC721Filterer) ParseApprovalForAll(log types.Log) (*IERC721ApprovalForAll, error) {
	event := new(IERC721ApprovalForAll)
	if err := _IERC721.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC721TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC721 contract.
type IERC721TransferIterator struct {
	Event *IERC721Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC721TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC721Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC721Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC721TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC721TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC721Transfer represents a Transfer event raised by the IERC721 contract.
type IERC721Transfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_IERC721 *IERC721Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*IERC721TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _IERC721.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &IERC721TransferIterator{contract: _IERC721.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_IERC721 *IERC721Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC721Transfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _IERC721.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC721Transfer)
				if err := _IERC721.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_IERC721 *IERC721Filterer) ParseTransfer(log types.Log) (*IERC721Transfer, error) {
	event := new(IERC721Transfer)
	if err := _IERC721.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC721BridgeReceiverABI is the input ABI used to generate the binding from.
const IERC721BridgeReceiverABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC721BridgeReceiverBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC721BridgeReceiverBinRuntime = ``

// IERC721BridgeReceiverFuncSigs maps the 4-byte function signature to its string representation.
var IERC721BridgeReceiverFuncSigs = map[string]string{
	"cf0da290": "onERC721Received(address,uint256,address,bytes)",
}

// IERC721BridgeReceiver is an auto generated Go binding around a Klaytn contract.
type IERC721BridgeReceiver struct {
	IERC721BridgeReceiverCaller     // Read-only binding to the contract
	IERC721BridgeReceiverTransactor // Write-only binding to the contract
	IERC721BridgeReceiverFilterer   // Log filterer for contract events
}

// IERC721BridgeReceiverCaller is an auto generated read-only Go binding around a Klaytn contract.
type IERC721BridgeReceiverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721BridgeReceiverTransactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC721BridgeReceiverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721BridgeReceiverFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC721BridgeReceiverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721BridgeReceiverSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC721BridgeReceiverSession struct {
	Contract     *IERC721BridgeReceiver // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// IERC721BridgeReceiverCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC721BridgeReceiverCallerSession struct {
	Contract *IERC721BridgeReceiverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// IERC721BridgeReceiverTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC721BridgeReceiverTransactorSession struct {
	Contract     *IERC721BridgeReceiverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// IERC721BridgeReceiverRaw is an auto generated low-level Go binding around a Klaytn contract.
type IERC721BridgeReceiverRaw struct {
	Contract *IERC721BridgeReceiver // Generic contract binding to access the raw methods on
}

// IERC721BridgeReceiverCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC721BridgeReceiverCallerRaw struct {
	Contract *IERC721BridgeReceiverCaller // Generic read-only contract binding to access the raw methods on
}

// IERC721BridgeReceiverTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC721BridgeReceiverTransactorRaw struct {
	Contract *IERC721BridgeReceiverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC721BridgeReceiver creates a new instance of IERC721BridgeReceiver, bound to a specific deployed contract.
func NewIERC721BridgeReceiver(address common.Address, backend bind.ContractBackend) (*IERC721BridgeReceiver, error) {
	contract, err := bindIERC721BridgeReceiver(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC721BridgeReceiver{IERC721BridgeReceiverCaller: IERC721BridgeReceiverCaller{contract: contract}, IERC721BridgeReceiverTransactor: IERC721BridgeReceiverTransactor{contract: contract}, IERC721BridgeReceiverFilterer: IERC721BridgeReceiverFilterer{contract: contract}}, nil
}

// NewIERC721BridgeReceiverCaller creates a new read-only instance of IERC721BridgeReceiver, bound to a specific deployed contract.
func NewIERC721BridgeReceiverCaller(address common.Address, caller bind.ContractCaller) (*IERC721BridgeReceiverCaller, error) {
	contract, err := bindIERC721BridgeReceiver(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721BridgeReceiverCaller{contract: contract}, nil
}

// NewIERC721BridgeReceiverTransactor creates a new write-only instance of IERC721BridgeReceiver, bound to a specific deployed contract.
func NewIERC721BridgeReceiverTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC721BridgeReceiverTransactor, error) {
	contract, err := bindIERC721BridgeReceiver(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721BridgeReceiverTransactor{contract: contract}, nil
}

// NewIERC721BridgeReceiverFilterer creates a new log filterer instance of IERC721BridgeReceiver, bound to a specific deployed contract.
func NewIERC721BridgeReceiverFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC721BridgeReceiverFilterer, error) {
	contract, err := bindIERC721BridgeReceiver(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC721BridgeReceiverFilterer{contract: contract}, nil
}

// bindIERC721BridgeReceiver binds a generic wrapper to an already deployed contract.
func bindIERC721BridgeReceiver(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC721BridgeReceiverABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721BridgeReceiver *IERC721BridgeReceiverRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721BridgeReceiver.Contract.IERC721BridgeReceiverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721BridgeReceiver *IERC721BridgeReceiverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721BridgeReceiver.Contract.IERC721BridgeReceiverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721BridgeReceiver *IERC721BridgeReceiverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721BridgeReceiver.Contract.IERC721BridgeReceiverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721BridgeReceiver *IERC721BridgeReceiverCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721BridgeReceiver.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721BridgeReceiver *IERC721BridgeReceiverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721BridgeReceiver.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721BridgeReceiver *IERC721BridgeReceiverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721BridgeReceiver.Contract.contract.Transact(opts, method, params...)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_IERC721BridgeReceiver *IERC721BridgeReceiverTransactor) OnERC721Received(opts *bind.TransactOpts, _from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _IERC721BridgeReceiver.contract.Transact(opts, "onERC721Received", _from, _tokenId, _to, _extraData)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_IERC721BridgeReceiver *IERC721BridgeReceiverSession) OnERC721Received(_from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _IERC721BridgeReceiver.Contract.OnERC721Received(&_IERC721BridgeReceiver.TransactOpts, _from, _tokenId, _to, _extraData)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xcf0da290.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, address _to, bytes _extraData) returns()
func (_IERC721BridgeReceiver *IERC721BridgeReceiverTransactorSession) OnERC721Received(_from common.Address, _tokenId *big.Int, _to common.Address, _extraData []byte) (*types.Transaction, error) {
	return _IERC721BridgeReceiver.Contract.OnERC721Received(&_IERC721BridgeReceiver.TransactOpts, _from, _tokenId, _to, _extraData)
}

// IERC721MetadataABI is the input ABI used to generate the binding from.
const IERC721MetadataABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC721MetadataBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC721MetadataBinRuntime = ``

// IERC721MetadataFuncSigs maps the 4-byte function signature to its string representation.
var IERC721MetadataFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"01ffc9a7": "supportsInterface(bytes4)",
	"95d89b41": "symbol()",
	"c87b56dd": "tokenURI(uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// IERC721Metadata is an auto generated Go binding around a Klaytn contract.
type IERC721Metadata struct {
	IERC721MetadataCaller     // Read-only binding to the contract
	IERC721MetadataTransactor // Write-only binding to the contract
	IERC721MetadataFilterer   // Log filterer for contract events
}

// IERC721MetadataCaller is an auto generated read-only Go binding around a Klaytn contract.
type IERC721MetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721MetadataTransactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC721MetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721MetadataFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC721MetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721MetadataSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC721MetadataSession struct {
	Contract     *IERC721Metadata  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC721MetadataCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC721MetadataCallerSession struct {
	Contract *IERC721MetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// IERC721MetadataTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC721MetadataTransactorSession struct {
	Contract     *IERC721MetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// IERC721MetadataRaw is an auto generated low-level Go binding around a Klaytn contract.
type IERC721MetadataRaw struct {
	Contract *IERC721Metadata // Generic contract binding to access the raw methods on
}

// IERC721MetadataCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC721MetadataCallerRaw struct {
	Contract *IERC721MetadataCaller // Generic read-only contract binding to access the raw methods on
}

// IERC721MetadataTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC721MetadataTransactorRaw struct {
	Contract *IERC721MetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC721Metadata creates a new instance of IERC721Metadata, bound to a specific deployed contract.
func NewIERC721Metadata(address common.Address, backend bind.ContractBackend) (*IERC721Metadata, error) {
	contract, err := bindIERC721Metadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC721Metadata{IERC721MetadataCaller: IERC721MetadataCaller{contract: contract}, IERC721MetadataTransactor: IERC721MetadataTransactor{contract: contract}, IERC721MetadataFilterer: IERC721MetadataFilterer{contract: contract}}, nil
}

// NewIERC721MetadataCaller creates a new read-only instance of IERC721Metadata, bound to a specific deployed contract.
func NewIERC721MetadataCaller(address common.Address, caller bind.ContractCaller) (*IERC721MetadataCaller, error) {
	contract, err := bindIERC721Metadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721MetadataCaller{contract: contract}, nil
}

// NewIERC721MetadataTransactor creates a new write-only instance of IERC721Metadata, bound to a specific deployed contract.
func NewIERC721MetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC721MetadataTransactor, error) {
	contract, err := bindIERC721Metadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721MetadataTransactor{contract: contract}, nil
}

// NewIERC721MetadataFilterer creates a new log filterer instance of IERC721Metadata, bound to a specific deployed contract.
func NewIERC721MetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC721MetadataFilterer, error) {
	contract, err := bindIERC721Metadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC721MetadataFilterer{contract: contract}, nil
}

// bindIERC721Metadata binds a generic wrapper to an already deployed contract.
func bindIERC721Metadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC721MetadataABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721Metadata *IERC721MetadataRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721Metadata.Contract.IERC721MetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721Metadata *IERC721MetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.IERC721MetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721Metadata *IERC721MetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.IERC721MetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721Metadata *IERC721MetadataCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721Metadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721Metadata *IERC721MetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721Metadata *IERC721MetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_IERC721Metadata *IERC721MetadataCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _IERC721Metadata.contract.Call(opts, out, "balanceOf", owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_IERC721Metadata *IERC721MetadataSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _IERC721Metadata.Contract.BalanceOf(&_IERC721Metadata.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_IERC721Metadata *IERC721MetadataCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _IERC721Metadata.Contract.BalanceOf(&_IERC721Metadata.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_IERC721Metadata *IERC721MetadataCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _IERC721Metadata.contract.Call(opts, out, "getApproved", tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_IERC721Metadata *IERC721MetadataSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _IERC721Metadata.Contract.GetApproved(&_IERC721Metadata.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_IERC721Metadata *IERC721MetadataCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _IERC721Metadata.Contract.GetApproved(&_IERC721Metadata.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_IERC721Metadata *IERC721MetadataCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _IERC721Metadata.contract.Call(opts, out, "isApprovedForAll", owner, operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_IERC721Metadata *IERC721MetadataSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _IERC721Metadata.Contract.IsApprovedForAll(&_IERC721Metadata.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_IERC721Metadata *IERC721MetadataCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _IERC721Metadata.Contract.IsApprovedForAll(&_IERC721Metadata.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC721Metadata *IERC721MetadataCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _IERC721Metadata.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC721Metadata *IERC721MetadataSession) Name() (string, error) {
	return _IERC721Metadata.Contract.Name(&_IERC721Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC721Metadata *IERC721MetadataCallerSession) Name() (string, error) {
	return _IERC721Metadata.Contract.Name(&_IERC721Metadata.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_IERC721Metadata *IERC721MetadataCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _IERC721Metadata.contract.Call(opts, out, "ownerOf", tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_IERC721Metadata *IERC721MetadataSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _IERC721Metadata.Contract.OwnerOf(&_IERC721Metadata.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_IERC721Metadata *IERC721MetadataCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _IERC721Metadata.Contract.OwnerOf(&_IERC721Metadata.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC721Metadata *IERC721MetadataCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _IERC721Metadata.contract.Call(opts, out, "supportsInterface", interfaceId)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC721Metadata *IERC721MetadataSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC721Metadata.Contract.SupportsInterface(&_IERC721Metadata.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC721Metadata *IERC721MetadataCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC721Metadata.Contract.SupportsInterface(&_IERC721Metadata.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC721Metadata *IERC721MetadataCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _IERC721Metadata.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC721Metadata *IERC721MetadataSession) Symbol() (string, error) {
	return _IERC721Metadata.Contract.Symbol(&_IERC721Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC721Metadata *IERC721MetadataCallerSession) Symbol() (string, error) {
	return _IERC721Metadata.Contract.Symbol(&_IERC721Metadata.CallOpts)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_IERC721Metadata *IERC721MetadataCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _IERC721Metadata.contract.Call(opts, out, "tokenURI", tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_IERC721Metadata *IERC721MetadataSession) TokenURI(tokenId *big.Int) (string, error) {
	return _IERC721Metadata.Contract.TokenURI(&_IERC721Metadata.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_IERC721Metadata *IERC721MetadataCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _IERC721Metadata.Contract.TokenURI(&_IERC721Metadata.CallOpts, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.Approve(&_IERC721Metadata.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.Approve(&_IERC721Metadata.TransactOpts, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.SafeTransferFrom(&_IERC721Metadata.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.SafeTransferFrom(&_IERC721Metadata.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_IERC721Metadata *IERC721MetadataTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721Metadata.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_IERC721Metadata *IERC721MetadataSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.SafeTransferFrom0(&_IERC721Metadata.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_IERC721Metadata *IERC721MetadataTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.SafeTransferFrom0(&_IERC721Metadata.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool _approved) returns()
func (_IERC721Metadata *IERC721MetadataTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, _approved bool) (*types.Transaction, error) {
	return _IERC721Metadata.contract.Transact(opts, "setApprovalForAll", operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool _approved) returns()
func (_IERC721Metadata *IERC721MetadataSession) SetApprovalForAll(operator common.Address, _approved bool) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.SetApprovalForAll(&_IERC721Metadata.TransactOpts, operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool _approved) returns()
func (_IERC721Metadata *IERC721MetadataTransactorSession) SetApprovalForAll(operator common.Address, _approved bool) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.SetApprovalForAll(&_IERC721Metadata.TransactOpts, operator, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.TransferFrom(&_IERC721Metadata.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_IERC721Metadata *IERC721MetadataTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _IERC721Metadata.Contract.TransferFrom(&_IERC721Metadata.TransactOpts, from, to, tokenId)
}

// IERC721MetadataApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC721Metadata contract.
type IERC721MetadataApprovalIterator struct {
	Event *IERC721MetadataApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC721MetadataApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC721MetadataApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC721MetadataApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC721MetadataApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC721MetadataApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC721MetadataApproval represents a Approval event raised by the IERC721Metadata contract.
type IERC721MetadataApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_IERC721Metadata *IERC721MetadataFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*IERC721MetadataApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _IERC721Metadata.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &IERC721MetadataApprovalIterator{contract: _IERC721Metadata.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_IERC721Metadata *IERC721MetadataFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC721MetadataApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _IERC721Metadata.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC721MetadataApproval)
				if err := _IERC721Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_IERC721Metadata *IERC721MetadataFilterer) ParseApproval(log types.Log) (*IERC721MetadataApproval, error) {
	event := new(IERC721MetadataApproval)
	if err := _IERC721Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC721MetadataApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the IERC721Metadata contract.
type IERC721MetadataApprovalForAllIterator struct {
	Event *IERC721MetadataApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC721MetadataApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC721MetadataApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC721MetadataApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC721MetadataApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC721MetadataApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC721MetadataApprovalForAll represents a ApprovalForAll event raised by the IERC721Metadata contract.
type IERC721MetadataApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_IERC721Metadata *IERC721MetadataFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*IERC721MetadataApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IERC721Metadata.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &IERC721MetadataApprovalForAllIterator{contract: _IERC721Metadata.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_IERC721Metadata *IERC721MetadataFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *IERC721MetadataApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IERC721Metadata.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC721MetadataApprovalForAll)
				if err := _IERC721Metadata.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_IERC721Metadata *IERC721MetadataFilterer) ParseApprovalForAll(log types.Log) (*IERC721MetadataApprovalForAll, error) {
	event := new(IERC721MetadataApprovalForAll)
	if err := _IERC721Metadata.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC721MetadataTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC721Metadata contract.
type IERC721MetadataTransferIterator struct {
	Event *IERC721MetadataTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC721MetadataTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC721MetadataTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC721MetadataTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC721MetadataTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC721MetadataTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC721MetadataTransfer represents a Transfer event raised by the IERC721Metadata contract.
type IERC721MetadataTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_IERC721Metadata *IERC721MetadataFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*IERC721MetadataTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _IERC721Metadata.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &IERC721MetadataTransferIterator{contract: _IERC721Metadata.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_IERC721Metadata *IERC721MetadataFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC721MetadataTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _IERC721Metadata.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC721MetadataTransfer)
				if err := _IERC721Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_IERC721Metadata *IERC721MetadataFilterer) ParseTransfer(log types.Log) (*IERC721MetadataTransfer, error) {
	event := new(IERC721MetadataTransfer)
	if err := _IERC721Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IERC721MintABI is the input ABI used to generate the binding from.
const IERC721MintABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"}],\"name\":\"mintWithTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC721MintBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC721MintBinRuntime = ``

// IERC721MintFuncSigs maps the 4-byte function signature to its string representation.
var IERC721MintFuncSigs = map[string]string{
	"50bb4e7f": "mintWithTokenURI(address,uint256,string)",
}

// IERC721Mint is an auto generated Go binding around a Klaytn contract.
type IERC721Mint struct {
	IERC721MintCaller     // Read-only binding to the contract
	IERC721MintTransactor // Write-only binding to the contract
	IERC721MintFilterer   // Log filterer for contract events
}

// IERC721MintCaller is an auto generated read-only Go binding around a Klaytn contract.
type IERC721MintCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721MintTransactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC721MintTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721MintFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC721MintFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721MintSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC721MintSession struct {
	Contract     *IERC721Mint      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC721MintCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC721MintCallerSession struct {
	Contract *IERC721MintCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// IERC721MintTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC721MintTransactorSession struct {
	Contract     *IERC721MintTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// IERC721MintRaw is an auto generated low-level Go binding around a Klaytn contract.
type IERC721MintRaw struct {
	Contract *IERC721Mint // Generic contract binding to access the raw methods on
}

// IERC721MintCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC721MintCallerRaw struct {
	Contract *IERC721MintCaller // Generic read-only contract binding to access the raw methods on
}

// IERC721MintTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC721MintTransactorRaw struct {
	Contract *IERC721MintTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC721Mint creates a new instance of IERC721Mint, bound to a specific deployed contract.
func NewIERC721Mint(address common.Address, backend bind.ContractBackend) (*IERC721Mint, error) {
	contract, err := bindIERC721Mint(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC721Mint{IERC721MintCaller: IERC721MintCaller{contract: contract}, IERC721MintTransactor: IERC721MintTransactor{contract: contract}, IERC721MintFilterer: IERC721MintFilterer{contract: contract}}, nil
}

// NewIERC721MintCaller creates a new read-only instance of IERC721Mint, bound to a specific deployed contract.
func NewIERC721MintCaller(address common.Address, caller bind.ContractCaller) (*IERC721MintCaller, error) {
	contract, err := bindIERC721Mint(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721MintCaller{contract: contract}, nil
}

// NewIERC721MintTransactor creates a new write-only instance of IERC721Mint, bound to a specific deployed contract.
func NewIERC721MintTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC721MintTransactor, error) {
	contract, err := bindIERC721Mint(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721MintTransactor{contract: contract}, nil
}

// NewIERC721MintFilterer creates a new log filterer instance of IERC721Mint, bound to a specific deployed contract.
func NewIERC721MintFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC721MintFilterer, error) {
	contract, err := bindIERC721Mint(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC721MintFilterer{contract: contract}, nil
}

// bindIERC721Mint binds a generic wrapper to an already deployed contract.
func bindIERC721Mint(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC721MintABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721Mint *IERC721MintRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721Mint.Contract.IERC721MintCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721Mint *IERC721MintRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721Mint.Contract.IERC721MintTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721Mint *IERC721MintRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721Mint.Contract.IERC721MintTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721Mint *IERC721MintCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721Mint.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721Mint *IERC721MintTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721Mint.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721Mint *IERC721MintTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721Mint.Contract.contract.Transact(opts, method, params...)
}

// MintWithTokenURI is a paid mutator transaction binding the contract method 0x50bb4e7f.
//
// Solidity: function mintWithTokenURI(address to, uint256 tokenId, string tokenURI) returns()
func (_IERC721Mint *IERC721MintTransactor) MintWithTokenURI(opts *bind.TransactOpts, to common.Address, tokenId *big.Int, tokenURI string) (*types.Transaction, error) {
	return _IERC721Mint.contract.Transact(opts, "mintWithTokenURI", to, tokenId, tokenURI)
}

// MintWithTokenURI is a paid mutator transaction binding the contract method 0x50bb4e7f.
//
// Solidity: function mintWithTokenURI(address to, uint256 tokenId, string tokenURI) returns()
func (_IERC721Mint *IERC721MintSession) MintWithTokenURI(to common.Address, tokenId *big.Int, tokenURI string) (*types.Transaction, error) {
	return _IERC721Mint.Contract.MintWithTokenURI(&_IERC721Mint.TransactOpts, to, tokenId, tokenURI)
}

// MintWithTokenURI is a paid mutator transaction binding the contract method 0x50bb4e7f.
//
// Solidity: function mintWithTokenURI(address to, uint256 tokenId, string tokenURI) returns()
func (_IERC721Mint *IERC721MintTransactorSession) MintWithTokenURI(to common.Address, tokenId *big.Int, tokenURI string) (*types.Transaction, error) {
	return _IERC721Mint.Contract.MintWithTokenURI(&_IERC721Mint.TransactOpts, to, tokenId, tokenURI)
}

// IERC721ReceiverABI is the input ABI used to generate the binding from.
const IERC721ReceiverABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC721ReceiverBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const IERC721ReceiverBinRuntime = ``

// IERC721ReceiverFuncSigs maps the 4-byte function signature to its string representation.
var IERC721ReceiverFuncSigs = map[string]string{
	"150b7a02": "onERC721Received(address,address,uint256,bytes)",
}

// IERC721Receiver is an auto generated Go binding around a Klaytn contract.
type IERC721Receiver struct {
	IERC721ReceiverCaller     // Read-only binding to the contract
	IERC721ReceiverTransactor // Write-only binding to the contract
	IERC721ReceiverFilterer   // Log filterer for contract events
}

// IERC721ReceiverCaller is an auto generated read-only Go binding around a Klaytn contract.
type IERC721ReceiverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721ReceiverTransactor is an auto generated write-only Go binding around a Klaytn contract.
type IERC721ReceiverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721ReceiverFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type IERC721ReceiverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC721ReceiverSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type IERC721ReceiverSession struct {
	Contract     *IERC721Receiver  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC721ReceiverCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type IERC721ReceiverCallerSession struct {
	Contract *IERC721ReceiverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// IERC721ReceiverTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type IERC721ReceiverTransactorSession struct {
	Contract     *IERC721ReceiverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// IERC721ReceiverRaw is an auto generated low-level Go binding around a Klaytn contract.
type IERC721ReceiverRaw struct {
	Contract *IERC721Receiver // Generic contract binding to access the raw methods on
}

// IERC721ReceiverCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type IERC721ReceiverCallerRaw struct {
	Contract *IERC721ReceiverCaller // Generic read-only contract binding to access the raw methods on
}

// IERC721ReceiverTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type IERC721ReceiverTransactorRaw struct {
	Contract *IERC721ReceiverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC721Receiver creates a new instance of IERC721Receiver, bound to a specific deployed contract.
func NewIERC721Receiver(address common.Address, backend bind.ContractBackend) (*IERC721Receiver, error) {
	contract, err := bindIERC721Receiver(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC721Receiver{IERC721ReceiverCaller: IERC721ReceiverCaller{contract: contract}, IERC721ReceiverTransactor: IERC721ReceiverTransactor{contract: contract}, IERC721ReceiverFilterer: IERC721ReceiverFilterer{contract: contract}}, nil
}

// NewIERC721ReceiverCaller creates a new read-only instance of IERC721Receiver, bound to a specific deployed contract.
func NewIERC721ReceiverCaller(address common.Address, caller bind.ContractCaller) (*IERC721ReceiverCaller, error) {
	contract, err := bindIERC721Receiver(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721ReceiverCaller{contract: contract}, nil
}

// NewIERC721ReceiverTransactor creates a new write-only instance of IERC721Receiver, bound to a specific deployed contract.
func NewIERC721ReceiverTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC721ReceiverTransactor, error) {
	contract, err := bindIERC721Receiver(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC721ReceiverTransactor{contract: contract}, nil
}

// NewIERC721ReceiverFilterer creates a new log filterer instance of IERC721Receiver, bound to a specific deployed contract.
func NewIERC721ReceiverFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC721ReceiverFilterer, error) {
	contract, err := bindIERC721Receiver(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC721ReceiverFilterer{contract: contract}, nil
}

// bindIERC721Receiver binds a generic wrapper to an already deployed contract.
func bindIERC721Receiver(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC721ReceiverABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721Receiver *IERC721ReceiverRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721Receiver.Contract.IERC721ReceiverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721Receiver *IERC721ReceiverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721Receiver.Contract.IERC721ReceiverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721Receiver *IERC721ReceiverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721Receiver.Contract.IERC721ReceiverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC721Receiver *IERC721ReceiverCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IERC721Receiver.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC721Receiver *IERC721ReceiverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC721Receiver.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC721Receiver *IERC721ReceiverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC721Receiver.Contract.contract.Transact(opts, method, params...)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address operator, address from, uint256 tokenId, bytes data) returns(bytes4)
func (_IERC721Receiver *IERC721ReceiverTransactor) OnERC721Received(opts *bind.TransactOpts, operator common.Address, from common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721Receiver.contract.Transact(opts, "onERC721Received", operator, from, tokenId, data)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address operator, address from, uint256 tokenId, bytes data) returns(bytes4)
func (_IERC721Receiver *IERC721ReceiverSession) OnERC721Received(operator common.Address, from common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721Receiver.Contract.OnERC721Received(&_IERC721Receiver.TransactOpts, operator, from, tokenId, data)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address operator, address from, uint256 tokenId, bytes data) returns(bytes4)
func (_IERC721Receiver *IERC721ReceiverTransactorSession) OnERC721Received(operator common.Address, from common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC721Receiver.Contract.OnERC721Received(&_IERC721Receiver.TransactOpts, operator, from, tokenId, data)
}

// OwnableABI is the input ABI used to generate the binding from.
const OwnableABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// OwnableBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const OwnableBinRuntime = ``

// OwnableFuncSigs maps the 4-byte function signature to its string representation.
var OwnableFuncSigs = map[string]string{
	"8da5cb5b": "owner()",
	"715018a6": "renounceOwnership()",
	"f2fde38b": "transferOwnership(address)",
}

// Ownable is an auto generated Go binding around a Klaytn contract.
type Ownable struct {
	OwnableCaller     // Read-only binding to the contract
	OwnableTransactor // Write-only binding to the contract
	OwnableFilterer   // Log filterer for contract events
}

// OwnableCaller is an auto generated read-only Go binding around a Klaytn contract.
type OwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableTransactor is an auto generated write-only Go binding around a Klaytn contract.
type OwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type OwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type OwnableSession struct {
	Contract     *Ownable          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnableCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type OwnableCallerSession struct {
	Contract *OwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OwnableTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type OwnableTransactorSession struct {
	Contract     *OwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OwnableRaw is an auto generated low-level Go binding around a Klaytn contract.
type OwnableRaw struct {
	Contract *Ownable // Generic contract binding to access the raw methods on
}

// OwnableCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type OwnableCallerRaw struct {
	Contract *OwnableCaller // Generic read-only contract binding to access the raw methods on
}

// OwnableTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type OwnableTransactorRaw struct {
	Contract *OwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwnable creates a new instance of Ownable, bound to a specific deployed contract.
func NewOwnable(address common.Address, backend bind.ContractBackend) (*Ownable, error) {
	contract, err := bindOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// NewOwnableCaller creates a new read-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableCaller(address common.Address, caller bind.ContractCaller) (*OwnableCaller, error) {
	contract, err := bindOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableCaller{contract: contract}, nil
}

// NewOwnableTransactor creates a new write-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnableTransactor, error) {
	contract, err := bindOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableTransactor{contract: contract}, nil
}

// NewOwnableFilterer creates a new log filterer instance of Ownable, bound to a specific deployed contract.
func NewOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnableFilterer, error) {
	contract, err := bindOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnableFilterer{contract: contract}, nil
}

// bindOwnable binds a generic wrapper to an already deployed contract.
func bindOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OwnableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.OwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Ownable.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCallerSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// OwnableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Ownable contract.
type OwnableOwnershipTransferredIterator struct {
	Event *OwnableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log      // Log channel receiving the found contract events
	sub  klaytn.Subscription // Subscription for errors, completion and termination
	done bool                // Whether the subscription completed delivering logs
	fail error               // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnableOwnershipTransferred represents a OwnershipTransferred event raised by the Ownable contract.
type OwnableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OwnableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OwnableOwnershipTransferredIterator{contract: _Ownable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OwnableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnableOwnershipTransferred)
				if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) ParseOwnershipTransferred(log types.Log) (*OwnableOwnershipTransferred, error) {
	event := new(OwnableOwnershipTransferred)
	if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StringsABI is the input ABI used to generate the binding from.
const StringsABI = "[]"

// StringsBinRuntime is the compiled bytecode used for adding genesis block without deploying code.
const StringsBinRuntime = `73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dfa49bc152ab2a1f7bc0d8b1b553b8aa2265a04b8f667ccecdb0b981127e2e1164736f6c634300080d0033`

// StringsBin is the compiled bytecode used for deploying new contracts.
var StringsBin = "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dfa49bc152ab2a1f7bc0d8b1b553b8aa2265a04b8f667ccecdb0b981127e2e1164736f6c634300080d0033"

// DeployStrings deploys a new Klaytn contract, binding an instance of Strings to it.
func DeployStrings(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Strings, error) {
	parsed, err := abi.JSON(strings.NewReader(StringsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(StringsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// Strings is an auto generated Go binding around a Klaytn contract.
type Strings struct {
	StringsCaller     // Read-only binding to the contract
	StringsTransactor // Write-only binding to the contract
	StringsFilterer   // Log filterer for contract events
}

// StringsCaller is an auto generated read-only Go binding around a Klaytn contract.
type StringsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsTransactor is an auto generated write-only Go binding around a Klaytn contract.
type StringsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsFilterer is an auto generated log filtering Go binding around a Klaytn contract events.
type StringsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsSession is an auto generated Go binding around a Klaytn contract,
// with pre-set call and transact options.
type StringsSession struct {
	Contract     *Strings          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StringsCallerSession is an auto generated read-only Go binding around a Klaytn contract,
// with pre-set call options.
type StringsCallerSession struct {
	Contract *StringsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StringsTransactorSession is an auto generated write-only Go binding around a Klaytn contract,
// with pre-set transact options.
type StringsTransactorSession struct {
	Contract     *StringsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StringsRaw is an auto generated low-level Go binding around a Klaytn contract.
type StringsRaw struct {
	Contract *Strings // Generic contract binding to access the raw methods on
}

// StringsCallerRaw is an auto generated low-level read-only Go binding around a Klaytn contract.
type StringsCallerRaw struct {
	Contract *StringsCaller // Generic read-only contract binding to access the raw methods on
}

// StringsTransactorRaw is an auto generated low-level write-only Go binding around a Klaytn contract.
type StringsTransactorRaw struct {
	Contract *StringsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStrings creates a new instance of Strings, bound to a specific deployed contract.
func NewStrings(address common.Address, backend bind.ContractBackend) (*Strings, error) {
	contract, err := bindStrings(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// NewStringsCaller creates a new read-only instance of Strings, bound to a specific deployed contract.
func NewStringsCaller(address common.Address, caller bind.ContractCaller) (*StringsCaller, error) {
	contract, err := bindStrings(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StringsCaller{contract: contract}, nil
}

// NewStringsTransactor creates a new write-only instance of Strings, bound to a specific deployed contract.
func NewStringsTransactor(address common.Address, transactor bind.ContractTransactor) (*StringsTransactor, error) {
	contract, err := bindStrings(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StringsTransactor{contract: contract}, nil
}

// NewStringsFilterer creates a new log filterer instance of Strings, bound to a specific deployed contract.
func NewStringsFilterer(address common.Address, filterer bind.ContractFilterer) (*StringsFilterer, error) {
	contract, err := bindStrings(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StringsFilterer{contract: contract}, nil
}

// bindStrings binds a generic wrapper to an already deployed contract.
func bindStrings(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StringsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.StringsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transact(opts, method, params...)
}
